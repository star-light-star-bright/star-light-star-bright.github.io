<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Scala学习笔记, ZWHBlog">
    <meta name="description" content="ScalaScala是一门以java虚拟机为运行环境，并将面向对象和函数式编程最佳特性结合在一起的静态类型编程语言
在大数据中
海量数据的采集、存储、计算
存储hbase
计算mapreduce
java编写完成后，由javac编译成.cl">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    

    <title>Scala学习笔记 | ZWHBlog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.2.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">ZWHBlog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">ZWHBlog</div>
        <div class="logo-desc">
            
            这是我的博客网站
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/12.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Scala学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Scala/">
                                <span class="chip bg-color">Scala</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Scala/" class="post-category">
                                Scala
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-07-27
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><p>Scala是一门以<strong>java虚拟机为运行环境</strong>，并将面向对象和函数式编程最佳特性结合在一起的<strong>静态类型编程语言</strong></p>
<p>在大数据中</p>
<p>海量数据的采集、存储、计算</p>
<p>存储hbase</p>
<p>计算mapreduce</p>
<p>java编写完成后，由javac编译成.class文件，在jvm上运行，在java的类库中(jdk)找到对应源码，然后运行</p>
<p><img src="/scala/scala/image-20200214154841642.png" alt="image-20200214154841642"></p>
<p>Scala可以使用java的部分语法 </p>
<p>scala有自己的特有语法</p>
<p>val map &#x3D; Map((“”,””),(“”,””))</p>
<p>同时还增强了一些功能，函数式编程</p>
<p>偏函数</p>
<p>函数的柯里化</p>
<p>将函数作为参数传递</p>
<p>而Scala在拥有特有的类库，还对java的类进行了包装 </p>
<p>在运行时，通过scalac编译器运行</p>
<h4 id="Scala的安装"><a href="#Scala的安装" class="headerlink" title="Scala的安装"></a>Scala的安装</h4><p>下载好tgz包，然后传到虚拟机端，</p>
<p>修改&#x2F;etc&#x2F;profile文件</p>
<pre><code>export JAVA_HOME=/root/Downloads/jdk1.8.0_161
export PATH=$PATH:$JAVA_HOME/bin
export HADOOP_HOME=/root/Downloads/hadoop-2.6.5
export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin
export ZOOKEEPER_HOME=/root/Downloads/zookeeper-3.4.5
export PATH=$PATH:$ZOOKEEPER_HOME/bin
export HIVE_HOME=/root/Downloads/apache-hive-2.1.1-bin
export PATH=$PATH:$HIVE_HOME/bin
export FLUME_HOME=/root/Downloads/apache-flume-1.6.0-bin
export PATH=$PATH:$FLUME_HOME/bin 
export HBASE_HOME=/root/Downloads/hbase-1.2.6
export PATH=$PATH:$HBASE_HOME/bin
export SQOOP_HOME=/root/Downloads/sqoop-1.4.6.bin__hadoop-2.0.4-alpha
export PATH=$PATH:$SQOOP_HOME/bin
export SCALA_HOME=/install/scala/scala-2.11.8
export PATH=$PATH:$SCALA_HOME/bin
</code></pre>
<p>修改完成后，记得source 一下</p>
<h4 id="Scala的执行流程"><a href="#Scala的执行流程" class="headerlink" title="Scala的执行流程"></a>Scala的执行流程</h4><p>在写好Scala类时，scalac先进行编译成两个class文件，类名.class和类名$.class文件，然后加载到jvm上运行</p>
<p>先从类名.class中执行，执行main方法，调用类名$.class中的main方法，调用module方法执行主体</p>
<h4 id="Scala的注意事项"><a href="#Scala的注意事项" class="headerlink" title="Scala的注意事项"></a>Scala的注意事项</h4><p>Scala源文件以“.scala”为扩展名。</p>
<p>Scala程序的执行入口是main()函数</p>
<p>Scala语言严格区分大小写</p>
<p>Scala方法由一条条语句构成，不需要加分号</p>
<p>如果一行有多条语句，除了最后一行其他语句都要加分号</p>
<h4 id="Scala语言输出的三种方式"><a href="#Scala语言输出的三种方式" class="headerlink" title="Scala语言输出的三种方式"></a>Scala语言输出的三种方式</h4><p>1、字符串通过+号连接</p>
<p>2、printf用法  用%号引用变量（格式化输出）</p>
<pre><code class="scala">printf(&quot;%d,%s,%h&quot;,name,age,height)
</code></pre>
<p>3、 字符串通过$引用</p>
<p>使用$直接引用变量</p>
<pre><code class="scala">println(&quot;个人信息如下 $name&quot;)
//这个还可以运算 &#123;&#125; 代表了一个表达式
println(&quot;个人信息如下 $&#123;sal+1*10&#125;&quot;)
</code></pre>
<h4 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h4><p>Ctrl+Alt+L   快速格式化 </p>
<p>Ctrl+B   查看源码</p>
<p>Tab    可以区域代码向后移动一个制表符位置</p>
<p>shift+Tab   可以向前移动</p>
<h4 id="Scala查看源码的方法"><a href="#Scala查看源码的方法" class="headerlink" title="Scala查看源码的方法"></a>Scala查看源码的方法</h4><p>将scala-sources-2.12.4.tar拷贝到scala的lib目录，解压完进行关联源码，就可以查看了 </p>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><pre><code>@deprecated  过期标签
@example	例子标签
n1=10 n2=20 return 30
@param    参数标签
@return   返回值标签
</code></pre>
<h4 id="生成注释文档"><a href="#生成注释文档" class="headerlink" title="生成注释文档"></a>生成注释文档</h4><p>scaladoc -d d:&#x2F;mydoc 文件名.scala</p>
<h4 id="Scala的语法"><a href="#Scala的语法" class="headerlink" title="Scala的语法"></a>Scala的语法</h4><pre><code>def   方法定义 
Unit  没有返回值 
val(var)   定义变量
</code></pre>
<h5 id="数据类型的主要内容"><a href="#数据类型的主要内容" class="headerlink" title="数据类型的主要内容"></a>数据类型的主要内容</h5><p>1、Scala与Java有着相同的数据类型，Scala数据类型都是对象，也就是说scala没有Java中原生类型</p>
<p>2、Scala数据类型分为两大类AnyVal(值类型)和AnyRef(引用类型)，它们都是对象</p>
<p>3、Null类型是scala的特别类型，他只有一个值，他是bottom class，是所有AnyRef类型的子类</p>
<p>4、Nothing也是bottom class，它是所有类的子类，在开发中可以将Noting的值返回给任意变量或者函数，在抛出异常使用的多</p>
<p>5、在scala中仍然遵守，低精度得值，像高精度的值自动转换（隐式转换）</p>
<p><img src="/scala/scala/image-20200214130544337.png" alt="image-20200214130544337"></p>
<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p><img src="/scala/scala/image-20200214132607246.png" alt="image-20200214132607246"></p>
<h6 id="Char："><a href="#Char：" class="headerlink" title="Char："></a><strong>Char：</strong></h6><p><strong>在使用Char类型时，255内的数字会自动查询unicode码，输出这个unicode码</strong></p>
<p><strong>Unicode码值表包含了ascii表</strong></p>
<p>超过Char数字范围，报错   var char1 : Char &#x3D; 999999</p>
<p>自动转码后进行计算，判定类型是Int，报错  var char : Char &#x3D; ‘a’ + 1</p>
<h6 id="Boolean："><a href="#Boolean：" class="headerlink" title="Boolean："></a>Boolean：</h6><p>Boolean占一个字节，<strong>Scala中不能使用1或者0来代替true和false</strong></p>
<h6 id="Null"><a href="#Null" class="headerlink" title="Null:"></a>Null:</h6><p>Null只有一个实例，null，类似java中null的引用，<strong>null可以赋值给任意的引用类型（AnyRef），不能赋值给（AnyVal）</strong></p>
<pre><code>var dog : Dog = null     //ok
var char : Char = null   //错误
</code></pre>
<h6 id="Unit："><a href="#Unit：" class="headerlink" title="Unit："></a>Unit：</h6><p>Unit等价于java的void，只有一个实例值：()</p>
<h6 id="String"><a href="#String" class="headerlink" title="String"></a>String</h6><p>Scala中String必须赋默认值，没有值是错的 </p>
<p>var  ss : String &#x3D; _ &#x2F;&#x2F;<strong>默认值是null</strong></p>
<h5 id="自动类型转换细节"><a href="#自动类型转换细节" class="headerlink" title="自动类型转换细节"></a>自动类型转换细节</h5><p>1、多种类型的数据混合运算时，系统首先将所有数据转换成容量最大的那种数据类型，然后再进行计算</p>
<p>2、当我们把进度大的数据类型赋值给精度小的数据类型时，就会报错，反之就会自动类型转换</p>
<p>3、(byte,short)和char之间不会相互自动转换</p>
<p>4、byte、short、char 他们三者可以计算，在计算时首先转换为int类型</p>
<p>5、自动提升原则，表达式结果的类型自动提升为操作数中最大的类型</p>
<p>注：Byte和Short类型在进行运算时，当作Int类型处理</p>
<h5 id="高级隐式转换和隐式函数（后面讲）"><a href="#高级隐式转换和隐式函数（后面讲）" class="headerlink" title="高级隐式转换和隐式函数（后面讲）"></a>高级隐式转换和隐式函数（后面讲）</h5><p>（还没有将，放到高级讲）</p>
<h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>自动类型转换的逆过程，将容量大的转换为容量小的数据类型，使用时要加上强制类型转换，但可能造成精度降低或溢出</p>
<pre><code>java：int num = (int)2.5
scala ；var num : Int = 2.7.toInt
//toInt	直接保留整数位，不进行四舍五入
</code></pre>
<h6 id="强制类型转换细节说明"><a href="#强制类型转换细节说明" class="headerlink" title="强制类型转换细节说明"></a>强制类型转换细节说明</h6><p>1、但进行数据从大——小，就需要用到强制转换</p>
<p>2、强转符号只针对最近的操作数有效，往往使用小括号提升优先级</p>
<p>Char类型可以保存Int的常量值，但不能保存Int的变量值，需要强转</p>
<h4 id="变量使用讲解"><a href="#变量使用讲解" class="headerlink" title="变量使用讲解"></a>变量使用讲解</h4><pre><code>val | val 变量名 [:变量类型] = 变量值
var 修饰的值可以修改
val 修饰的值不可以修改，(final),没有线程安全问题，效率较高，推荐使用val
val修饰的变量在编译后，等同于加上final
!!变量声明时需要初始值，&quot;_&quot;是默认值!!
//名称在前  类型在后 值在最后
声明变量是声明数据类型
定义变量是开辟内存空间
大部分两种一起
</code></pre>
<p><img src="/scala/scala/image-20200214123156457.png" alt="image-20200214123156457"></p>
<h4 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h4><p>全局变量放在堆 </p>
<p>局部变量放在栈</p>
<p>现在许多编译器加了（逃逸分析），也不一定就放在一个里面是不变的</p>
<h4 id="进制运算"><a href="#进制运算" class="headerlink" title="进制运算"></a>进制运算</h4><p>最高位是符号位，用来表示正负的</p>
<p>0为正，1为负</p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>1、Scala对各种变量，方法、函数等命名时使用的字符序列称为标识符</p>
<p>2、凡是自己可以起名字的地方叫做标识符</p>
<h5 id="标识符命名规范"><a href="#标识符命名规范" class="headerlink" title="标识符命名规范"></a>标识符命名规范</h5><p>1、首字符为字母，后续字符任意字母和数字，美元符号，可后接下划线_</p>
<p>2、数字不可以开头</p>
<p>3、<strong>首字符为操作符(比如+-*&#x2F;)，后续字符也需跟操作符，至少一个</strong></p>
<pre><code>    val ++ = 90
    val +-*/ = 29
</code></pre>
<p>4、操作符(比如+-*&#x2F;)不能在标识符中间或者最后</p>
<p>5、用反引号<code>....</code>包括的任意字符串，即使是关键字也可以true</p>
<pre><code class="scala">    val `true` : String = &quot;sss&quot;
</code></pre>
<h4 id="运算符介绍"><a href="#运算符介绍" class="headerlink" title="运算符介绍"></a>运算符介绍</h4><p>运算符是一种特殊的符号，用以表示数据的运算，赋值和比较等</p>
<h5 id="1、算术运算符"><a href="#1、算术运算符" class="headerlink" title="1、算术运算符"></a>1、算术运算符</h5><p><img src="/scala/scala/image-20200214180750699.png" alt="image-20200214180750699"></p>
<h6 id="的运算原则："><a href="#的运算原则：" class="headerlink" title="%	的运算原则："></a>%	的运算原则：</h6><p>a % b &#x3D; a - a&#x2F;b *b</p>
<p>例：10 % 3 &#x3D; 10 - 10 &#x2F; 3 * 3 &#x3D; 10 - 9 &#x3D; 1</p>
<h6 id="和-–"><a href="#和-–" class="headerlink" title="++ 和 –"></a>++ 和 –</h6><p>在scala中没有++和–，而使用了+&#x3D;和-&#x3D;来代替</p>
<h6 id="2、赋值运算符"><a href="#2、赋值运算符" class="headerlink" title="2、赋值运算符"></a>2、赋值运算符</h6><p>赋值运算符就是将某个运算后的值，赋给指定的变量</p>
<p><img src="/scala/scala/image-20200214183242300.png" alt="image-20200214183242300"></p>
<p><strong>这部分包含了进制运算</strong></p>
<p><img src="/scala/scala/image-20200214183423340.png" alt="image-20200214183423340"></p>
<pre><code>var num = 2
num &lt;&lt;= 2   //num = 8 	2*2*2
num &gt;&gt;= 1   //num = 4   8/2 
</code></pre>
<p><strong>Scala中还支持代码块，返回值</strong></p>
<pre><code>var res = &#123;
    if(num &gt; 1) &quot;1&quot; else 2 
&#125;
</code></pre>
<h6 id="3、比较运算符（关系运算符）"><a href="#3、比较运算符（关系运算符）" class="headerlink" title="3、比较运算符（关系运算符）"></a>3、比较运算符（关系运算符）</h6><p>1、关系运算符的结果都是boolean型，也就是要么是true，要不就是false</p>
<p>2、关系表达式经常使用if结果和循环结构条件中</p>
<p><img src="/scala/scala/image-20200214182946847.png" alt="image-20200214182946847"></p>
<h6 id="4、逻辑运算符"><a href="#4、逻辑运算符" class="headerlink" title="4、逻辑运算符"></a>4、逻辑运算符</h6><p>用于连接多个条件，最终结果也是一个boolean值</p>
<p><img src="/scala/scala/image-20200214183138391.png" alt="image-20200214183138391"></p>
<h6 id="5、位运算符"><a href="#5、位运算符" class="headerlink" title="5、位运算符"></a>5、位运算符</h6><p><img src="/scala/scala/image-20200214185855402.png" alt="image-20200214185855402"></p>
<h3 id="程序流程控制"><a href="#程序流程控制" class="headerlink" title="程序流程控制"></a>程序流程控制</h3><h4 id="1、顺序控制"><a href="#1、顺序控制" class="headerlink" title="1、顺序控制"></a>1、顺序控制</h4><h4 id="2、分支控制（嵌套分支不要超过三层）"><a href="#2、分支控制（嵌套分支不要超过三层）" class="headerlink" title="2、分支控制（嵌套分支不要超过三层）"></a>2、分支控制（<strong>嵌套分支不要超过三层</strong>）</h4><p>Scala中任意表达式都是有返回值的，代表着ifelse是有返回结果的，具体返回结果的值取决于满足条件的代码体的最后一行内容</p>
<pre><code class="scala">val age = 60
val res = if(age &gt; 20)&#123;
    println(&quot;hello age &gt; 20&quot;)
    9 + 20
    &quot;yes ok&quot;
&#125;else&#123;
    7
&#125;
//结果是res=yes ok
</code></pre>
<h5 id="单分支"><a href="#单分支" class="headerlink" title="单分支"></a>单分支</h5><h5 id="双分支"><a href="#双分支" class="headerlink" title="双分支"></a>双分支</h5><h5 id="多分支"><a href="#多分支" class="headerlink" title="多分支"></a>多分支</h5><h6 id="Scala中没有Switch（后面讲）"><a href="#Scala中没有Switch（后面讲）" class="headerlink" title="Scala中没有Switch（后面讲）"></a>Scala中没有Switch（后面讲）</h6><p>Scala没有switch，而是使用模式匹配来处理</p>
<p>match-case</p>
<h5 id="嵌套分支"><a href="#嵌套分支" class="headerlink" title="嵌套分支"></a>嵌套分支</h5><h4 id="3、循环控制"><a href="#3、循环控制" class="headerlink" title="3、循环控制"></a>3、循环控制</h4><p>Scala的for循环常见的控制结构提供了非常多的特性，for循环也被称为for推导式或for表达式</p>
<pre><code class="scala">for(i &lt;- 1 to 3)&#123;
    println(i)
&#125;
//&lt;-把右边的值赋值给i
//1 to 3 就是 1到3
//to 是关键字 

var list= List(&quot;hello&quot;,30)
//scala的集合可以存放任意对象
for(item &lt;- list)&#123;
    println(item)
&#125;
</code></pre>
<pre><code class="scala">//until循环范围是start到end-1
for(item &lt;- 1 until 5)&#123;
    //就是1 - 4 (5-1)
    println(item)
&#125;
</code></pre>
<h6 id="循环守卫"><a href="#循环守卫" class="headerlink" title="循环守卫"></a>循环守卫</h6><p>循环保护(也是条件判断式守卫)，<strong>保护式为true则进入循环体内部，为false则跳过，类似于continue</strong></p>
<pre><code class="scala">for(i &lt;- 1 to 3 if i !=2)&#123;
    println(i)
&#125;
</code></pre>
<h6 id="循环控制引入变量"><a href="#循环控制引入变量" class="headerlink" title="循环控制引入变量"></a>循环控制引入变量</h6><pre><code class="scala">for(i &lt;- 1 to 3 ; j = 4 - i)&#123;
    print(j)
&#125;
//这里没有关键字，所以要加上&quot;;&quot;来隔断逻辑
</code></pre>
<h6 id="for循环返回值"><a href="#for循环返回值" class="headerlink" title="for循环返回值"></a>for循环返回值</h6><pre><code class="scala">val res = for(i &lt;- 1 to 10) yield i
println(res)
//将遍历过程中处理的结果返回到一个新的Vector集合中，使用yield关键字

//在i可以是一个代码块
例：
val res = for(i &lt;- 1 to 10) yield i*2
println(res)

//还可以添加代码块
例：
val res = for(i &lt;- 1 to 10) yield &#123;
if(i % 2 == 0)&#123;
    i
&#125;else&#123;
    &quot;不是偶数&quot;
&#125;
&#125;
println(res)
</code></pre>
<h6 id="for循环花括号-代替小括号"><a href="#for循环花括号-代替小括号" class="headerlink" title="for循环花括号{}代替小括号()"></a>for循环花括号{}代替小括号()</h6><pre><code class="scala">for(i &lt;- 1 to 3 ; j = 4 - i)&#123;
    print(j)
&#125;
//可以写成
for&#123;i &lt;- 1 to 3 
    j = 4 - i&#125;&#123;
    print(j)
&#125;
//当for推导式仅包含单一表达式时使用圆括号，但其中包含多个表时使用大括号
//使用&#123;&#125;来换行写表达式时，分号就不用写了
</code></pre>
<h6 id="for循环的步长控制"><a href="#for循环的步长控制" class="headerlink" title="for循环的步长控制"></a>for循环的步长控制</h6><pre><code class="scala">//步长控制为2
for(i &lt;- Range(1,10,2))&#123;
    print(j)
    //1，3，5，7，9
&#125;
//使用循环守卫控制步长
for(i &lt;- 1 to 10 if i % 2 == 0)&#123;
    print(j)
    //1，3，5，7，9
&#125;
//在不使用Range的情况下也能进行步长控制
</code></pre>
<h6 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h6><p>Scala中有while循环，<strong>while语句的返回值是Unit类型()，</strong>但是while中没有返回值，当用该语句计算返回结果时吗，就不可避免地使用了变量，变量需要声明在while循环的外部，那么等于循环的内部对外部的变量造成了影响，所以不推荐使用，推荐使用for循环</p>
<h5 id="Scala内置控制结构特地去除了break"><a href="#Scala内置控制结构特地去除了break" class="headerlink" title="Scala内置控制结构特地去除了break"></a>Scala内置控制结构特地去除了break</h5><p>使用了函数式的风格解决了break和continue功能，而不是一个关键字</p>
<pre><code class="scala">//要导入包
import util.control.Breaks._

var n = 1
    while (n &lt;= 20) &#123;
      n += 1
      if(n==18)&#123;
        break()
          //这里会报一个异常breakException
      &#125;
&#125;
</code></pre>
<pre><code class="scala">//这个break()方法做的事就是抛出了一个异常
def break(): Nothing = &#123; throw breakException &#125;

//这是一个高阶函数，可以接受函数的函数
//op: =&gt;Unit    表示接受的参数是一个没有输入，也灭有返回值的函数
//就相当于一个代码块 
//将你的代码块在try中执行，同时还对break()抛出的异常做了处理
def breakable(op: =&gt;Unit)&#123;
try &#123;
      op
    &#125; catch &#123;
      case ex: BreakControl =&gt;
        if (ex ne breakException) throw ex
    &#125;
&#125;
</code></pre>
<pre><code class="scala">//所以上面的两个方法要联合起来使用
    breakable &#123;
      var n = 1
      while (n &lt;= 20) &#123;
        n += 1
        println(n+&quot;ddddd&quot;)
        if (n == 18) &#123;
          break()
        &#125;
      &#125;
    &#125;
</code></pre>
<h5 id="也可以使用循环守卫来实现中断效果"><a href="#也可以使用循环守卫来实现中断效果" class="headerlink" title="也可以使用循环守卫来实现中断效果"></a>也可以使用循环守卫来实现中断效果</h5><pre><code class="scala">    var loop = true
    var sum2 = 0
    for (i &lt;- 1 to 100 if loop==true) &#123;
      sum2 += i
      if (sum2 &gt; 20) &#123;
        println(i)
        loop=false
      &#125;
    &#125;
</code></pre>
<h5 id="Scala内置控制结构特地去除了continue"><a href="#Scala内置控制结构特地去除了continue" class="headerlink" title="Scala内置控制结构特地去除了continue"></a>Scala内置控制结构特地去除了continue</h5><p>Scala内置控制结构特地去除了continue，为了更好地适应函数话编程，<strong>可以使用if-else 或是循环守卫的方式来实现continue</strong></p>
<pre><code class="scala">for (i &lt;- 1 to 10 if (i != 2 &amp;&amp; i!=3)) &#123;
    printf(&quot;%d&quot;,i)
&#125;

//效果一样
    for (i &lt;- 1 to 10 ) &#123;
      if (i != 2 &amp;&amp; i!=3)&#123;
        printf(&quot;%d\n&quot;,i)
      &#125;
    &#125;
</code></pre>
<h4 id="键盘输入语句"><a href="#键盘输入语句" class="headerlink" title="键盘输入语句"></a>键盘输入语句</h4><p>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。InputDemo.scala</p>
<p><strong>Scala的实现 【 import scala.io.StdIn】</strong></p>
<pre><code>
</code></pre>
<h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><h5 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h5><p>方法、函数、函数式编程、面向对象编程的概念：</p>
<p>1、在Scala中，方法和函数几乎等同（他们的定义、使用、运行机制都一样），只是函数的使用方式更加灵活</p>
<p>2、函数式编程是从编程方式角度来谈的，在Scala中，函数既可以当作函数的变量使用，也可以将函数赋值给一个变量，函数的创建也不用依赖于类或者对象，在java中，函数的创建则依赖于类、抽象类或者接口</p>
<p>3、面向对象编程是以对象为基础的编程方式</p>
<p>4、在Scala中函数式编程和面向对象编程融合在一起</p>
<pre><code class="scala">//将对象方法转化为函数
val f1 = dog.sum _
println(f1)
println(f1(1,2))

//函数
val f2 = (t1:Int,t2:Int) =&gt; t1+t2
println(f2)
println(f2(1,2))
</code></pre>
<h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><p>def 函数名 ([参数名：参数类型]，…)[:返回值类型&#x3D;]{</p>
<p>语句…</p>
<p>return 返回值</p>
<p>}</p>
<p>1、函数声明关键字为def（definiton）</p>
<p>2、[参数名：参数类型],…..，表示函数的输入（就是参数列表），可以没有。如果有，多个参数使用逗号间隔</p>
<p>3、函数中的语句，表示未来实现某一功能代码块</p>
<p>4、函数可以有返回值，也可以没有返回值</p>
<p>5、返回值形式1:返回值类型&#x3D;</p>
<p>6、返回值形式2：&#x3D; 表示返回值类型不确定，适用类型推导完成</p>
<p>7、表示没有返回值，return 不生效 </p>
<p>8、如果没有return，默认以执行到最后一行作为返回值</p>
<h4 id="函数递归调用"><a href="#函数递归调用" class="headerlink" title="函数递归调用"></a>函数递归调用</h4><p>1、执行一个函数时，创建新的受保护的独立空间 </p>
<p>2、函数的局部变量是独立的 ，不会相互影响</p>
<p>3、递归必须先推出递归的条件逼近，否则就是无限递归</p>
<p>4、但一个函数执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁</p>
<h4 id="递归练习题"><a href="#递归练习题" class="headerlink" title="递归练习题"></a>递归练习题</h4><p><img src="/scala/scala/image-20200215144730070.png" alt="image-20200215144730070"></p>
<p><img src="/scala/scala/image-20200215144716788.png" alt="image-20200215144716788"></p>
<h4 id="函数注意事项"><a href="#函数注意事项" class="headerlink" title="函数注意事项"></a>函数注意事项</h4><p>1、函数的形参列表可以是多个，如果参数没有形参，<strong>调用时可以不带()</strong></p>
<p>2、形参列表和返回值列表的数据类型可以是值类型和引用类型</p>
<p>3、Scala中的函数可以根据函数体的最后一行代码自行推断函数返回值类型，在这种情况下，return关键字可以省略</p>
<p>4、Scala可以自行推断，在省略return关键字的情况下，返回值类型也可以省略</p>
<p>5、如果函数明确使用return关键字，那么函数类型就不能使用自行推断了，要明确写成:返回类型，如果什么也不写，返回值是()</p>
<p>6、如果函数声明无返回值(Unit),那么函数中即使使用return关键字也不会有返回值</p>
<pre><code class="scala">//返回值什么都没有写，表示该函数没有返回值
//这里的return无效
def getSum2(n1 :Int,n2:Int)&#123;
return n1 + n2
&#125;
</code></pre>
<p>7、如果明确函数无返回值或者不确定返回值类型，那么返回值类型可以省略</p>
<p>8、Scala语法中任何语法结构都可以嵌套其他语法结构，即：函数中可以在声明&#x2F;定义函数，类种可以在声明类，方法中可以在声明&#x2F;定义方法</p>
<p>9、<strong>Scala函数的形参，再声明参数时，直接赋初始值，这时调用函数时，如果没有指定实参，则会使用默认值。如果制定了实参，则是参会覆盖默认值</strong></p>
<pre><code class="scala">println(sayOk())			//jackok!
println(sayOk(&quot;asdf&quot;))    //asdfok!
def sayOk(name :String = &quot;jack&quot;):String = &#123;
    return name + &quot;ok!&quot;
&#125;
</code></pre>
<p>10、如果函数存在多个参数，每一个参数都可以设定默认值，那么这个时候，传递的参数到底是覆盖默认值，还是赋值给没有默认值的参数，就不确定了（默认按照声明顺序<strong>从左到右</strong>）。在这种情况下，可以使用带名参数</p>
<pre><code class="scala">//只修改user参数
mysqlCon(user = &quot;tom&quot;)
def mysqlCon(add:String = &quot;locathost&quot;,port : Int = 3306,
user:String =&quot;root&quot;,pwd : String = &quot;root&quot;)=&#123;&#125;
</code></pre>
<p>11、scala的函数形参默认时val的，不能再函数中进行修改</p>
<p>12、递归函数为执行之前是无返回值结果类型的，在使用时必须有明确的返回值类型</p>
<p>13、Scala函数支持可变参数</p>
<pre><code class="scala">def sum(n1:Int,args:Int*) : Int =&#123;

&#125;
//args是集合，通过for循环可以访问到各个值
//可变参数需要放在形参列表的最后
</code></pre>
<p><img src="/scala/scala/image-20200215160417071.png" alt="image-20200215160417071"></p>
<h4 id="惰性函数"><a href="#惰性函数" class="headerlink" title="惰性函数"></a>惰性函数</h4><p>惰性计算(尽可能延迟表达式求值)，是许多函数式编程语言的特性，惰性集合在需要时提供其元素，无需预先计算他们。首先你可以<strong>将耗时的计算推迟到绝对需要的时候</strong>。其次，你可以创建无限个集合，只要他们继续接受请求，就会继续提供元素。函数的个性能够得到更高效的代码</p>
<p>单行数返回值被声明为<strong>lazy</strong>时，函数的执行将被推迟，直到我们首次对此取值，该函数才会执行。这种函数我们称为惰性函数</p>
<pre><code class="scala">lazy val res = sum(10,20)
println(&quot;_____________&quot;)
println(&quot;res=&quot;+res)

def sum(n1: Int,n2:Int): Int = &#123;
    println(&quot;sum()执行了&quot;)
    n1+n2
&#125;

//结果:
_____________
sum()执行了
res=30
</code></pre>
<h5 id="惰性函数注意事项"><a href="#惰性函数注意事项" class="headerlink" title="惰性函数注意事项"></a>惰性函数注意事项</h5><p>1、<strong>lazy</strong>不能修饰var类型的变量</p>
<p>2、在调用函数时，加了lazy，会导致函数的执行被推迟，在声明变量时，如果给声明了lazy，那么变量的分配也会变得推迟</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>Scala提供try和catch块来处理异常。<strong>try块用于包含可能出错的代码，catch块用于处理try块中发生的异常。</strong>可以根据需要在程序中任意数量的try…catch块。</p>
<h5 id="Java异常处理的注意点"><a href="#Java异常处理的注意点" class="headerlink" title="Java异常处理的注意点"></a>Java异常处理的注意点</h5><p>1、java语言按照try-catch-catch-finally的方式处理异常</p>
<p>2、不管有没有异常捕获，都会执行finally，finally通常用来释放资源</p>
<p>3、可以有多个catch，分别捕获对应的异常，<strong>需要把范围小的异常类写在前面，把范围大的异常类写在后面，否则编译错误</strong>。但是Scala中可以大的在前，小的在后</p>
<h5 id="Scala异常处理"><a href="#Scala异常处理" class="headerlink" title="Scala异常处理"></a>Scala异常处理</h5><p>1、在scala中只有一个catch</p>
<p>2、在catch中有多个case，每个case可以匹配一种异常	case ex : ArithmeticException</p>
<p>3、&#x3D;&gt;关键符号，表示后面是对异常处理的代码块</p>
<p>4、finally最重要执行</p>
<pre><code class="scala">try&#123;
    val r = 10 /0
&#125;catch &#123;
    case ex:ArithmeticException =&gt; println(&quot;捕获除数为0的算数异常&quot;)
    case ex:Exception =&gt; println(&quot;捕获了异常&quot;)
&#125;finally&#123;
println(&quot;scala finally&quot;)
&#125;
</code></pre>
<h5 id="Scala异常处理小节"><a href="#Scala异常处理小节" class="headerlink" title="Scala异常处理小节"></a>Scala异常处理小节</h5><p>1、在try之后使用一个catch处理程序来捕获异常，如果发生任何异常，catch处理它，程序继续执行</p>
<p>2、Scala的异常的工作机制和java一样，但是Scala没有“checked(编译期)”异常， Scala没有编译异常这个概念，异常都是在运行时候捕获处理</p>
<p>3、用throw关键字，抛出一个异常对象。<strong>所有的一场都是Throwable的字类型。throw表达式是有类型的，就是Nothing，因为Nothing时所有类的字类，所有throw表达式可以写在任意地方</strong></p>
<p>4、在Scala里，借用了模式匹配的思想来做异常的匹配，因此，在catch的代码里，是一系列case子句来匹配异常。当匹配上后&#x3D;&gt;有多条语句可以换行写，类似java的switch case x：代码块~<br>5、异常捕捉的机制与其他语言中一样，如果有异常发生，catch子句是按次序捕捉的。因此，在catch子句中，越具体的异常越要靠前，越普遍的异常越靠后，如果把越普遍的异常写在前，把具体的异常写在后，在Scala也不会报错，但这样是非常不好的编程风格。</p>
<pre><code class="scala">//如果我们希望在test()抛出异常后，代码可以继续执行，则我们需要处理
  try &#123;
    test()
  &#125; catch &#123;
    case ex: Exception =&gt; &#123;
        //捕获到异常算数异常
      println(&quot;捕获到异常&quot; + ex.getMessage)
      println(&quot;xxxx&quot;)
    &#125;
    case ex: ArithmeticException =&gt; println(&quot;得到一个算数异常&quot;)
  &#125; finally &#123;

  &#125;
  
  def test():Nothing&#123;
  throw new ArithmeticException(&quot;算数异常&quot;)
  &#125;
</code></pre>
<p>7、finally子句用于执行不管是正常处理还是有异常发生时都需要执行的步骤，一般用于对象的清理工作，这点和Java一样。</p>
<p>8、Scala提供了throws关键字来声明异常。可以使用方法定义声明异常。 它向调用者函数提供了此方法可能引发此异常的信息。 它有助于调用函数处理并将该代码包含在try-catch块中，<strong>以避免程序异常终止</strong>。在scala中，可以使用throws注释来声明异常</p>
<pre><code class="scala">//throws注释
@throws(classOf[NumberFormatException])//等同于NumberFormatException.class
  def f11()  = &#123;
    &quot;abc&quot;.toInt
  &#125;
</code></pre>
<h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><h5 id="定义类的注意事项"><a href="#定义类的注意事项" class="headerlink" title="定义类的注意事项"></a>定义类的注意事项</h5><p>1、scala语法中，类并不声明为public，所有这些类都是具有共有可见性（即默认就是public）</p>
<p>2、一个Scala源文件可以包含多个类，而且默认都是public</p>
<h5 id="类和对象的区别"><a href="#类和对象的区别" class="headerlink" title="类和对象的区别"></a>类和对象的区别</h5><p>1、类是抽象的，概念的，代表<strong>一类事物</strong>,比如人类,猫类..</p>
<p>2、对象是具体的，实际的，代表<strong>一个具体</strong>事物</p>
<p>3、类是对象的模板，对象是类的一个个体，对应一个实例</p>
<p>4、Scala中类和对象的区别和联系 和 Java是一样的。</p>
<h5 id="属性和类的关系"><a href="#属性和类的关系" class="headerlink" title="属性和类的关系"></a>属性和类的关系</h5><p>1、属性是类的一个组成部分，一般是<strong>值数据类型</strong>,也可是<strong>引用类型</strong>。比如我们前面定义猫类 的 age 就是属性</p>
<h5 id="属性-x2F-成员变量"><a href="#属性-x2F-成员变量" class="headerlink" title="属性&#x2F;成员变量"></a>属性&#x2F;成员变量</h5><p>1、属性的定义语法同变量，示例：var 属性名称 [:类型] &#x3D; 属性值</p>
<p>2、属性的定义类型可以为任意类型，包含值类型或引用类型</p>
<p>3、Scala声明一个属性，必须显式的初始化，然后根据初始化数据的类型自动判断，属性类型可以省略</p>
<p>4、如果赋值null，<strong>一定要加类型</strong>，因为不加类型，该属性的类型就是Null类型</p>
<p>5、在定义属性时，暂时不赋值，也可以使用符号_(下划线)，让系统分配默认值</p>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>val | var 对象名 [:类型] &#x3D; new 类型()</p>
<p>1、如果我们不希望改变对象的引用，应该是val性质的，否则声明var，scala设计者推荐使用val，因为一般来说，在程序中，我们只是改变对象属性的值，而不是改变对象的引用</p>
<p>2、scala在声明对象变量时，可以根据创建对象的类型自动推断，所以类型声明可以省略，<strong>但当类型和后面new 对象类型有继承关系即多态时，就必须写了</strong></p>
<h5 id="类和对象的内存分配机制"><a href="#类和对象的内存分配机制" class="headerlink" title="类和对象的内存分配机制"></a>类和对象的内存分配机制</h5><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>Scala中的方法其实就是函数</p>
<h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><pre><code>def 方法名(参数列表) [：返回值类型] = &#123; 
    方法体
&#125;
</code></pre>
<h5 id="方法的调用机制原理"><a href="#方法的调用机制原理" class="headerlink" title="方法的调用机制原理"></a>方法的调用机制原理</h5><ol>
<li><p>当我们scala开始执行时，先在栈区开辟一个main栈。main栈是最后被销毁</p>
</li>
<li><p>当scala程序在执行到一个方法时，总会开一个新的栈。</p>
</li>
<li><p>每个栈是独立的空间，变量（基本数据类型）是独立的，相互不影响</p>
</li>
<li><p>当方法执行完毕后，该方法开辟的栈就会被jvm机回收。</p>
</li>
</ol>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>主要作用是完成<strong>对象的初始化</strong></p>
<h5 id="Scala构造器的介绍"><a href="#Scala构造器的介绍" class="headerlink" title="Scala构造器的介绍"></a>Scala构造器的介绍</h5><p>和Java一样，Scala构造对象也需要调用构造方法，并且可以有任意多个构造方法（即scala中构造器也支持重载）。<br>Scala类的构造器包括： <strong>主构造器 和 辅助构造器</strong></p>
<h5 id="Scala构造器的基本语法"><a href="#Scala构造器的基本语法" class="headerlink" title="Scala构造器的基本语法"></a>Scala构造器的基本语法</h5><pre><code class="scala">class 类名(形参列表) &#123;  // 主构造器
   // 类体
   def  this(形参列表) &#123;  // 辅助构造器
   &#125;
   def  this(形参列表) &#123;  //辅助构造器可以有多个...
   &#125;
&#125; 
//辅助构造器可以有多个，通过参数或者类型来区分
</code></pre>
<h5 id="构造器的私有化"><a href="#构造器的私有化" class="headerlink" title="构造器的私有化"></a>构造器的私有化</h5><pre><code class="scala">class 类名 private(形参列表) &#123; &#125;
</code></pre>
<h5 id="Scala构造器注意事项和细节"><a href="#Scala构造器注意事项和细节" class="headerlink" title="Scala构造器注意事项和细节"></a>Scala构造器注意事项和细节</h5><p>1、Scala的构造器作用是完成<strong>对新对象的初始化，构造器没有返回值</strong></p>
<p>2、<strong>主构造器的声明直接放置于类名之后</strong></p>
<p>3、<strong>主构造器会执行类定义中除方法外的所有语句</strong>，构造器也是方法，这里可以体会到Scala的函数式编程和面向对象编程融合在一起</p>
<p>4、如果<strong>主构造器无参数，小括号可省略</strong>，构建对象时调用的构造方法小括号也可以省略</p>
<p>5、<strong>辅助构造器名称为this</strong>（这个和Java是不一样的），多个辅助构造器通过不同参数列表进行区分， 在底层就是构造器重载。</p>
<p>6、如果想<strong>让主构造器变成私有的，可以在()之前加上private</strong>，这样用户只能通过辅助构造器来构造对象了</p>
<pre><code class="scala">//私有化主构造器
class Person2 private()&#123;
&#125;
//私有化辅助构造器
private this()&#123;
    
&#125;
</code></pre>
<p>7、辅助构造器的声明不能和主构造器的声明一致,会发生错误(即构造器名重复 )</p>
<h6 id="快速入门案例"><a href="#快速入门案例" class="headerlink" title="快速入门案例"></a>快速入门案例</h6><pre><code class="scala">//主构造器
class Person(inName : String,inage :Int) &#123;
  var name: String = inName
  var age: Int = inage
  //辅助构造器
  def this(name: String) &#123;
    this()
    this.name = name
  &#125;
  //辅助构造器
  def this(name: String, age: Int) &#123;
    this()
    this.name = name
    this.age=age
  &#125;
  println(&quot;_________&quot;)
&#125;
</code></pre>
<h5 id="Scala构造器参数"><a href="#Scala构造器参数" class="headerlink" title="Scala构造器参数"></a>Scala构造器参数</h5><p>1、Scala类的主构造器的形参未用任何修饰符修饰，那么这个参数是局部变量</p>
<pre><code class="scala">class Car(inname : String)&#123;
    //就是一个局部变量的形参
&#125;
</code></pre>
<p>2、如果<strong>参数使用val关键字声明，</strong>那么Scala会将参数<strong>作为类的私有的只读属性</strong></p>
<pre><code class="scala">class Car(val inname : String)&#123;
&#125;
  def main(args: Array[String]): Unit = &#123;
    val car = new Car
    println(car.inname)//ok
    car.inname=&quot;&quot;//error
  &#125;
</code></pre>
<p>3、如果参数使用<strong>var关键字</strong>声明，那么Scala会将参数作为类的<strong>成员属性</strong>使用，即这时的成员属性是私有的，但是可读写。</p>
<pre><code class="scala">class Car(var inname : String)&#123;
&#125;
  def main(args: Array[String]): Unit = &#123;
    val car = new Car
    car.inname=&quot;&quot;
    println(car.inname)
  &#125;
</code></pre>
<p>4、JavaBeans规范定义了Java的属性是像getXxx（）和setXxx（）的方法。为了Java的互操作性。将Scala<strong>字段加@BeanProperty</strong>时，这样会<strong>自动生成规范的 setXxx&#x2F;getXxx 方法</strong>。这时可以使用 对象.setXxx() 和 对象.getXxx() 来调用属性。</p>
<pre><code class="scala">class Car(val inname : String)&#123;
  @BeanProperty
  var name :String = null
  def this()&#123;
    this(&quot;&quot;)
  &#125;
&#125;
  def main(args: Array[String]): Unit = &#123;
 val car = new Car
 car.setName(&quot;宝马&quot;)
 car.getName
  &#125;
//加了注解之后的生成的getset方法和原来的car.name方法共存
</code></pre>
<h4 id="Scala对象创建流程？（面试题）"><a href="#Scala对象创建流程？（面试题）" class="headerlink" title="Scala对象创建流程？（面试题）"></a>Scala对象创建流程？（面试题）</h4><pre><code>var p : Person = new Person(&quot;小强&quot;,20)
</code></pre>
<p>1、加载类得信息(属性信息，方法信息)</p>
<p>2、在内存中(堆)开辟空间，开辟的大小根据属性多大</p>
<p>3、调用父类的构造器(主和辅助)进行初始化</p>
<p>4、使用主构造器对属性进行初始化</p>
<p>5、使用辅助构造器对属性进行初始化</p>
<p>6、开辟的对象的地址赋值给p引用</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h4 id="Java包的三大作用"><a href="#Java包的三大作用" class="headerlink" title="Java包的三大作用"></a>Java包的三大作用</h4><p>1、区分相同名字的类</p>
<p>2、当类很多时，可以很好的管理类</p>
<p>3、控制访问范围</p>
<h4 id="Java对包的要求"><a href="#Java对包的要求" class="headerlink" title="Java对包的要求"></a>Java对包的要求</h4><p>类的源文件，需要和包对应的文件路径匹配</p>
<p>当我们编译Dog类，后生成对应的.class文件，编译器会将该.class文件也放在和包一样的路径里</p>
<h4 id="Scala包的基本介绍"><a href="#Scala包的基本介绍" class="headerlink" title="Scala包的基本介绍"></a>Scala包的基本介绍</h4><p>和Java一样，Scala中管理项目可以使用包，但Scala中的包的功能更加强大，使用也相对复杂些</p>
<h5 id="Scala基本语法"><a href="#Scala基本语法" class="headerlink" title="Scala基本语法"></a>Scala基本语法</h5><pre><code>package 包名
</code></pre>
<h5 id="Scala包的特点和Java的一样"><a href="#Scala包的特点和Java的一样" class="headerlink" title="Scala包的特点和Java的一样"></a>Scala包的特点和Java的一样</h5><p>1、区分相同名字的类</p>
<p>2、当类很多时，可以很好的管理类</p>
<p>3、控制访问范围</p>
<p>4、<strong>可以对类的功能进行扩展</strong></p>
<p>Scala中包名和源码所在的系统文件目录结构要可以不一致，但是编译后的字节码文件路径和包名会保持一致(这个工作由编译器完成)</p>
<p>Scala中包名和源码所在的系统文件目录结构<strong>可以不一致</strong>，但是编译后的字节码文件路径和包名会保持一致(就是源码路径和.class文件路径可以不一致，但是他们必须在同一个包的目录下)</p>
<p>例：</p>
<pre><code class="Scala">//源文件目录
package com.star.chapter06.constuctor
//.class字节码目录
package com.star.chapter06.hello
</code></pre>
<h5 id="Scala包的命名"><a href="#Scala包的命名" class="headerlink" title="Scala包的命名"></a>Scala包的命名</h5><p>只能包含数字、字母、下划线、小圆点.,但不能用数字开头, 也不要使用关键字。</p>
<h6 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h6><p>一般是小写字母+小圆点一般是 </p>
<p><strong>com.公司名.项目名.业务模块名</strong></p>
<h5 id="Scala会自动引入的常用包"><a href="#Scala会自动引入的常用包" class="headerlink" title="Scala会自动引入的常用包"></a>Scala会自动引入的常用包</h5><pre><code class="scala">java.lang.*  
scala包
Predef包//预定义包
</code></pre>
<h5 id="Scala包注意事项和使用细节"><a href="#Scala包注意事项和使用细节" class="headerlink" title="Scala包注意事项和使用细节"></a>Scala包注意事项和使用细节</h5><h6 id="一、Scala打包的方式"><a href="#一、Scala打包的方式" class="headerlink" title="一、Scala打包的方式"></a>一、Scala打包的方式</h6><h6 id="注：包名不会影响源码，只会影响-class字节码文件的位置"><a href="#注：包名不会影响源码，只会影响-class字节码文件的位置" class="headerlink" title="注：包名不会影响源码，只会影响.class字节码文件的位置"></a>注：<strong>包名不会影响源码，只会影响.class字节码文件的位置</strong></h6><p>1、传统的方式</p>
<pre><code>package com.atguigu.scala
class Person&#123;

&#125;
</code></pre>
<p>2、和第一种完全等价</p>
<pre><code>package com.atguigu
package 
class Person&#123;

&#125;
</code></pre>
<p>3、这种方式来指定.class文件到哪个包中</p>
<pre><code class="scala">//package+包名&#123;&#125;
package com.atguigu &#123;
  class User&#123;

  &#125;
  package scala2&#123;
    object User&#123;

    &#125;
  &#125;
  package scala &#123;

    class Person &#123;
      val name = &quot;Nick&quot;

      def play(message: String): Unit = &#123;
        println(this.name + &quot; &quot; + message)
      &#125;
    &#125;

    object Test100 &#123;
      def main(args: Array[String]): Unit = &#123;
        println(&quot;ok&quot;)
      &#125;
    &#125;

  &#125;
</code></pre>
<h6 id="二、包中有包"><a href="#二、包中有包" class="headerlink" title="二、包中有包"></a>二、包中有包</h6><p>包也可以像嵌套类那样嵌套使用（包中有包）, 这个在前面的第三种打包方式已经讲过了，在使用第三种方式时的好处是：<strong>程序员可以在同一个文件中，将类(class &#x2F; object)、trait 创建在不同的包中</strong>，这样就非常灵活了。</p>
<pre><code class="scala">package com.atguigu &#123;
    //这个类的字节码文件在com.atguigu包下
  class User&#123;

  &#125;
  package scala2&#123;
    //这个类的字节码文件在com.atguigu.scala2包下
    class User&#123;

    &#125;
&#125;
</code></pre>
<h6 id="三、作用域原则"><a href="#三、作用域原则" class="headerlink" title="三、作用域原则"></a>三、作用域原则</h6><p>作用域原则：<strong>可以直接向上访问</strong>。即: Scala中子包中直接访问父包中的内容, 大括号体现作用域。(提示：Java中子包使用父包的类，需要import)。<strong>在子包和父包 类重名时，默认采用就近原则，如果希望指定使用某个类，则带上包名即可。</strong></p>
<h6 id="四、父包访问子包"><a href="#四、父包访问子包" class="headerlink" title="四、父包访问子包"></a>四、父包访问子包</h6><p>父包要访问子包的内容时，需要import对应的类等</p>
<p>&#x2F;&#x2F;和java不同，位置在哪里都可以</p>
<pre><code class="scala">package com.atguigu &#123;
import com.atguigu.scala.Tiger
class User&#123;
    var tiger = new Tiger()
&#125;
  package scala&#123;
    class Tiger&#123;

    &#125;
  &#125;
&#125;
</code></pre>
<h6 id="五、嵌套的package不超过三层"><a href="#五、嵌套的package不超过三层" class="headerlink" title="五、嵌套的package不超过三层"></a>五、嵌套的package不超过三层</h6><p>可以在同一个.scala文件中，声明多个并列的package(建议嵌套的pakage不要超过3层) </p>
<h6 id="六、包名的相对路径引入和绝对路径引入"><a href="#六、包名的相对路径引入和绝对路径引入" class="headerlink" title="六、包名的相对路径引入和绝对路径引入"></a>六、包名的相对路径引入和绝对路径引入</h6><p>包名可以相对也可以绝对，比如，访问BeanProperty的绝对路径是：<em>root</em>. scala.beans.BeanProperty ，在一般情况下：我们使用相对路径来引入包，<strong>只有当包名冲突时，使用绝对路径来处理。</strong></p>
<pre><code class="scala">//第一种形式，相对路径
@BeanProperty
//第二种和第一种一样，也是相对路径
@scala.beans.BeanProperty
//第三种，绝对路径
@_root_.scala.beans.BeanProperty
</code></pre>
<h4 id="包对象"><a href="#包对象" class="headerlink" title="包对象"></a>包对象</h4><p><strong>包可以包含类、对象和特质trait，但不能包含函数&#x2F;方法或变量的定义</strong>。这是Java虚拟机的局限。为了<strong>弥补这一点不足，scala提供了包对象的概念来解决这个问题</strong>。</p>
<pre><code class="scala">package com.atguigu &#123;
    //包对象
  package object scala &#123;
    var name = &quot;kk&quot;

    def sayOk(): Unit = &#123;
      println(&quot;package object&quot;)
    &#125;
  &#125;
    //包范围
  package scala &#123;

    object TestObj &#123;
      def main(args: Array[String]): Unit = &#123;

        println(name)
        sayOk()
      &#125;
    &#125;

  &#125;

&#125;
</code></pre>
<h5 id="包对象实现的机制"><a href="#包对象实现的机制" class="headerlink" title="包对象实现的机制"></a>包对象实现的机制</h5><p>一个包对象会生成两个字节码文件</p>
<p>Package.class和package$.class</p>
<p>运行类调用包对象的方法时，是调用package$.class中的方法来输出结果</p>
<h5 id="包对象的应用"><a href="#包对象的应用" class="headerlink" title="包对象的应用"></a>包对象的应用</h5><h6 id="1、语法"><a href="#1、语法" class="headerlink" title="1、语法"></a>1、语法</h6><pre><code>package object 包名
//表示创建一个包对象
</code></pre>
<h6 id="2、包对象的名字需要和子包一样"><a href="#2、包对象的名字需要和子包一样" class="headerlink" title="2、包对象的名字需要和子包一样"></a>2、包对象的名字需要和子包一样</h6><p>(放在外面，包对象和包同级的，不是被包包含的)</p>
<h6 id="3、每一个包都可以有一个包对象"><a href="#3、每一个包都可以有一个包对象" class="headerlink" title="3、每一个包都可以有一个包对象"></a>3、每一个包都可以有一个包对象</h6><h6 id="4、包对象中可以定义变量、方法"><a href="#4、包对象中可以定义变量、方法" class="headerlink" title="4、包对象中可以定义变量、方法"></a>4、包对象中可以定义变量、方法</h6><h6 id="5、包对象中定义的变量和方法，可以在对应的包中使用"><a href="#5、包对象中定义的变量和方法，可以在对应的包中使用" class="headerlink" title="5、包对象中定义的变量和方法，可以在对应的包中使用"></a>5、包对象中定义的变量和方法，可以在对应的包中使用</h6><h4 id="包的可见性"><a href="#包的可见性" class="headerlink" title="包的可见性"></a>包的可见性</h4><h5 id="Java的修饰符范围"><a href="#Java的修饰符范围" class="headerlink" title="Java的修饰符范围"></a>Java的修饰符范围</h5><p>Java的四种访问控制修饰符号控制方法和变量的访问权限(范围)</p>
<p>1、公开级别:用public 修饰,对外公开<br>2、受保护级别:用protected修饰,对子类和同一个包中的类公开<br>3、默认级别:没有修饰符号,向同一个包的类公开.<br>4、私有级别:用private修饰,只有类本身可以访问,不对外公开</p>
<h5 id="Scala的可见性"><a href="#Scala的可见性" class="headerlink" title="Scala的可见性"></a>Scala的可见性</h5><p>在Java中，访问权限分为: public，private，protected和默认。在Scala中，你可以通过类似的修饰符达到同样的效果。但是使用上有区别。</p>
<h5 id="Scala的修饰符范围"><a href="#Scala的修饰符范围" class="headerlink" title="Scala的修饰符范围"></a>Scala的修饰符范围</h5><p><strong>private</strong>   			外部不能访问，连方法都是private的，只能在本类或者伴生对象中使用</p>
<p><strong>protected</strong>(编译器控制)		只能够子类访问，权限控制严格</p>
<p>如果不写默认也是private，但方法是public的，可以在任意地方使用</p>
<p>但是在解码后，不管你什么修饰符，不是能够让外部访问的，就是private</p>
<p>能够被外部访问的就是public  就这两种，但是</p>
<h5 id="伴生类和伴生对象"><a href="#伴生类和伴生对象" class="headerlink" title="伴生类和伴生对象"></a>伴生类和伴生对象</h5><p>伴生对象可以使用伴生对象的私有属性和私有方法</p>
<p>当一个文件中同时出现了名字相同的class和object</p>
<pre><code class="scala">object Testvisit &#123;
  def main(args: Array[String]): Unit = &#123;
    val  c = new Clerk()
    c.showInfo()
    Clerk.test(c)
  &#125;&#125;
class Clerk &#123;
  var name : String = &quot;jack&quot;
  private var sal : Double = 9999.9
  def showInfo(): Unit = &#123;
    println(&quot; name &quot; + name + &quot; sal= &quot; + sal)
  &#125;&#125;
//伴生对象可以访问伴生类的私有属性
object Clerk&#123;
  def test(c : Clerk): Unit = &#123;
    //这里体现出在伴生对象中，可以访问c.sal
    println(&quot;test() name=&quot; + c.name + &quot; sal= &quot; + c.sal)
  &#125;&#125;
</code></pre>
<p>因为Scala设计者将static拿掉，他设计了<strong>伴生类和伴生对象的概念</strong></p>
<p><strong>class称作伴生类，存放非静态内容的地方</strong></p>
<p><strong>object称为伴生对象，存放静态内容的地方</strong></p>
<h5 id="Scala中包的可见性和访问修饰符"><a href="#Scala中包的可见性和访问修饰符" class="headerlink" title="Scala中包的可见性和访问修饰符"></a>Scala中包的可见性和访问修饰符</h5><p>1、当属性访问权限为<strong>默认时</strong>，从底层看<strong>属性是private的</strong>，方法是public的，因为提供了xxx_$eq()[类似setter]&#x2F;xxx()[类似getter] 方法，因此从使用效果看是任何地方都可以访问)</p>
<p>2、当方法访问权限为<strong>默认时</strong>，默认为public访问权限</p>
<p>3、<strong>private</strong>为私有权限，<strong>只在类的内部和伴生对象中可用</strong></p>
<p>4、<strong>protected</strong>为受保护权限，scala中受保护权限比Java中更严格，<strong>只能子类访问，同包无法访问</strong> (编译器)</p>
<p>5、在scala中<strong>没有public关键字</strong>,即不能用public显式的修饰属性和方法</p>
<p>6、包访问权限（表示属性有了限制。同时包也有了限制），这点和Java不一样，体现出Scala包使用的灵活性。</p>
<p>将非静态的内容放在伴生类中</p>
<p>将静态内容放在伴生对象中</p>
<pre><code class="scala">class Person &#123;
  private[scala] val pname=&quot;hello&quot; 
  // 增加包访问权限后，1.private同时起作用。不仅同类可以使用 
  //2. 同时com.atguigu.scala中包下其他类也可以使用
&#125;
//也可以延展到上层
private[atguigu] val description=&quot;zhangsan&quot;
</code></pre>
<h5 id="Scala引入包的细节和注意事项"><a href="#Scala引入包的细节和注意事项" class="headerlink" title="Scala引入包的细节和注意事项"></a>Scala引入包的细节和注意事项</h5><p>1、在Scala中，improt语句可以出现在任何的地方，并不仅限于文件顶端，import语句的作用一直延伸到包含该语句的块末尾。这种语法的好处是：<strong>在需要时在引入包，缩小import 包的作用范围，提高效率</strong>。</p>
<p>2、Java中如果想要导入包中所有的类，可以通过通配符<em>，*<em>Scala中采用下 “_”</em></em>  </p>
<pre><code>import scala.beans._
</code></pre>
<p>3、如果不想要某个包中全部的类，而是其中的几个类，可以采用选取器(大括号)</p>
<pre><code>def test(): Unit = &#123;
    import scala.collection.mutable.&#123;HashMap, HashSet&#125;
    var map = new HashMap()
    var set = new HashSet()
&#125;
</code></pre>
<p>4、如果引入的多个包中含有相同的类，那么可以<strong>将不需要的类进行重命名</strong>进行区分，这个就是重命名</p>
<pre><code>import java.util.&#123; HashMap=&gt;JavaHashMap, List&#125;
import scala.collection.mutable._
var map = new HashMap() 	// 此时的HashMap指向的是scala中的HashMap
var map1 = new JavaHashMap(); // 此时使用的java中hashMap的别名
</code></pre>
<p>5、如果某个冲突的类根本就不会用到，那么这个类可以直接隐藏掉</p>
<pre><code>import java.util.&#123; HashMap=&gt;_, _&#125; // 含义为 引入java.util包的所有类，但是忽略 HahsMap类.
var map = new HashMap() // 此时的HashMap指向的是scala中的HashMap, 而且idea工具的提示也不会显示java.util的HashMaple 
</code></pre>
<h3 id="面向对象编程三大特征"><a href="#面向对象编程三大特征" class="headerlink" title="面向对象编程三大特征"></a>面向对象编程三大特征</h3><p>面向对象编程有三大特征：封装、继承和多态</p>
<h4 id="封装介绍"><a href="#封装介绍" class="headerlink" title="封装介绍"></a>封装介绍</h4><p>封装(encapsulation)就是把<strong>抽象出的数据和对数据的操作封装在一起</strong>,数据被保护在内部,<strong>程序的其它部分只有通过被授权的操作(成员方法),才能对数据进行操作。</strong></p>
<h6 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h6><p>隐藏实现细节<br>提可以对数据进行验证，保证安全合理</p>
<h6 id="封装的步骤"><a href="#封装的步骤" class="headerlink" title="封装的步骤"></a>封装的步骤</h6><p>1、私有化属性</p>
<p>2、提供getset方法</p>
<h5 id="Scala封装的注意事项和细节"><a href="#Scala封装的注意事项和细节" class="headerlink" title="Scala封装的注意事项和细节"></a>Scala封装的注意事项和细节</h5><p>1、Scala中为了简化代码的开发，当声明属性时，本身就自动提供了对应setter&#x2F;getter方法，如果<strong>属性声明为private的，那么自动生成的setter&#x2F;getter方法也是private的</strong>，如果<strong>属性省略访问权限修饰符，那么自动生成的setter&#x2F;getter方法是public</strong>的</p>
<p>2、因此我们如果只是**对一个属性进行简单的set和get ，只要声明一下该属性(**属性使用默认访问修饰符) 不用写专门的getset，默认会创建，访问时，直接对象.变量。这样也是为了保持访问一致性</p>
<p>3、从形式上看 dog.food 直接访问属性，其实底层仍然是访问的方法,  看一下反编译的代码就明白<br>4、有了上面的特性，目前很多新的框架，在进行反射时，也支持对属性的直接反射(<strong>支持框架</strong>)</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h5 id="继承基本介绍"><a href="#继承基本介绍" class="headerlink" title="继承基本介绍"></a>继承基本介绍</h5><p><strong>继承可以解决代码复用</strong>,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类(比如Student),在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends语句来声明继承父类即可。</p>
<h5 id="Scala继承的基本语法"><a href="#Scala继承的基本语法" class="headerlink" title="Scala继承的基本语法"></a>Scala继承的基本语法</h5><p>class 子类名 extends 父类名  { 类体 }</p>
<h5 id="Scala继承给编程带来的便利"><a href="#Scala继承给编程带来的便利" class="headerlink" title="Scala继承给编程带来的便利"></a>Scala继承给编程带来的便利</h5><p>代码的复用性提高了<br>代码的扩展性和维护性提高了</p>
<p><img src="/scala/scala/image-20200217095200063.png" alt="image-20200217095200063"></p>
<h5 id="Scala继承了什么？"><a href="#Scala继承了什么？" class="headerlink" title="Scala继承了什么？"></a>Scala继承了什么？</h5><p>子类继承了<strong>所有的属性</strong>，只是私有的属性不能直接访问，<br> 需要<strong>通过公共的方法</strong>去访问</p>
<h4 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h4><p>scala明确规定，重写一个非抽象方法需要用<strong>override</strong>修饰符，调用超类被覆盖的方法使用super关键字  </p>
<pre><code class="scala">class Person &#123;
  var name : String = &quot;tom&quot;
  def printName() &#123;
    println(&quot;Person printName() &quot; + name)
  &#125;
&#125;

class Emp extends Person &#123;
  //这里需要显式的使用override
  override def printName() &#123;
    println(&quot;Emp printName() &quot; + name)
    //父类方法被重写，要调用父类方法使用supper关键字
    super.printName()
  &#125;
&#125;
</code></pre>
<h4 id="Scala中类型检查和转换"><a href="#Scala中类型检查和转换" class="headerlink" title="Scala中类型检查和转换"></a>Scala中类型检查和转换</h4><p>要测试某个对象是否属于某个给定的类，可以用<strong>isInstanceOf</strong>方法。用<strong>asInstanceOf</strong>方法将引用转换为子类的引用。<strong>classOf</strong>获取对象的类名</p>
<p>1、classOf[String]就如同Java的 String.class 。会输出class java.lang.String</p>
<pre><code class="scala">classOf[String]
//两种等价
val s = &quot;kk&quot;
//这种是利用反射机制
println(s.getClass.getName)
</code></pre>
<p>2、obj.isInstanceOf[T]就如同Java的obj instanceof T <strong>判断obj是不是T类型</strong>。</p>
<pre><code class="scala">print(&quot;s&quot;.isInstanceOf[String])
</code></pre>
<p>3、obj.asInstanceOf[T]就如同Java的(T)obj <strong>将obj强转成T类型。</strong></p>
<pre><code class="scala">var p1 = new Person
var emp = new Emp
//自动向上转型,还是Person类型
p1 = emp
var emp2 = p1.isInstanceOf[Emp]
</code></pre>
<h4 id="Scala中超类的构造"><a href="#Scala中超类的构造" class="headerlink" title="Scala中超类的构造"></a>Scala中超类的构造</h4><p>1、类有一个主构器和任意数量的辅助构造器，而<strong>每个辅助构造器都必须先调用主构造器</strong>(也可以是间接调用.)</p>
<pre><code class="scala">object SealaBaseConstrator &#123;
def	main(args: Array[String]): Unit * &#123;
//分析一下他的执行流程
//1.因为scala 遵循先构建父类部分extends Pcrson700
//2.Person...
//3.默认的名字
//4.Emp....
val emp = new Emp700（）
//分析一下他的执行流程
//1.因为scala 遵循先构建父类部分extends Pcrson700
//Person...
//默认的名字
//3.Emp...
//4.Emp 辅助构造器
phntln(&quot;========================&quot;)
val emp2 = new Emp700(&quot;mary&quot;）
print ln(&quot;***********************&quot;)
//分析执行的顺序
//1.Person...
//2.默认的名字
//3.Emp...
//4.Emp 辅助构造器
val emp3 = new Emp700(&quot;smith&quot;)
    &#125;
&#125;
                      
//父类 Person
class Person700(pName:String)&#123;
    var name = pName
    println(&quot;Person...&quot;)
    def this()&#123;
        this(&quot;默认的名字&quot;)
        println(&quot;默认的名字&quot;)
    &#125;
&#125;
                      
//子类Emp继承Perso
class Emp700() extends Person700()&#123;
    println(&quot;Emp...&quot;)
    def this(name:String)&#123;
        this
        this.name=name
        println(&quot;Emp 辅助构造器~&quot;);
    &#125;
&#125;
</code></pre>
<p>2、<strong>只有主构造器可以调用父类的构造器</strong>。辅助构造器不能直接调用父类的构造器。在Scala的构造器中，你不能调用super(params) ，没有super的语法</p>
<h4 id="覆写字段"><a href="#覆写字段" class="headerlink" title="覆写字段"></a>覆写字段</h4><p>在Scala中，<strong>子类改写父类的字段</strong>，我们称为<strong>覆写&#x2F;重写字段</strong>。覆写字段需使用 <strong>override</strong>修饰。<strong>是通过重写方法来实现的</strong></p>
<p>Java中只有方法的重写，没有属性&#x2F;字段的重写，准确的讲，是隐藏字段代替了重写</p>
<h5 id="Java动态绑定机制"><a href="#Java动态绑定机制" class="headerlink" title="Java动态绑定机制"></a>Java动态绑定机制</h5><p>将一个子类的对象地址交给了一个AA(父类的)引用</p>
<h6 id="java的动态绑定机制的小结"><a href="#java的动态绑定机制的小结" class="headerlink" title="java的动态绑定机制的小结"></a>java的动态绑定机制的小结</h6><p>1、<strong>如果调用的是方法，则，jvm机将该方法和对象的内存地址绑定</strong></p>
<p>2、<strong>如果调用的是一个属性，则没有动态绑定机制，在哪里调用，就返回对应值</strong></p>
<pre><code class="java">class A &#123;
    public int i = 10;
    public int sum() &#123;
        return getI() + 10;
    &#125;
    public int sum1() &#123;
        return i + 10;
    &#125;
    public int getI() &#123;
        return i;
    &#125;
&#125;

class B extends A &#123;
    public int i = 20;
    public int sum() &#123;
        return i + 20;
    &#125;
    public int getI() &#123;
        return i;
    &#125;
    public int sum1() &#123;
        return i + 10;
    &#125;
&#125;

A a = new B();
//这个等于30
System.out.println(a.sum());  //?
//30
System.out.println(a.sum1()); //?

//如果把B类的sum方法注释掉呢？?
System.out.println(a.sum());
//这个等于30
//因为动态绑定，执行A类的sum方法时执行B的getI()进行计算
</code></pre>
<h5 id="Scala的覆写字段案例"><a href="#Scala的覆写字段案例" class="headerlink" title="Scala的覆写字段案例"></a>Scala的覆写字段案例</h5><p>其实和java动态绑定机制一样，在取值时，调用age()方法，绑定内存地址就调用B类的age()方法</p>
<pre><code class="scala">class A&#123;
val age :Int = 10
&#125;
class B extends A&#123;
    //override重写
override val age : Int = 20
&#125;
def main(args: Array[String]):Unit = &#123;
    val obj1 = new B
    val obj2 = new B
    //都等于20
    println(obj1.age+obj2.age)
&#125;
</code></pre>
<h5 id="覆写字段的注意事项和细节"><a href="#覆写字段的注意事项和细节" class="headerlink" title="覆写字段的注意事项和细节"></a>覆写字段的注意事项和细节</h5><p>1、<strong>def只能重写另一个def</strong>(即：方法只能重写另一个方法)</p>
<p>2、<strong>val只能重写另一个val</strong> 属性 或 <strong>重写不带参数的def</strong>（带了参数就是重载了）</p>
<p>3、var只能重写另一个<strong>抽象的var属性</strong> </p>
<h5 id="抽象属性-字段"><a href="#抽象属性-字段" class="headerlink" title="抽象属性(字段)"></a>抽象属性(字段)</h5><p><strong>抽象属性</strong>：声明但未初始化的变量就是抽象的属性,抽象属性在抽象类</p>
<p>1、一个属性没有初始化，那么这个属性就是抽象属性</p>
<p>2、抽象属性在编译成字节码文件时，属性并不会声明，但是会自动生成抽象方法，所以类必须声明为抽象类</p>
<p>3、如果是覆写一个父类的抽象属性，那么override 关键字可省略 [原因：父类的抽象属性，生成的是抽象方法，因此就不涉及到方法重写的概念，因此override可省略]</p>
<pre><code class="scala">//抽象类
abstract class A03&#123;
  var name : String//抽象
&#125;
class Sub_A03 extends A03&#123;
  override var name: String = &quot;&quot;
&#125;
</code></pre>
<p>反编译后的java文件</p>
<pre><code class="java">public abstract class A03
&#123;
  public abstract String name();

  public abstract void name_$eq(String paramString);
&#125;
</code></pre>
<h5 id="覆写案例"><a href="#覆写案例" class="headerlink" title="覆写案例"></a>覆写案例</h5><pre><code class="scala">//代码正确吗?
class AAAA &#123;
  var name: String = &quot;&quot;
&#125;
class BBBB extends AAAA &#123;
  override  val name: String = &quot;jj&quot;
&#125;
//这段代码错误的
</code></pre>
<p>这要是成了，就是用BBBB类的方法读，用AAAA类的方法设值了</p>
<pre><code class="scala">//代码正确吗?
class A &#123;
   def sal(): Int = &#123;
      return 10
  &#125;&#125;

class B extends A &#123;
 override val sal : Int = 0
&#125;
//这段代码正确
</code></pre>
<p>val可以重写不带参数的def</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>在Scala中，通过<strong>abstract</strong>关键字标记不能被实例化的类。<strong>方法不用标记abstract，只要省掉方法体即可</strong>。抽象类可以拥有<strong>抽象字段</strong>，抽象字段&#x2F;属性就是没有初始值的字段</p>
<pre><code class="scala">abstract class Animal&#123;
  var name : String //抽象的字段
  var age : Int // 抽象的字段
  var color : String = &quot;black&quot;
  def cry()//抽象方法
&#125;
</code></pre>
<h5 id="抽象类基本语法"><a href="#抽象类基本语法" class="headerlink" title="抽象类基本语法"></a>抽象类基本语法</h5><pre><code>abstract class Person() &#123; // 抽象类 
  var name: String // 抽象字段, 没有初始化
  def printName // 抽象方法, 没有方法体
&#125;
</code></pre>
<h5 id="抽象类有什么用？"><a href="#抽象类有什么用？" class="headerlink" title="抽象类有什么用？"></a>抽象类有什么用？</h5><p>抽象类的价值更多是在于设计，是设计者设计好后，让子类继承并实现抽象类(即：实现抽象类的抽象方法)</p>
<h5 id="Scala抽象类使用的注意事项和细节讨论"><a href="#Scala抽象类使用的注意事项和细节讨论" class="headerlink" title="Scala抽象类使用的注意事项和细节讨论"></a>Scala抽象类使用的注意事项和细节讨论</h5><p>1、抽象类不能被实例，但可以通过匿名子类，在实例化时同时实现它的抽象方法</p>
<p>2、抽象类不一定要包含abstract方法。也就是说,<strong>抽象类可以没有abstract方法</strong></p>
<p>3、一旦类包含了抽象方法或者抽象属性,则这个类必须声明为abstract</p>
<p>4、<strong>抽象方法不能有主体，不允许使用abstract修饰。</strong><br>5、如果一个类继承了抽象类，则它<strong>必须实现抽象类的所有抽象方法和抽象属性，除非它自己也声明为abstract类。</strong><br>6、<strong>抽象方法和抽象属性不能使用private、final 来修饰</strong>，因为这些关键字都是和重写&#x2F;实现相违背的。<br>7、抽象类中可以有实现的方法.<br>8、子类重写抽象方法不需要override，写上也不会错.</p>
<h4 id="匿名子类"><a href="#匿名子类" class="headerlink" title="匿名子类"></a>匿名子类</h4><p>和Java一样，可以通过包含带有定义或重写的代码块的方式创建一个匿名的子类.</p>
<h5 id="Java的匿名子类"><a href="#Java的匿名子类" class="headerlink" title="Java的匿名子类"></a>Java的匿名子类</h5><pre><code class="java">abstract class A2&#123;
    abstract public   void cry();
&#125;

A2 obj = new A2() &#123;
        @Override
        public void cry() &#123;
           System.out.println(&quot;okook!&quot;);
        &#125;
&#125;;
</code></pre>
<h5 id="Scala的匿名子类"><a href="#Scala的匿名子类" class="headerlink" title="Scala的匿名子类"></a>Scala的匿名子类</h5><pre><code class="scala">abstract class Monster&#123;
  var name : String
  def cry()
  &#125;

var monster = new Monster &#123;
      override var name: String = &quot;牛魔王&quot;
      override def cry(): Unit = &#123;
        println(&quot;牛魔王哼哼叫唤..&quot;)
      &#125;
    &#125;
</code></pre>
<h5 id="继承层级关系"><a href="#继承层级关系" class="headerlink" title="继承层级关系"></a>继承层级关系</h5><p>1、在scala中，所有其他类都是AnyRef的子类，类似Java的Object。<br>2、AnyVal和AnyRef都扩展自Any类。Any类是根节点<br>3、<strong>Any中定义了isInstanceOf、asInstanceOf方法，以及哈希方法等。</strong></p>
<p>4、Null类型的唯一实例就是null对象。可以将null赋值给任何引用，但不能赋值给值类型的变量[案例演示]。<br>5、Nothing类型没有实例。它对于泛型结构是有用处的，举例：空列表Nil的类型是List[Nothing]，它是List[T]的子类型，T可以是任何类。</p>
<p><img src="/scala/scala/image-20200214130544337.png" alt="image-20200214130544337"></p>
<h4 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h4><h5 id="Java的静态概念"><a href="#Java的静态概念" class="headerlink" title="Java的静态概念"></a>Java的静态概念</h5><pre><code>public static 返回值类型  方法名(参数列表) &#123;方法体&#125;
      静态属性...
</code></pre>
<p><strong>说明：</strong>: Java中静态方法并不是通过对象调用的，而<strong>是通过类对象调用</strong>的，所以静态操作并不是面向对象的。</p>
<h5 id="Scala中静态的概念"><a href="#Scala中静态的概念" class="headerlink" title="Scala中静态的概念"></a>Scala中静态的概念</h5><p>Scala语言是完全面向对象(万物皆对象)的语言，所以并没有静态的操作(<strong>即在Scala中没有静态的概念</strong>)。但是为了能够和Java语言交互(因为Java中有静态概念)，就产生了一种特殊的对象来<strong>模拟类对象</strong>，我们称之为类的<strong>伴生对象</strong>。这个类的所有<strong>静态内容</strong>都可以<strong>放置在它的伴生对象</strong>中声明和调用</p>
<h5 id="伴生对象的快速入门"><a href="#伴生对象的快速入门" class="headerlink" title="伴生对象的快速入门"></a>伴生对象的快速入门</h5><pre><code class="scala">//class是伴生类
class ScalaPerson &#123;
  var name : String = _
&#125;

//object是伴生对象
object ScalaPerson &#123;
   var sex : Boolean = true
&#125;
</code></pre>
<h5 id="伴生对象的小结"><a href="#伴生对象的小结" class="headerlink" title="伴生对象的小结"></a>伴生对象的小结</h5><p>1、Scala中伴生对象采用object关键字声明，<strong>伴生对象中声明的全是 “静态”内容</strong>，可以通过伴生对象名称直接调用。<br>2、伴生对象对应的类称之为伴生类，<strong>伴生对象的名称应该和伴生类名一致。</strong></p>
<p>3、伴生对象中的属性和方法都可以通过伴生对象名(类名)直接调用访问<br>4、从语法角度来讲，所谓的<strong>伴生对象其实就是类的静态方法和成员的集合</strong><br>5、从技术角度来讲，scala还是没有生成静态的内容，只不过是将伴生对象生成了一个新的类，实现属性和方法的调用。[反编译看源码]<br>6、从底层原理看，<strong>伴生对象实现静态特性是依赖于 public static final  MODULE$ 实现的。</strong> </p>
<p>7、伴生对象的声明应该和伴生类的声明在同一个源码文件中(如果不在同一个文件中会运行错误!)，但是如果没有伴生类，也就没有所谓的伴生对象了，所以放在哪里就无所谓了。</p>
<p>8、如果 class A 独立存在，那么A就是一个类， 如果 object A 独立存在，那么A就是一个”静态”性质的对象[即类对象], 在 object A中声明的属性和方法可以通过 A.属性 和 A.方法 来实现调用</p>
<p>9、当一个文件中，存在伴生类和伴生对象时，文件的图标会发生变化</p>
<h6 id="伴生对象的使用实例"><a href="#伴生对象的使用实例" class="headerlink" title="伴生对象的使用实例:"></a>伴生对象的使用实例:</h6><p>设计一个var total Int表示总人数,我们在创建一个小孩时，就把total加1,并且 total是所有对象共享的就ok了!，我们使用伴生对象来解决</p>
<pre><code class="scala">class Child(cName:String)&#123;
var name = cName
&#125;

object Child02 &#123;
var totalChildNum = 0
def joinGame(child:Child02):Unit=&#123;
printf(&quot;%s 小孩加入了游戏\n&quot;,child.name)
totalchildNum+=1
&#125;
def showNum():Unit=&#123;
printf(&quot;当前有%d小孩玩游戏\
n&quot;,totalChildNum)
&#125;
&#125;
</code></pre>
<h5 id="伴生对象apply方法"><a href="#伴生对象apply方法" class="headerlink" title="伴生对象apply方法"></a>伴生对象apply方法</h5><p>在伴生对象中定义apply方法，可以实现： <strong>类名(参数) 方式来创建对象实例.</strong> </p>
<pre><code class="scala">object ApplyDemo01&#123;
    def main(args:Array[String])；Unit&#123;
    val list = List(1,2,5)
        println(list)
        val pig = new Pig(&quot;hh&quot;)
        
        //使用apply方法创建对象
        val pig2 = Pig(&quot;小黑猪&quot;)
        val pig3 = pig()
    &#125;
&#125;

class Pig(pName:String)&#123;
    var name:String = pName
&#125;

object Pig&#123;
    def apply(pName:String):Pig = new Pig(pName)
    def apply :Pig = new Pig(&quot;默认&quot;)
&#125;
</code></pre>
<h4 id="Trait-接口"><a href="#Trait-接口" class="headerlink" title="Trait(接口)"></a>Trait(接口)</h4><h5 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h5><h6 id="声明接口"><a href="#声明接口" class="headerlink" title="声明接口"></a>声明接口</h6><pre><code>interface 接口名
</code></pre>
<h6 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h6><pre><code>class 类名 implements 接口名1，接口2
</code></pre>
<p>1、在Java中, 一个类可以实现多个接口。<br>2、在Java中，接口之间支持多继承<br>3、接口中属性都是常量<br>4、接口中的方法都是抽象的</p>
<h5 id="Scala接口"><a href="#Scala接口" class="headerlink" title="Scala接口"></a>Scala接口</h5><p>Scala是纯面向对象的语言，在Scala中，没有接口。</p>
<p>Scala语言中，<strong>采用特质trait（特征）来代替接口的概念</strong>，也就是说，多个类具有相同的特征（特征）时，就可以将这个特质（特征）独立出来，采用关键字trait声明。 <strong>理解trait 等价于(interface + abstract class)</strong></p>
<img src="/scala/scala/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200217172555849.png" alt="image-20200217172555849" style="zoom:150%;">

<h5 id="trait-特质-的声明"><a href="#trait-特质-的声明" class="headerlink" title="trait(特质)的声明"></a>trait(特质)的声明</h5><p>trait命名一般首字母大写</p>
<p>在Scala种，java中的接口可以当作特质使用</p>
<pre><code class="scala">trait 特质名&#123;
    trait体
&#125;
</code></pre>
<h6 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h6><pre><code>object T1 extends Serializable&#123;

&#125;
</code></pre>
<h5 id="Scala中trait-的语法"><a href="#Scala中trait-的语法" class="headerlink" title="Scala中trait 的语法"></a>Scala中trait 的语法</h5><p>一个类具有某种特质（特征），就意味着这个类满足了这个特质（特征）的所有要素，所以在使用时，也采用了<strong>extends</strong>关键字，如果有多个特质或存在父类，那么需要采用<strong>with</strong>关键字连接</p>
<pre><code class="scala">没有父类
class  类名   extends   特质1   with    特质2   with   特质3 ..

有父类，(父类必须写在前面)
class  类名   extends   父类   with  特质1   with   特质2   with 特质3
</code></pre>
<p><strong>Scala的继承是单继承</strong>,也就是一个类最多只能有一个父类,这种单继承的机制可保证类<br>的纯洁性,比c++中的多继承机制简洁。但对子类功能的扩展有一定影响.所以<br>我们认为: <strong>Scala引入trait特征 第一可以替代Java的接口,  第二个也是对单继承机制</strong>的一种补充</p>
<h6 id="特质的快速入门案例"><a href="#特质的快速入门案例" class="headerlink" title="特质的快速入门案例"></a>特质的快速入门案例</h6><p><img src="/scala/scala/image-20200217180834234.png" alt="image-20200217180834234"></p>
<pre><code class="scala">trait Trait01&#123;
    def getConnect()
&#125;

class A&#123;&#125;
class B extends A&#123;&#125;
class C extends C with Trait01&#123;
    override def getConnect():Unit=&#123;
        
    &#125;
&#125;

class D &#123;&#125;
class E extends D with Trait01&#123;
    override def getConnect():Unit=&#123;
        
    &#125;
&#125;
class F extends D&#123;&#125;
</code></pre>
<h5 id="带有具体实现的特质"><a href="#带有具体实现的特质" class="headerlink" title="带有具体实现的特质"></a>带有具体实现的特质</h5><p>和Java中的接口不太一样的是<strong>特质中的方法并不一定是抽象的，也可以有非抽象方法</strong>(即：实现了的方法)。</p>
<pre><code class="scala">trait Trait03&#123;
  //抽象方法
  def sayHi()
  //普通方法
  def sayHello(): Unit =&#123;
    println(&quot;say Hello&quot;)
  &#125;
&#125;
</code></pre>
<h5 id="trait执行流程"><a href="#trait执行流程" class="headerlink" title="trait执行流程"></a>trait执行流程</h5><p>同时有抽象方法和普通方法的执行流程：trait生成两个文件，Trait03和Trait03$class。Trait03是一个接口，存着trait的所有方法，Trait03$class文件是一个抽象类，存着trait的普通方法，继承了Trait03的类会实现Trait03接口，普通方法调用trait03$class的普通方法，重写接口中的抽象方法</p>
<pre><code class="scala">object TraitDemo02 &#123;
  def main(args: Array[String]): Unit = &#123;
    val sheep = new Sheep
    sheep.sayHi()
    sheep.sayHello()
  &#125;
&#125;
trait Trait03&#123;
  //抽象方法
  def sayHi()
  //普通方法
  def sayHello(): Unit =&#123;
    println(&quot;say Hello&quot;)
  &#125;
&#125;

class Sheep extends Trait03&#123;
  override def sayHi(): Unit = &#123;
    println(&quot;Sheep hi&quot;)
  &#125;
&#125;
</code></pre>
<p><img src="/scala/scala/image-20200217184449697.png" alt="image-20200217184449697"></p>
<h4 id="动态混入"><a href="#动态混入" class="headerlink" title="动态混入"></a>动态混入</h4><p>1、除了可以在类声明时继承特质以外，还可以在构建对象时混入特质，扩展目标类的功能</p>
<p>2、此种方式也可以应用于对抽象类功能进行扩展</p>
<p>3、动态混入是<strong>Scala特有的方式</strong>（java没有动态混入），可在不修改类声明&#x2F;定义的情况下，扩展类的功能，非常的灵活，<strong>耦合性低</strong> 。</p>
<p>4、动态混入可以在不影响原有的继承关系的基础上，给指定的类扩展功能。</p>
<p>5、要注意动态混入时，抽象类也有抽象方法，如何混入</p>
<pre><code class="scala">object MinInDemo01 &#123;
  def main(args: Array[String]): Unit = &#123;
    //不修改类定义的基础上使用trait的方法
    val oracle = new OratleDB with Operate3
    oracle.insert(3)
    val l = new MySQL3 with Operate3 &#123;&#125;

  &#125;
&#125;

trait Operate3 &#123;
  def insert(id:Int): Unit =&#123;
    println(&quot;插入数据&quot;+id)
  &#125;
&#125;
class OratleDB&#123;

&#125;
abstract class MySQL3&#123;

&#125;
</code></pre>
<h5 id="Scala中创建对象有几种方式？"><a href="#Scala中创建对象有几种方式？" class="headerlink" title="Scala中创建对象有几种方式？"></a>Scala中创建对象有几种方式？</h5><p>1、new对象</p>
<p>2、apply创建</p>
<p>3、匿名子类创建</p>
<p>4、动态混入</p>
<h4 id="叠加特质"><a href="#叠加特质" class="headerlink" title="叠加特质"></a>叠加特质</h4><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><p><strong>构建对象的同时如果混入多个特质，称之为叠加特质</strong>，那么<strong>特质声明顺序从左到右</strong>，方法执<strong>行顺序从右到左</strong>。</p>
<p><strong>调用父类方法是调用右边特质的方法，如果右边没有方法才会去父类找</strong></p>
<h6 id="案例：-1"><a href="#案例：-1" class="headerlink" title="案例："></a>案例：</h6><p>目的：分析叠加特质时，对象的构建顺序，和执行方法的顺序</p>
<pre><code class="scala">object AddTraits &#123;
  def main(args: Array[String]): Unit = &#123;
      //初始化构建
    val mysql = new MySQL4 with DB4 with File4
    println(mysql)
    //结果：
    //Operate444
    //date444
    //db4
    //file4
    //内存地址
       println(&quot;________________&quot;)
    println(mysql.insert(1))
    //执行的顺序从右到左，调用父类方法是调用左边类的方法	
    //结果：
    //文件
    //db4
    //插入数据1
    
  &#125;
&#125;
trait Operate4&#123;
  //特质里面的打印语句会生成一个构造器
  println(&quot;Operate444&quot;)
  def insert(id:Int)
&#125;
trait Date4 extends Operate4  &#123;
  println(&quot;date444&quot;)

  override def insert(id: Int): Unit = &#123;
    println(&quot;插入数据&quot;+id)
  &#125;
&#125;
trait DB4 extends Date4 &#123;
  println(&quot;db4&quot;)

  override def insert(id: Int): Unit = &#123;
    println(&quot;db4&quot;)
    super.insert(id)
  &#125;

&#125;

trait File4 extends Date4&#123;
  println(&quot;file4&quot;)

  override def insert(id: Int): Unit = &#123;
    println(&quot;文件&quot;)
    super.insert(id)
  &#125;

&#125;

class MySQL4&#123;

&#125;
</code></pre>
<h5 id="叠加特质注意事项和细节"><a href="#叠加特质注意事项和细节" class="headerlink" title="叠加特质注意事项和细节"></a>叠加特质注意事项和细节</h5><p>1、<strong>特质声明顺序从左到右。</strong><br>2、Scala在执行叠加对象的方法时，会首<strong>先从后面的特质(从右向左)开始执行</strong><br>3、Scala中特质中如果<strong>调用super</strong>，并不是表示调用父特质的方法，而<strong>是向前面（左边）继续查找特质，如果找不到，才会去父特质查找</strong><br>4、如果想要调用具体特质的方法，可以指定：super[特质].xxx(…).其中的泛型<strong>必须是该特质的直接超类类型</strong></p>
<pre><code class="scala">trait File4 extends Date4&#123;
  println(&quot;file4&quot;)

  override def insert(id: Int): Unit = &#123;
    println(&quot;文件&quot;)
    super[Date4].insert(id)
  &#125;

&#125;
</code></pre>
<h5 id="在特质中重写抽象方法"><a href="#在特质中重写抽象方法" class="headerlink" title="在特质中重写抽象方法"></a>在特质中重写抽象方法</h5><p>给某个方法增加了abstract override ，重写了父特质的抽象方法</p>
<pre><code class="scala">object MixInDemo02 &#123;
  def main(args: Array[String]): Unit = &#123;
    val mySql = new MySql5 with DB5 with File5
    mySql.insert(666)
    val mySql_ = new MySql5 with File5 with DB5 //error
    //File5在父类MySql5找实现方法没找到
  &#125;
&#125;

trait Operate5&#123;
  def insert(id:Int)
&#125;

trait File5 extends Operate5&#123;
    //在这里先输出File5，然后找左边父类的insert方法，输出DB5
  abstract override def insert(id: Int): Unit = &#123;
    println(&quot;File5&quot;)
    super.insert(id)
  &#125;
&#125;

trait DB5 extends Operate5&#123;
  override def insert(id: Int): Unit = &#123;
    println(&quot;DB5&quot;)
  &#125;
&#125;

class MySql5&#123;

&#125;
</code></pre>
<h6 id="理解-abstract-override-的小技巧"><a href="#理解-abstract-override-的小技巧" class="headerlink" title="理解 abstract override 的小技巧"></a>理解 abstract override 的小技巧</h6><p>重写抽象方法时需要考虑混入特质的<strong>顺序问题</strong>和<strong>完整性</strong>问题 </p>
<p>我们给某个方法增加了abstract override 后，就是明确的告诉编译器，该方法确实是重写了父特质的抽象方法，但是重写后，该方法仍然是一个抽象方法（因为没有完全的实现，需要其它特质继续实现[通过混入顺序]）</p>
<h5 id="富接口使用的特质"><a href="#富接口使用的特质" class="headerlink" title="富接口使用的特质"></a>富接口使用的特质</h5><p>富接口：即该<strong>特质中既有抽象方法，又有非抽象方法</strong></p>
<h5 id="特质中的具体字段"><a href="#特质中的具体字段" class="headerlink" title="特质中的具体字段"></a>特质中的具体字段</h5><p>特质中可以定义具体字段，如果<strong>初始化了就是具体字段，如果不初始化就是抽象字</strong>段。混入该特质的类就具有了该字段，字段不是继承，而<strong>是直接加入类，成为自己的字段</strong>。</p>
<p>特质中未被初始化的字段在具体的子类中必须被重写。</p>
<h5 id="特质构造顺序"><a href="#特质构造顺序" class="headerlink" title="特质构造顺序"></a>特质构造顺序</h5><pre><code class="scala">//从左到右，从Mysql开始初始化，先执行MySql构造器
val mysql2 = new MySQL4 with File4 with DB4
</code></pre>
<pre><code class="scala">//从左到右，从EE开始初始化，最后执行FF构造器
class FF extends EE with CC with DD &#123;
  println(&quot;F....&quot;)
&#125;
</code></pre>
<h5 id="分析两种方式对构造顺序的影响"><a href="#分析两种方式对构造顺序的影响" class="headerlink" title="分析两种方式对构造顺序的影响"></a>分析两种方式对构造顺序的影响</h5><p> 第1种方式实际是构造匿名子类，可以理解成在混入特质时，对象已经创建了。 第2种方式实际是构建类对象, 在混入特质时，该对象还没有创建。</p>
<h5 id="扩展类的特质"><a href="#扩展类的特质" class="headerlink" title="扩展类的特质"></a>扩展类的特质</h5><p>特质可以继承类，以用来扩展该特质类的一些功能</p>
<pre><code class="scala">trait LoggedException extends Exception&#123;
  def log(): Unit =&#123;
    println(getMessage)
  &#125;
&#125;
</code></pre>
<p>所有混入该特质的类，<strong>会自动成为那个特质所继承的超类的子类</strong>（UnhappyException2也是Exception的子类了）</p>
<pre><code class="scala">class UnhappyException2 extends IndexOutOfBoundsException with LoggedException&#123;
&#125;
</code></pre>
<p>如果混<strong>入该特质的类，已经继承了另一个类(A类)，则要求A类是特质超类的子类</strong>，否则就会出现了多继承现象，发生错误。（要有相同的父类）</p>
<pre><code class="scala">//他们的父类都是Exception
class UnhappyException2 extends IndexOutOfBoundsException with LoggedException&#123;
&#125;

//错误案例：
class CCC&#123;&#125;
class UnhappyException3 extends CCC with LoggedException&#123;&#125;
</code></pre>
<h5 id="自身类型"><a href="#自身类型" class="headerlink" title="自身类型"></a>自身类型</h5><p>自身类型：主要是为了<strong>解决特质的循环依赖问题</strong>，同时可以确保特质在不扩展某个类的情况下，依然可以做到限制混入该特质的类的类型。</p>
<pre><code class="scala">//Logger就是自身类型特质
trait Logger &#123;
  // 明确告诉编译器，我就是Exception,如果没有这句话，下面的getMessage不能调用
  this: Exception =&gt;
  def log(): Unit =&#123;
    // 既然我就是Exception, 那么就可以调用其中的方法
    println(getMessage)
  &#125;
&#125;
</code></pre>
<pre><code class="scala">class Console extends  Logger &#123;&#125; //error
class Console extends Exception with Logger//ok
</code></pre>
<h5 id="面试题：Java中，类共有五大成员，请说明是哪五大成员"><a href="#面试题：Java中，类共有五大成员，请说明是哪五大成员" class="headerlink" title="面试题：Java中，类共有五大成员，请说明是哪五大成员"></a>面试题：Java中，类共有五大成员，请说明是哪五大成员</h5><p>1.属性<br>2.方法<br>3.内部类<br>4.构造器<br>5.代码块</p>
<h4 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h4><h5 id="Java的内部类"><a href="#Java的内部类" class="headerlink" title="Java的内部类"></a>Java的内部类</h5><p>在类中可以再定义一个类，这样的类是嵌套类，其他语法结构也是一样。<br>嵌套类类似于Java中的内部类</p>
<p>在Java中，一个类的内部又完整的嵌套了另一个完整的类结构。被<strong>嵌套的类称为内部类(inner class)<strong>，嵌套其他类的类称为外部类。内部类最大的特点就是</strong>可以直接访问私有属性</strong>，并且可以体现类与类之间的包含关系 </p>
<h6 id="Java内部类基本语法"><a href="#Java内部类基本语法" class="headerlink" title="Java内部类基本语法"></a>Java内部类基本语法</h6><pre><code class="java">class Outer&#123;	//外部类   
class Inner&#123;	//内部类&#125;
&#125;
class Other&#123;	//外部其他类
&#125;
</code></pre>
<h6 id="Java内部类的分类"><a href="#Java内部类的分类" class="headerlink" title="Java内部类的分类"></a>Java内部类的分类</h6><p>从定义在外部类的成员位置上来看，</p>
<p><strong>1) 成员内部类（没用static修饰）</strong><br><strong>2) 和静态内部类（使用static修饰），</strong></p>
<p>定义在外部类局部位置上（比如方法内）来看：<br><strong>分为局部内部类（有类名）</strong><br><strong>匿名内部类（没有类名</strong>）</p>
<h4 id="Scala嵌套类"><a href="#Scala嵌套类" class="headerlink" title="Scala嵌套类"></a>Scala嵌套类</h4><pre><code class="scala">class ScalaOuterClass &#123;
  class ScalaInnerClass &#123; //成员内部类
  &#125;
&#125;
object ScalaOuterClass &#123;  //伴生对象
  class ScalaStaticInnerClass &#123; //静态内部类
  &#125;
&#125;
</code></pre>
<pre><code class="scala"> val outer1 : ScalaOuterClass = new ScalaOuterClass();
 val outer2 : ScalaOuterClass = new ScalaOuterClass();

 // Scala创建内部类的方式和Java不一样，将new关键字放置在前，使用  对象.内部类  的方式创建
 val inner1 = new outer1.ScalaInnerClass()
 val inner2 = new outer2.ScalaInnerClass()
 //创建静态内部类对象
 val staticInner = new ScalaOuterClass.ScalaStaticInnerClass()
 println(staticInner)
</code></pre>
<h5 id="在内部类中访问外部类的属性"><a href="#在内部类中访问外部类的属性" class="headerlink" title="在内部类中访问外部类的属性"></a>在内部类中访问外部类的属性</h5><h6 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h6><p>内部类如果想要访问外部类的属性，可以通过外部类对象访问。</p>
<p>即：<strong>访问方式：外部类名.this.属性名</strong>  </p>
<pre><code class="scala">class ScalaOuterClass &#123;
  var name : String = &quot;scott&quot;
  private var sal : Double = 1.2
  class ScalaInnerClass &#123; //成员内部类
    def info() = &#123;
      // 访问方式：外部类名.this.属性名
      // 怎么理解 ScalaOuterClass.this 就相当于是 ScalaOuterClass 这个外部类的一个实例,
      // 然后通过 ScalaOuterClass.this 实例对象去访问 name 属性
      // 只是这种写法比较特别，学习java的同学可能更容易理解 ScalaOuterClass.class 的写法.
      println(&quot;name = &quot; + ScalaOuterClass.this.name
        + &quot; age =&quot; + ScalaOuterClass.this.sal)
    &#125;&#125;&#125;
</code></pre>
<h6 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h6><p>内部类如果想要访问外部类的属性，也可以通过外部类别名访问(<strong>推荐</strong>)。</p>
<p>即：<strong>访问方式：外部类名别名.属性名</strong>   </p>
<pre><code class="scala">class ScalaOuterClass &#123;
  myOuter =&gt;  //这样写，你可以理解成这样写，myOuter就是代表外部类的一个对象.
  class ScalaInnerClass &#123; //成员内部类
    def info() = &#123;
      println(&quot;name = &quot; + ScalaOuterClass.this.name
        + &quot; age =&quot; + ScalaOuterClass.this.sal)
      println(&quot;-----------------------------------&quot;)
      println(&quot;name = &quot; + myOuter.name
        + &quot; age =&quot; + myOuter.sal)
    &#125;&#125;
  // 当给外部指定别名时，需要将外部类的属性放到别名后.
  var name : String = &quot;scott&quot;
  private var sal : Double = 1.2
&#125;
</code></pre>
<h4 id="类型投影"><a href="#类型投影" class="headerlink" title="类型投影"></a>类型投影</h4><p>&#x2F;&#x2F;说明下面调用test 的 正确和错误的原因：<br>&#x2F;&#x2F;1.Java中的内部类从属于外部类,因此在java中 inner.test(inner2) 就可以，因为是按类型来匹配的。<br>&#x2F;&#x2F;2 <strong>Scala中内部类从属于外部类的对象</strong>，所以外部类的对象不一样，创建出来的内部类也不一样，无法互换使用<br>&#x2F;&#x2F;3. 比如你使用idea 看一下在inner1.test()的形参上，它提示的类型是 outer1.ScalaOuterClass, 而不是ScalaOuterClass</p>
<p>inner1.test(inner1) &#x2F;&#x2F;</p>
<p> ok inner1.test(inner2) &#x2F;&#x2F; 错误</p>
<pre><code class="scala">class ScalaOuterClass3 &#123;
  myOuter =&gt;
  class ScalaInnerClass3 &#123; //成员内部类
    def test(ic: ScalaInnerClass3): Unit = &#123;
      System.out.println(ic)
    &#125;
  &#125;
&#125;
object Scala01_Class &#123;
    def main(args: Array[String]): Unit = &#123;
        val outer1 : ScalaOuterClass3 = new ScalaOuterClass3();
        val outer2 : ScalaOuterClass3 = new ScalaOuterClass3();
        val inner1 = new outer1.ScalaInnerClass3()
        val inner2 = new outer2.ScalaInnerClass3()
        inner1.test(inner1) // ok, 因为 需要outer1.ScalanInner
        inner1.test(inner2) // error, 需要outer1.ScalanInnerouter2.ScalanInner
    &#125;
&#125;
</code></pre>
<h5 id="使用类型投影"><a href="#使用类型投影" class="headerlink" title="使用类型投影"></a>使用类型投影</h5><p>类型投影是指：在方法声明上，如果使用  外部类#内部类  的方式，表示忽略内部类的对象关系，等同于Java中内部类的语法操作，我们将这种方式称之为 类型投影（即：<strong>忽略对象的创建方式，只考虑类型</strong>）</p>
<pre><code class="scala">class ScalaOuterClass3 &#123;
  myOuter =&gt;
  class ScalaInnerClass3 &#123; //成员内部类
    def test(ic: ScalaOuterClass3#ScalaInnerClass3): Unit = &#123;
      System.out.println(ic)
    &#125;
  &#125;
&#125;
</code></pre>
<h4 id="隐式转换和隐式值"><a href="#隐式转换和隐式值" class="headerlink" title="隐式转换和隐式值"></a>隐式转换和隐式值</h4><p>隐式转换函数是以<strong>implicit</strong>关键字声明的带有单个参数的函数。这种函数将会<strong>自动应用</strong>，将值<strong>从一种类型转换为另一种类型</strong></p>
<pre><code class="scala">//解决数据类型转换,Double转Int
implicit def f1(d: Double): Int = &#123;  d.toInt
&#125;
</code></pre>
<h5 id="隐式转换的注意事项和细节"><a href="#隐式转换的注意事项和细节" class="headerlink" title="隐式转换的注意事项和细节"></a>隐式转换的注意事项和细节</h5><p>1、隐式转换函数的函数名可以是任意的，隐式转换与函数名称无关，只与<strong>函数签名</strong>（<strong>函数参数类型和返回值类型</strong>）有关。</p>
<p>2、隐式函数可以有多个(即：隐式函数列表)，但是需要保证在当前环境下，<strong>只有一个隐式函数能被识别</strong></p>
<pre><code class="scala">implicit def a(d: Double) = d.toInt
implicit def b(d: Double) = d.toInt 
val i1 :Int = 3.5//error,编译器不知道该用哪个，所以出错
</code></pre>
<h5 id="隐式转换丰富类库功能"><a href="#隐式转换丰富类库功能" class="headerlink" title="隐式转换丰富类库功能"></a>隐式转换丰富类库功能</h5><p>隐式转换方式动态的给MySQL类增加delete方法。</p>
<pre><code class="scala">//给mysql添加delete方法，不修改mysql
class MySQL&#123;
  def insert(): Unit = &#123;
    println(&quot;insert&quot;)
  &#125;
&#125;
class DB &#123;
  def delete(): Unit = &#123;
    println(&quot;delete&quot;)
  &#125;
&#125;

//隐式转换
implicit def addDelete(mysql:MySql):DB=&#123;
new DB
&#125;
</code></pre>
<h4 id="隐式值"><a href="#隐式值" class="headerlink" title="隐式值"></a>隐式值</h4><h5 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>隐式值也叫隐式变量，将某个形参变量标记为implicit，所以编译器会在方法省略隐式参数的情况下去搜索作用域内的隐式值作为缺省参数</p>
<pre><code class="scala">implicit val str1: String = &quot;jack&quot;
def hello(implicit name: String): Unit = &#123;
println(name + &quot; hello&quot;)
&#125;
hello //调用.不带()
//jackhello
</code></pre>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><pre><code class="scala">//报错，因为两个相似的不知道选哪个(二义性)
object ImplicitVal02 &#123;
  def main(args: Array[String]): Unit = &#123;
      // 隐式变量（值）
      implicit val name: String = &quot;Scala&quot;
      implicit val name1: String = &quot;World&quot;

      def hello(implicit content: String = &quot;jack&quot;): Unit = &#123;
        println(&quot;Hello &quot; + content)
      &#125; //调用hello
      hello
    &#125;
&#125;
</code></pre>
<pre><code class="scala">//输出HelloScala，隐式值是直接传入方法的，比默认值优先级高
object ImplicitVal02 &#123;
  def main(args: Array[String]): Unit = &#123;
      // 隐式变量（值）
      implicit val name: String = &quot;Scala&quot;
      def hello(implicit content: String = &quot;jack&quot;): Unit = &#123;
        println(&quot;Hello &quot; + content)
      &#125; //调用hello
      hello
    &#125;
&#125;
</code></pre>
<pre><code class="scala">//类型不匹配按默认值执行
object ImplicitVal02 &#123;
  def main(args: Array[String]): Unit = &#123;
      // 隐式变量（值）
      implicit val Int: Int = &quot;Scala&quot;
      def hello(implicit content: String = &quot;jack&quot;): Unit = &#123;
        println(&quot;Hello &quot; + content)
      &#125; //调用hello
      hello
    &#125;
&#125;
</code></pre>
<pre><code class="scala">//三个(传值，默认值，隐式参数)都没有，会报错
object ImplicitVal02 &#123;
  def main(args: Array[String]): Unit = &#123;
      // 隐式变量（值）
      implicit val Int: Int = &quot;Scala&quot;
      def hello(implicit content: String): Unit = &#123;
        println(&quot;Hello &quot; + content)
      &#125; //调用hello
      hello
    &#125;
&#125;
</code></pre>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>1、但在程序中，同时有隐式值，默认值，传值</p>
<p>2、编译器优先级为传值，隐式值，默认值</p>
<p>3、隐式值匹配时，不能有二义性</p>
<p>4、如果三个(传值，隐式值，默认值)一个都没有就会报错</p>
<h4 id="隐式类"><a href="#隐式类" class="headerlink" title="隐式类"></a>隐式类</h4><p>在scala2.10后提供了隐式类，可以使用implicit声明类，隐式类的非常强大，同样可以扩展类的功能，比前面使用隐式转换丰富类库功能更加的方便，在集合中隐式类会发挥重要的作用。</p>
<h5 id="隐式类使用有如下几个特点："><a href="#隐式类使用有如下几个特点：" class="headerlink" title="隐式类使用有如下几个特点："></a>隐式类使用有如下几个特点：</h5><p>1、其所带的<strong>构造参数有且只能有一个</strong><br>2、隐式类必须被定义在“类”或“伴生对象”或“包对象”里，即<strong>隐式类不能是 顶级的</strong>(top-level  objects)。<br>3、隐式类不能是case class（case class在后续介绍 样例类）<br>4、<strong>作用域内不能有与之相同名称的标识符</strong></p>
<pre><code class="scala">object ImplicitClassDemo &#123;
  def main(args: Array[String]): Unit = &#123;
  //隐式类
    implicit class DB1(val m: MySQL1) &#123;
      def addSuffix(): String = &#123;
        m + &quot;scala&quot;
      &#125;
    &#125;
    val mysql = new MySQL1
    mysql.addSuffix()
  &#125;
&#125;
class MySQL1&#123;
  def sayOk(): Unit =&#123;
    println(&quot;sayOk&quot;)
  &#125;
&#125;
</code></pre>
<pre><code class="scala">object ImplicitClassDemo &#123;
  def main(args: Array[String]): Unit = &#123;
    val mysql = new MySQL1
    mysql.addSuffix()
  &#125;
&#125;
  //隐式类不能放在最外面
    implicit class DB1(val m: MySQL1) &#123;
      def addSuffix(): String = &#123;
        m + &quot;scala&quot;
      &#125;
    &#125;
class MySQL1&#123;
  def sayOk(): Unit =&#123;
    println(&quot;sayOk&quot;)
  &#125;
&#125;
</code></pre>
<h5 id="隐式的转换时机"><a href="#隐式的转换时机" class="headerlink" title="隐式的转换时机"></a>隐式的转换时机</h5><p>1、当方法中的参数的类型与目标类型不一致时，或是赋值时<br>2、当对象调用所在类中不存在的方法或成员时，编译器会自动将对象进行隐式转换（根据类型）</p>
<pre><code class="scala">implicit def (d:Double):Int=&#123;
    d.toInt
&#125;
def test1(n1:Int)&#123;
    println(&quot;ok&quot;)
&#125;
test1(10.1)
</code></pre>
<h6 id="隐式解析机制"><a href="#隐式解析机制" class="headerlink" title="隐式解析机制"></a>隐式解析机制</h6><p>即编译器是如何查找到缺失信息的，解析具有以下两种规则：</p>
<p>1)首先会在当前代码作用域下查找隐式实体（隐式方法、隐式类、隐式对象）。(<strong>一般是这种情况</strong>)</p>
<p>2)如果第一条规则查找隐式实体失败，会继续在隐式参数的类型的作用域里查找。类型的作用域是指与该类型相关联的全部伴生模块，一个隐式实体的类型T它的查找范围如下(<strong>第二种情况范围广且复杂在使用时，应当尽量避免出现</strong>)：</p>
<p>a) 如果T被定义为T with A with B with C,那么A,B,C都是T的部分，在T的隐式解析过程中，它们的伴生对象都会被搜索。</p>
<p>b) 如果T是参数化类型，那么类型参数和与类型参数相关联的部分都算作T的部分，比如List[String]的隐式搜索会搜索List的伴生对象和String的伴生对象。</p>
<p>c) 如果T是一个单例类型p.T，即T是属于某个p对象内，那么这个p对象也会被搜索。</p>
<p>d) 如果T是个类型注入S#T，那么S和T都会被搜索。</p>
<h5 id="隐式转换的前提"><a href="#隐式转换的前提" class="headerlink" title="隐式转换的前提"></a>隐式转换的前提</h5><p>在进行隐式转换时，需要遵守两个基本的前提：</p>
<p>1)不能存在二义性</p>
<p>2)隐式操作不能嵌套使用 &#x2F;&#x2F; [举例：]如:隐式转换函数</p>
<pre><code class="scala">implicit def (d:Double):Int=&#123;
    d.toInt
    //error不能嵌套，等于自己调自己形成递归
    var num2 = 1.2
&#125;
</code></pre>
<p>String是char的一个集合，按照索引来查询的 </p>
<h4 id="数据结构（应用）"><a href="#数据结构（应用）" class="headerlink" title="数据结构（应用）"></a>数据结构（应用）</h4><h5 id="scala集合基本介绍"><a href="#scala集合基本介绍" class="headerlink" title="scala集合基本介绍"></a>scala集合基本介绍</h5><p>Scala同时支持<strong>不可变集合</strong>和<strong>可变集合</strong>，不可变集合可以安全的并发访问<br>两个主要的包：</p>
<p><strong>不可变集合：scala.collection.immutable</strong><br><strong>可变集合：  scala.collection.mutable</strong></p>
<p><strong>Scala默认采用不可变集合</strong>，对于几乎所有的集合类，Scala都同时提供了可变(mutable)和不可变(immutable)的版本<br>Scala的集合有<strong>三大类：序列Seq、集Set、映射Map</strong>，所有的集合都扩展自<strong>Iterable</strong>特质，在Scala中集合有可变（mutable）和不可变（immutable）两种类型。 </p>
<h6 id="什么时候用什么集合？"><a href="#什么时候用什么集合？" class="headerlink" title="什么时候用什么集合？"></a>什么时候用什么集合？</h6><p>序列(Seq，有序的，Linear Seq)</p>
<p>Set(去重时用Set)</p>
<p>Map()</p>
<h5 id="可变集合和不可变集合举例"><a href="#可变集合和不可变集合举例" class="headerlink" title="可变集合和不可变集合举例"></a>可变集合和不可变集合举例</h5><p><strong>不可变集合</strong>：scala不可变集合，就是这个<strong>集合本身不能动态变化</strong>。(类似java的数组，是不可以动态增长的)<br><strong>可变集合</strong>:可变集合，就是这个<strong>集合本身可以动态变化的</strong>。(比如:ArrayList , 是可以动态增长的) </p>
<h5 id="Scala不可变集合继承关系一览图"><a href="#Scala不可变集合继承关系一览图" class="headerlink" title="Scala不可变集合继承关系一览图"></a>Scala不可变集合继承关系一览图</h5><p><img src="/scala/scala/image-20200222111236407.png" alt="image-20200222111236407"></p>
<h6 id="不可变集合小结："><a href="#不可变集合小结：" class="headerlink" title="不可变集合小结："></a>不可变集合小结：</h6><p>1.Set、Map是Java中也有的集合</p>
<p>2.Seq是Java没有的，我们发现List归属到Seq了,因此这里的List就和java不是同一个概念了</p>
<p>3.我们前面的for循环有一个 1 to 3 , 就是IndexedSeq 下的Vector<br>4.String也是属于IndexeSeq<br>5.我们发现经典的数据结构比如Queue 和 Stack被归属到LinearSeq<br>6.大家注意Scala中的Map体系有一个SortedMap,说明<strong>Scala的Map可以支持排序</strong><br>7**.IndexSeq 和 LinearSeq 的区别**[IndexSeq是通过索引来查找和定位，因此速度快，比如String就是一个索引集合，通过索引即可定位] [LineaSeq 是线型的，即有头尾的概念，这种数据结构一般是通过遍历来查找，它的价值在于应用到一些具体的应用场景 (电商网站, 大数据推荐系统 :最近浏览的10个商品)</p>
<p><strong>他返回了一个新的对象，这里面就是指返回了一个新的集合，而老的集合没有改变。</strong></p>
<h5 id="Scala可变集合继承关系一览图"><a href="#Scala可变集合继承关系一览图" class="headerlink" title="Scala可变集合继承关系一览图"></a>Scala可变集合继承关系一览图</h5><img src="/scala/scala/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200222111943952.png" alt="image-20200222111943952" style="zoom:150%;">

<h6 id="可变集合小结"><a href="#可变集合小结" class="headerlink" title="可变集合小结"></a>可变集合小结</h6><p>1）在可变集合中比不可变集合更加丰富</p>
<p>2）在Seq集合中，增加了Buffer(缓冲)集合，将来开发我们常用的有ArrayBuffer和ListBuffer</p>
<p>3）如果涉及到线程安全，使用Syn开头的集合</p>
<h4 id="定长数组-声明泛型"><a href="#定长数组-声明泛型" class="headerlink" title="定长数组(声明泛型)"></a>定长数组(声明泛型)</h4><p>第一种方式定义数组</p>
<pre><code class="scala">这里的数组等同于Java中的数组,中括号的类型就是数组的类型
val arr1 = new Array[Int](10)
//赋值,集合元素采用小括号访问
arr1(1) = 7 
for (i &lt;- arr01) &#123;
println(i)
&#125;
</code></pre>
<p>第二种方式定义数组</p>
<pre><code class="scala">在定义数组时，直接赋值
//使用apply方法创建数组对象
val arr1 = Array(1, 2)//arr1的类型是Int
for (i &lt;- arr02) &#123;
println(i)
&#125;

val arr2 = Array(1, 2,&quot;String&quot;)//arr2的类型是Any
for (i &lt;- arr2) &#123;
println(i)
&#125;
</code></pre>
<h5 id="变长数组-声明泛型"><a href="#变长数组-声明泛型" class="headerlink" title="变长数组(声明泛型)"></a>变长数组(声明泛型)</h5><pre><code class="scala">//定义/声明
val arr2 = ArrayBuffer[Int]()
//追加值/元素
arr2.append(7)
//重新赋值
arr2(0) = 7
//学习集合的流程(创建,查询,修改,删除)
</code></pre>
<h5 id="变长数组分析小结"><a href="#变长数组分析小结" class="headerlink" title="变长数组分析小结"></a>变长数组分析小结</h5><ol>
<li>ArrayBuffer是变长数组，类似java的ArrayList</li>
</ol>
<p>2)val arr2 &#x3D; ArrayBuffer<a href>Int</a> 也是使用的apply方法构建对象</p>
<p>3)<strong>def</strong> append(elems: A*) { appendAll(elems) } 接收的是可变参数.</p>
<p>4)<strong>每append一次，arr在底层会重新分配空间，进行扩容，arr2的内存地址会发生变化，也就成为新的ArrayBuffer</strong></p>
<h5 id="定长数组与变长数组的转换"><a href="#定长数组与变长数组的转换" class="headerlink" title="定长数组与变长数组的转换"></a>定长数组与变长数组的转换</h5><pre><code>arr1.toBuffer  //定长数组转可变数组
arr2.toArray  //可变数组转定长数组

//！注意：
//arr2.toArray 返回结果才是一个定长数组， arr2本身没有变化
//arr1.toBuffer返回结果才是一个可变数组， arr1本身没有变化
</code></pre>
<pre><code class="scala">val buffer = ArrayBuffer[Int]()
buffer.append(1)
val array2 = buffer.toArray
</code></pre>
<pre><code class="scala">val array = Array[Int](3)
array(0)=32
val buffer1 = array.toBuffer
</code></pre>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><h5 id="多维数组的定义和使用"><a href="#多维数组的定义和使用" class="headerlink" title="多维数组的定义和使用"></a>多维数组的定义和使用</h5><pre><code class="scala">val arr = Array.ofDim[Double](3,4)
//说明：二维数组中有三个一维数组，每个一维数组中有四个元素
//赋值
arr(1)(1) = 11.11
</code></pre>
<pre><code class="scala">    val arr = Array.ofDim[Int](3, 4)
    arr(1)(1)=100
    //遍历方式1
    for (item &lt;- arr) &#123; //取出二维数组的各个元素
      for (item2 &lt;- item) &#123; //一维数组元素捋一遍
        print(&quot;\t&quot;+item2)
      &#125;
      println()
    &#125;
    //遍历方式2
    for (item &lt;- 0 to arr.length-1) &#123; //取出二维数组的各个元素
      for (item2 &lt;-0 to arr(item).length-1) &#123; //一维数组元素捋一遍
        printf(&quot;arr[%s][%h]=%s\t&quot;,item,item2,arr(item)(item2))
      &#125;
      println()
    &#125;
</code></pre>
<h5 id="Scala数组与Java的List的互转"><a href="#Scala数组与Java的List的互转" class="headerlink" title="Scala数组与Java的List的互转"></a>Scala数组与Java的List的互转</h5><h5 id="在项目开发中，有时我们需要将Scala数组转成Java数组，看下面案例："><a href="#在项目开发中，有时我们需要将Scala数组转成Java数组，看下面案例：" class="headerlink" title="在项目开发中，有时我们需要将Scala数组转成Java数组，看下面案例："></a>在项目开发中，有时我们需要将Scala数组转成Java数组，看下面案例：</h5><pre><code class="scala">    // Scala集合和Java集合互相转换
    val buffer = ArrayBuffer(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;)
    println(buffer)
    import scala.collection.JavaConversions.bufferAsJavaList
    //这里通过调用隐式函数buffer转成List类型，调用ProcessBuilder构造器
    var javaarr = new ProcessBuilder(buffer)
    //调用command方法返回arrlist
    val arrList = javaarr.command()
    println(arrList)//输出[1,2,3]
</code></pre>
<h6 id="补充多态知识点"><a href="#补充多态知识点" class="headerlink" title="补充多态知识点:"></a><strong>补充多态知识点</strong>:</h6><pre><code class="scala">trait MyTrait01 &#123;&#125;
class A extends MyTrait01 &#123;&#125;
object B &#123;
  def test(m: MyTrait01): Unit = &#123;
    println(&quot;b ok..&quot;)
  &#125;
&#125;
//明确一个知识点
//当一个类继承了一个trait
//那么该类的实例，就可以传递给这个trait引用
val a01 = new A
B.test(a01)
</code></pre>
<h5 id="Scala数组与Java数组的互转"><a href="#Scala数组与Java数组的互转" class="headerlink" title="Scala数组与Java数组的互转"></a>Scala数组与Java数组的互转</h5><p>在项目开发中，有时我们需要将Java的List转成Scala数组，看下面案例：</p>
<pre><code class="scala"> import scala.collection.JavaConversions.asScalaBuffer
    import scala.collection.mutable
    //java的list转换成java的ArrayBuffer
    val scalaArr :mutable.Buffer[String] = arrList
    scalaArr.append(&quot;jack&quot;)
    scalaArr.append(&quot;tome&quot;)
    scalaArr.remove(0)
    scalaArr.set(0,&quot;100&quot;)
    println(scalaArr)
</code></pre>
<h4 id="元组Tuple"><a href="#元组Tuple" class="headerlink" title="元组Tuple"></a>元组Tuple</h4><p>元组也是可以理解为一个<strong>容器</strong>，可以存放各种相同或不同类型的数据。</p>
<p>说的简单点，就是将<strong>多个无关的数据封装为一个整体，称为元组, 最多的特点灵活,对数据没有过多的约束。</strong></p>
<h5 id="元组中最大只能有22个元素"><a href="#元组中最大只能有22个元素" class="headerlink" title="元组中最大只能有22个元素"></a>元组中最大只能有22个元素</h5><h5 id="元组的创建"><a href="#元组的创建" class="headerlink" title="元组的创建"></a>元组的创建</h5><pre><code class="scala">val tuple1 = (1, 2, 3, &quot;hello&quot;, 4)
println(tuple1)
//Tuple5
</code></pre>
<p>1)t1 的类型是 Tuple5类 是scala特有的类型</p>
<p>2)t1 的类型取决于 t1 后面有多少个元素, 有对应关系，比如 4个元素&#x3D;》Tuple4</p>
<p>3)给大家看一个Tuple5 类的定义,大家就了然了</p>
<pre><code class="scala">  /*
  final case class Tuple5[+T1, +T2, +T3, +T4, +T5](_1: T1, _2: T2, _3: T3, _4: T4, _5: T5)
 extends Product5[T1, T2, T3, T4, T5]
 &#123;
 override def toString() = &quot;(&quot; + _1 + &quot;,&quot; + _2 + &quot;,&quot; + _3 + &quot;,&quot; + _4 + &quot;,&quot; + _5 + &quot;)&quot;
  &#125;
   */
</code></pre>
<p>4)元组中最大只能有22个元素 即 Tuple1…Tuple22</p>
<h5 id="元组数据的访问"><a href="#元组数据的访问" class="headerlink" title="元组数据的访问"></a>元组数据的访问</h5><p>访问元组中的数据,可以采用<strong>顺序号（_顺序号</strong>），也可以通过<strong>索引（productElement）</strong>访问。</p>
<pre><code class="scala">val t1 = (1,2,3,&quot;5&quot;)
//访问第一个元素，从1开始
println(t1._2) //2
//访问第一个元素，从0开始
println(t1.productElement(0))//1
</code></pre>
<h5 id="遍历元组"><a href="#遍历元组" class="headerlink" title="遍历元组"></a>遍历元组</h5><p>遍历元组，元组的遍历需要迭代器</p>
<pre><code class="scala">    val t1 = (1,2,3,&quot;5&quot;)
    for (item &lt;- tuple1.productIterator) &#123;
      println(item)
    &#125;
</code></pre>
<h4 id="创建List"><a href="#创建List" class="headerlink" title="创建List"></a>创建List</h4><p>Scala中的List 和Java List 不一样，在Java中List是一个接口，真正存放数据是ArrayList，而<strong>Scala的List可以直接存放数据，就是一个object，默认情况下Scala的List是不可变的，List属于序列Seq。</strong><br>val List &#x3D; scala.collection.immutable.List<br>object List extends SeqFactory[List]</p>
<pre><code class="scala">    val list01 = List(1,2,3)
    println(list01)
    val list02 = Nil//空集合
    println(list02)
</code></pre>
<h5 id="List说明"><a href="#List说明" class="headerlink" title="List说明"></a>List说明</h5><p>1、List是scala.collection.immutable.List，既不可变</p>
<p>2、在scala中，List就是不可变的，<strong>要使用可变的List，使用ListBuffer</strong></p>
<p>3、List在package object scala做了val List &#x3D; scala.collection.immutable.List</p>
<p>4、val Nil &#x3D; scala.collection.immutable.Nil&#x2F;&#x2F;List()</p>
<h5 id="创建List的应用案例小结"><a href="#创建List的应用案例小结" class="headerlink" title="创建List的应用案例小结"></a>创建List的应用案例小结</h5><p>1）List默认为不可变的集合<br>2）List 在 scala包对象声明的,因此不需要引入其它包也可以使用<br>3）val List &#x3D; scala.collection.immutable.List<br>4）List 中可以放任何数据类型，比如 arr1的类型为 List[Any]<br>如果希望得到一个空列表，可以使用Nil对象, 在 scala包对象声明的,因此不需要引入其它包也可以使用val Nil &#x3D; scala.collection.immutable.Nil</p>
<h5 id="访问List元素"><a href="#访问List元素" class="headerlink" title="访问List元素"></a>访问List元素</h5><pre><code>val value1 = list1(1) // 1是索引，表示取出第2个元素.
println(value1)
</code></pre>
<h5 id="元素的追加"><a href="#元素的追加" class="headerlink" title="元素的追加"></a>元素的追加</h5><p>向列表中增加元素, <strong>会返回新的列表&#x2F;集合对象</strong>（没有破坏List不可变的特性）。注意：Scala中List元素的追加形式非常独特，和Java不一样。</p>
<p><strong>冒号那头是集合，加号那边是元素</strong></p>
<h6 id="在列表的最后面增加数据"><a href="#在列表的最后面增加数据" class="headerlink" title="在列表的最后面增加数据"></a>在列表的最后面增加数据</h6><pre><code class="scala">var list1 = List(1, 2, 3, &quot;abc&quot;)
val list2 = list1 :+ 4
// :+运算符表示在列表的最后增加数据
println(list1) //list1没有变化
println(list2) //新的列表结果是 [1, 2, 3, &quot;abc&quot;, 4]
</code></pre>
<h6 id="在列表的最前面增加数据"><a href="#在列表的最前面增加数据" class="headerlink" title="在列表的最前面增加数据"></a>在列表的最前面增加数据</h6><pre><code class="scala">var list1 = List(1, 2, 3, &quot;abc&quot;)
val list2 = 4 +: list1
// +:运算符表示在列表的最前面增加数据
println(list1) //list1没有变化
println(list2) //新的列表结果是 [4，1, 2, 3, &quot;abc&quot;]
</code></pre>
<h6 id="列表的最后增加数据"><a href="#列表的最后增加数据" class="headerlink" title="列表的最后增加数据"></a>列表的最后增加数据</h6><p>1、<strong>符号::表示向集合中  新建集合添加元素。</strong><br>2、运算时，集合对象一定要放置在最右边，<br>3、<strong>运算规则，从右向左。</strong><br>4、**::: 运算符是将集合中的每一个元素加入到空集合中去**</p>
<pre><code class="scala">val list05 = List(1, 2, 3, &quot;jojo&quot;)
val list06 = 4 :: 5 :: 6 :: list05 :: Nil
println(list06)
//输出List(4, 5, 6, List(1, 2, 3, jojo))
</code></pre>
<pre><code class="scala">val list05 = List(1, 2, 3, &quot;jojo&quot;)
val list06 = 4 :: 5 :: 6 :: list05 ::: Nil
println(list06)
//输出List(4, 5, 6, List(1, 2, 3, jojo))
</code></pre>
<h6 id="List追加练习题"><a href="#List追加练习题" class="headerlink" title="List追加练习题"></a>List追加练习题</h6><pre><code class="scala">val list1 = List(1, 2, 3, &quot;abc&quot;)
val list5 = 4 :: 5 :: 6 :: list1 
println(list5) // (4,5,6,1,2,3,&quot;abc&quot;)

val list1 = List(1, 2, 3, &quot;abc&quot;)
val list5 = 4 :: 5 :: 6 :: list1 :: 9
println(list5) //错误，最右边放集合

val list1 = List(1, 2, 3, &quot;abc&quot;)
val list5 = 4 :: 5 :: 6 ::: list1 ::: Nil
println(list5) // 错误 ::: 左右边为集合
//把6改成一个集合，或者改成&#39;::&#39;

val list1 = List(1, 2, 3, &quot;abc&quot;)
val list5 = 4 :: 5 :: list1 ::: list1 ::: Nil
println(list5) // (4,5,1,2,3,&quot;abc&quot;,1,2,3,&quot;abc&quot;)
</code></pre>
<h4 id="ListBuffer"><a href="#ListBuffer" class="headerlink" title="ListBuffer"></a>ListBuffer</h4><h5 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h5><p><strong>ListBuffer是可变的list集合</strong>，可以添加，删除元素,ListBuffer属于序列<br>&#x2F;&#x2F;追一下继承关系即可<br>Seq var listBuffer &#x3D; ListBuffer(1,2)</p>
<h5 id="应用实例："><a href="#应用实例：" class="headerlink" title="应用实例："></a>应用实例：</h5><pre><code class="scala">    //listbuffer可变的，在
    val listBuffer0 = ListBuffer[Int](1, 2, 3)
    println(listBuffer0(2))//3
    for (item &lt;- listBuffer0) &#123;
      println(item)//1,2,3
    &#125;

    //不赋值需要new一下进行初始化
    val listBuffer3 = new ListBuffer[Int]
    listBuffer3 += 4
    listBuffer3.append(5)
    println(listBuffer3)//4,5
    
    //右边集合元素添加到昨天集合，++一般是集合之间元素相加
    listBuffer0 ++= listBuffer3
    println(&quot;0=&quot;+listBuffer0)//listBuffer0(1,2,3,4,5)
    
    val list2 = listBuffer0 ++ listBuffer3
    println(list2)//list2(1,2,3,4,5,4,5)

    val list3 = listBuffer0:+5
    println(list3)//list3(1,2,3,4,5,5)

    println(&quot;删除&quot;)
    list3.remove(5)//删除下标为5的元素
    println(list3)
</code></pre>
<h5 id="ListBuffer的head和tail"><a href="#ListBuffer的head和tail" class="headerlink" title="ListBuffer的head和tail"></a>ListBuffer的head和tail</h5><p>head是第一个数据</p>
<p>tail是除了第一个之外的数据，是拼接起来的</p>
<h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h4><h5 id="队列的说明"><a href="#队列的说明" class="headerlink" title="队列的说明"></a>队列的说明</h5><p>1、队列是一个<strong>有序列表</strong>，在底层可以用<strong>数组</strong>或是<strong>链表</strong>来实现。<br>2、其输入和输出要遵循<strong>先入先出</strong>的原则。即：先存入队列的数据，要先取出。后存入的要后取出<br>3、在Scala中，由设计者直接给我们提供队列类型使用。<br>4、在scala中, 有 scala.collection.mutable.Queue 和 scala.collection.immutable.Queue , 一般来说，我们在开发中<strong>通常使用可变集合中的队列。</strong> </p>
<h5 id="应用案例："><a href="#应用案例：" class="headerlink" title="应用案例："></a>应用案例：</h5><pre><code class="scala">    import scala.collection.&#123;mutable&#125;
    val queue = new mutable.Queue[Int]()
    println(queue)//Queue()
    queue+=5
    println(queue)//Queue(5)
    queue ++= List(1,2,3)
    println(queue)//Queue(5,1,2,3)

    queue += List(1,2,3)//error,这样相当于添加list集合到队列中
</code></pre>
<h5 id="删除和加入队列元素"><a href="#删除和加入队列元素" class="headerlink" title="删除和加入队列元素"></a>删除和加入队列元素</h5><p>在队列中，严格遵守，入队列的数据放在队尾，出队列的数据是从头部取出</p>
<pre><code class="scala">  //删除队列元素，从前面拿
    import scala.collection.mutable.Queue
   //取出队列的第一个元素，queue会变化
    val queue2 = mutable.Queue[Int](1, 2, 3)
    val firstement = queue2.dequeue()
    println(firstement)//1
    println(queue)//Queue(2,3)
</code></pre>
<pre><code class="scala">    //加入队列元素，在后面增加
    import scala.collection.mutable.Queue
   //取出队列的第一个元素，queue会变化
    val queue2 = mutable.Queue[Int](1, 2, 3)
    queue.enqueue(5,10,15)
    println(queue)//Queue(1,2,3,5,10,15)
</code></pre>
<h5 id="返回队列的元素"><a href="#返回队列的元素" class="headerlink" title="返回队列的元素"></a>返回队列的元素</h5><pre><code class="scala">    //获取队列的最后一个元素
    println(queue.last)
    //获取队列的第一个元素
    println(queue.head)
    //取出队尾的数据，返回除了第一个以外剩余的元素，可以级联使用
    println(queue.tail)
    println(queue.tail.tail.tail)
</code></pre>
<h4 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射 Map"></a>映射 Map</h4><h5 id="Java中的Map回顾"><a href="#Java中的Map回顾" class="headerlink" title="Java中的Map回顾"></a>Java中的Map回顾</h5><p>HashMap 是一个<strong>散列表(数组+链表)<strong>，它存储的内容是</strong>键值对(key-value)映射</strong>，Java中的<strong>HashMap是无序的</strong>，key不能重复。</p>
<h5 id="Scala中的Map介绍"><a href="#Scala中的Map介绍" class="headerlink" title="Scala中的Map介绍"></a>Scala中的Map介绍</h5><p>Scala中的Map 和Java类似，也是一个散列表，它存储的内容也是键值对(key-value)映射，Scala中<strong>不可变的Map是有序的，可变的Map是无序的。</strong></p>
<p>Scala中，有可变Map (scala.collection.mutable.Map) 和 不可变Map(scala.collection.immutable.Map) </p>
<h5 id="构建Map"><a href="#构建Map" class="headerlink" title="构建Map"></a>构建Map</h5><pre><code class="scala">    //1、默认Map是immutable.Map
    //2、key-value 类型支持Any
    //3、在Map底层，每队key-value是Tuple2
    //4、不可变Map输出顺序和声明顺序一致
    //构建不可变Map
    val map = Map(&quot;Alice&quot; -&gt; 10, 2 -&gt; &quot;two&quot;)
    println(map)//Map(2 -&gt; two, Alice -&gt; 10)

    //构建可变的Map
    val map2 = mutable.Map(&quot;Alice&quot; -&gt; 10, 2 -&gt; &quot;two&quot;)
    println(map2)//Map(Alice -&gt; 10, 2 -&gt; two)


    //创建空的Map
    val nullmap = new mutable.HashMap[String,Int]()
    println(nullmap)//Map()

    //对偶元组方式创建
    val map3 = mutable.Map((&quot;2&quot;,2),(&quot;3&quot;-&gt;3))
    println(map3)//Map(2 -&gt; 2, 3 -&gt; 3)
</code></pre>
<h5 id="Map-取值"><a href="#Map-取值" class="headerlink" title="Map-取值"></a>Map-取值</h5><p>方式1-使用map(key)</p>
<p>如果key存在，则返回对应的值<br>如果key不存在，则抛出异常[java.util.NoSuchElementException]<br>在Java中,如果key不存在则返回null </p>
<pre><code class="scala">//方式1
val map = Map(&quot;Alice&quot; -&gt; 10, 2 -&gt; &quot;two&quot;)
println(map(&quot;Alice&quot;))//10

println(map(&quot;Alice&quot;))//java.util.NoSuchElementException
</code></pre>
<p>方式2-使用contains方法检查是否存在key </p>
<p>&#x2F;&#x2F; 返回Boolean<br>&#x2F;&#x2F; 1.如果key存在，则返回true<br>&#x2F;&#x2F; 2.如果key不存在，则返回false</p>
<pre><code class="scala">//方式2
val map = Map(&quot;Alice&quot; -&gt; 10, 2 -&gt; &quot;two&quot;)
if(map.contains(&quot;B&quot;))&#123;
println(map(&quot;B&quot;))
&#125;else&#123;
println(&quot;key不存在&quot;)
&#125;
</code></pre>
<p>方式3-使用map.get(key).get取值 </p>
<p>通过 映射.get(键) 这样的调用返回一个Option对象，<strong>要么是Some，要么是None</strong></p>
<p>map.get方法会将数据进行包装<br>如果 map.get(key) key存在返回some,如果key不存在，则返回None<br> 如果 map.get(key).get  key存在，返回key对应的值,否则，抛出异常 java.util.NoSuchElementException: None.get</p>
<pre><code class="scala">//方式三
val map = Map(&quot;Alice&quot; -&gt; 10, 2 -&gt; &quot;two&quot;)
println(map.get(&quot;Alice&quot;))//Some(10)
println(map.get(&quot;Alice~~~&quot;))//None
</code></pre>
<p>方式4-使用**map4.getOrElse()**取值 </p>
<p>如果key存在，返回key对应的值。<br>如果key不存在，返回默认值。在java中底层有很多类似的操作</p>
<pre><code class="scala">//方式四
val map = Map(&quot;Alice&quot; -&gt; 10, 2 -&gt; &quot;two&quot;)
println(map.getOrElse(&quot;Alice&quot;,&quot;默认&quot;))//10
println(map.getOrElse(&quot;Alice~~~&quot;,&quot;默认&quot;))//默认
</code></pre>
<h6 id="选择取值方式建议"><a href="#选择取值方式建议" class="headerlink" title="选择取值方式建议"></a>选择取值方式建议</h6><p>1、如果我们确定map有这个key ,则应当使用map(key), 速度快<br>2、如果我们不能确定map是否有key ,而且有不同的业务逻辑，使用map.contains() 先判断在加入逻辑<br>3、如果只是简单的希望得到一个值，使用map4.getOrElse(“ip”,”127.0.0.1”)</p>
<h5 id="对map修改、添加和删除"><a href="#对map修改、添加和删除" class="headerlink" title="对map修改、添加和删除"></a>对map修改、添加和删除</h5><p>map 是可变的，才能修改，否则报错<br>如果<strong>key存在</strong>：<strong>则修改</strong>对应的值,<strong>key不存在,等价于添加</strong>一个key-val</p>
<pre><code class="scala">    import scala.collection.mutable
    val map3 = mutable.Map((&quot;2&quot;,2),(&quot;3&quot;-&gt;3))
    println(map3)//Map(2 -&gt; 2, 3 -&gt; 3)
    map3(&quot;4&quot;) = 4
    println(map3)//Map(2 -&gt; 2, 4 -&gt; 4, 3 -&gt; 3)
    map3(&quot;4&quot;) = 20
    println(map3)//Map(2 -&gt; 2, 4 -&gt; 20, 3 -&gt; 3)
</code></pre>
<h5 id="添加map元素"><a href="#添加map元素" class="headerlink" title="添加map元素"></a>添加map元素</h5><h6 id="单个元素增加"><a href="#单个元素增加" class="headerlink" title="单个元素增加"></a>单个元素增加</h6><pre><code class="scala">val map4 = mutable.Map((&quot;A&quot;, 1), (&quot;B&quot;, &quot;北京&quot;), (&quot;C&quot;, 3))
map4 += ( &quot;D&quot; -&gt; 4 )
map4 += ( &quot;B&quot; -&gt; 50 ,&quot;E&quot;-&gt;&quot;e&quot;)//key如果已存在就是更新
println(map4)//Map(D -&gt; 4, A -&gt; 1, C -&gt; 3, E -&gt; e, B -&gt; 50)
</code></pre>
<h6 id="多个元素增加"><a href="#多个元素增加" class="headerlink" title="多个元素增加"></a>多个元素增加</h6><pre><code class="scala">val map4 = mutable.Map( (&quot;A&quot;, 1), (&quot;B&quot;, &quot;北京&quot;), (&quot;C&quot;, 3) )
val map5 = map4 + (&quot;E&quot;-&gt;1, &quot;F&quot;-&gt;3)
map4 += (&quot;EE&quot;-&gt;1, &quot;FF&quot;-&gt;3)  
</code></pre>
<h5 id="删除map元素"><a href="#删除map元素" class="headerlink" title="删除map元素"></a>删除map元素</h5><p>“A”,”B” 就是要删除的key, 可以写多个.<br><strong>如果key存在，就删除，如果key不存在，也不会报错.</strong></p>
<pre><code class="scala">   val map4 = mutable.Map( (&quot;A&quot;, 1), (&quot;B&quot;, &quot;北京&quot;), (&quot;C&quot;, 3) )
   map4 -= (&quot;A&quot;,&quot;B&quot;,&quot;asdfadf&quot;)//不能存在的key不会报错
   println(map4)//Map(c -&gt; 3)
     map5.remove(&quot;A&quot;)
</code></pre>
<h5 id="map遍历"><a href="#map遍历" class="headerlink" title="map遍历"></a>map遍历</h5><p>对map的元素(元组Tuple2对象 )进行遍历的方式很多，具体如下:</p>
<pre><code class="scala">val map5 = mutable.Map((&quot;A&quot;, 1), (&quot;B&quot;, &quot;北京&quot;), (&quot;C&quot;, 3))
for ((k, v) &lt;- map5) println(k + &quot; is mapped to &quot; + v)
//A is mapped to 1
//C is mapped to 3
//B is mapped to 北京
</code></pre>
<pre><code class="scala">for (k &lt;- map5.keys) println(v
//A
//C
//B
</code></pre>
<pre><code class="scala">for (v &lt;- map5.values) println(v)
//1
//3
//北京
</code></pre>
<pre><code class="scala">//v是Tuple2类型
for(v &lt;- map5) println(v)
//(A,1)
//(C,3)
//(B,北京)
v._1
v._2
</code></pre>
<h4 id="Set-集"><a href="#Set-集" class="headerlink" title="Set 集"></a>Set 集</h4><p>集是不重复元素的结合。集不保留顺序，默认是以哈希集实现</p>
<h5 id="Java中的Set回顾"><a href="#Java中的Set回顾" class="headerlink" title="Java中的Set回顾"></a>Java中的Set回顾</h5><p>java中，HashSet是实现Set<E>接口的一个实体类，数据是以哈希表的形式存放的，里面的不能包含重复数据。Set接口是一种不包含重复元素的 collection，HashSet中的数据也是没有顺序的。 </E></p>
<pre><code class="java">HashSet hs = new HashSet&lt;String&gt;();
hs.add(&quot;jack&quot;);
hs.add(&quot;tom&quot;);
hs.add(&quot;jack&quot;);
hs.add(&quot;jack2&quot;);
System.out.println(hs);
</code></pre>
<h5 id="Scala中Set的说明"><a href="#Scala中Set的说明" class="headerlink" title="Scala中Set的说明"></a>Scala中Set的说明</h5><p>默认情况下，Scala 使用的是不可变集合，如果你想使用可变集合，需要引用 scala.collection.mutable.Set 包</p>
<pre><code class="scala">    //不可变集合
    val set1 = Set(1,2,3)
    println(set1)
    //可变集合
    val set2 = scala.collection.mutable.Set(1,2,3)
    set2+=(3)
    println(set2)
</code></pre>
<h5 id="Set可变集合的元素添加"><a href="#Set可变集合的元素添加" class="headerlink" title="Set可变集合的元素添加"></a>Set可变集合的元素添加</h5><p>如果添加的对象已经存在，则不会重复添加，也不会报错</p>
<pre><code class="scala">val set2 = scala.collection.mutable.Set(1,2,3)
set2+=(3)
set2.add(4)
set2 += 0
</code></pre>
<h5 id="Set可变集合的元素删除"><a href="#Set可变集合的元素删除" class="headerlink" title="Set可变集合的元素删除"></a>Set可变集合的元素删除</h5><p>如果删除的对象不存在，则不生效，也不会报错</p>
<pre><code class="scala">val set02 = mutable.Set(1,2,4,&quot;abc&quot;)
set02 -= 2 // 操作符形式
set02.remove(&quot;abc&quot;) // 方法的形式，scala的Set可以直接删除值
println(set02)//Set(1, 4)
</code></pre>
<h3 id="数据结构-下-集合操作"><a href="#数据结构-下-集合操作" class="headerlink" title="数据结构(下)-集合操作"></a>数据结构(下)-集合操作</h3><h4 id="实际需求"><a href="#实际需求" class="headerlink" title="实际需求"></a>实际需求</h4><p>请将List(3,5,7) 中的所有元素都 * 2 ，将其结果放到一个新的集合中返回，即返回一个新的List(6,10,14), 请编写程序实现</p>
<h5 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h5><p>没有体现函数式编程特点（集合，函数）</p>
<p>不够高效，简介</p>
<pre><code class="scala">val list1 = List(3, 5, 7)
var list2 = List[Int]()
for (item &lt;- list1) &#123; //遍历
list2 = list2 :+ item * 2
&#125;
println(list2)
</code></pre>
<h5 id="map映射操作"><a href="#map映射操作" class="headerlink" title="map映射操作"></a>map映射操作</h5><p>上面提出的问题，其实就是一个关于<strong>集合元素映射操作</strong>的问题。<br>在Scala中可以通过map映射操作来解决：<strong>将集合中的每一个元素通过指定功能（函数）映射（转换）成新的结果集合</strong>这里其实就是所谓的<strong>将函数作为参数传递给另外一个函数,这是函数式编程的特点</strong></p>
<p>就是传入函数，在map方法中遍历集合元素，执行传入方法，返回新的集合</p>
<pre><code class="scala">def map[B](f: (A) ⇒ B): HashSet[B]
//map函数的签名
//这个就是map映射函数集合类型都有
//[B] 是泛型
//map 是一个高阶函数(可以接受一个函数的函数，就是高阶函数)，可以接收 函数 f: (A) =&gt; B 后面详解(先简单介绍下.)
//HashSet[B] 就是返回的新的集合

val list1 = List(3, 5, 7)
def f1(n1: Int): Int = &#123;
2 * n1
&#125;
val list2 = list1.map(f1)
println(list2)
//map方法是系统给定的
//这里将map遍历，将参数放入到f1方法中，将返回的结果装入到一个新的Map并返回
</code></pre>
<h4 id="高阶函数的使用"><a href="#高阶函数的使用" class="headerlink" title="高阶函数的使用"></a>高阶函数的使用</h4><p>就是把函数名称当成形参传入方法执行</p>
<pre><code class="scala">object TestHighOrderDef &#123;
  def main(args: Array[String]): Unit = &#123;
    val res = test(sum, 6.0)
    println(&quot;res=&quot; + res)
  &#125;
    //输入Double和输出Double的函数
  def test(f: Double =&gt; Double, n1: Double) = &#123;
    f(n1)
  &#125;
  def sum(d: Double): Double = &#123;
    d + d
  &#125;&#125;
</code></pre>
<pre><code class="scala">def main(args: Array[String]): Unit = &#123;
test2(sayOK)&#125;
def test2(f: () =&gt; Unit) = &#123;
f()&#125;
def sayOK() = &#123;
println(&quot;sayOKKK...&quot;)&#125;
</code></pre>
<h4 id="map映射函数的机制-模拟实现"><a href="#map映射函数的机制-模拟实现" class="headerlink" title="map映射函数的机制-模拟实现"></a>map映射函数的机制-模拟实现</h4><pre><code class="scala">object MapOperatDemo02 &#123;
  def main(args: Array[String]): Unit = &#123;
    val list = List(3,5,7,9)
    val list2 = list.map(multiple)
    println(list2)

    val myList = MyList()
    println(myList)
    val myList2 = myList.map(multiple)
    println(myList2)
  &#125;
  def multiple(n:Int):Int=&#123;
    println(&quot;diaoyong&quot;)
    n*2
  &#125;
&#125;

class MyList &#123;
  val list1 = List(3,5,7,9)
  var list2 = List[Int]()

  def map(f:Int =&gt;Int): List[Int] =&#123;
    for(item &lt;- this.list1)&#123;
       list2 = list2 :+ f(item)
    &#125;
    list2
  &#125;
&#125;
object MyList&#123;
  def apply(): MyList = new MyList()
&#125;
</code></pre>
<h4 id="集合元素的过滤-filter"><a href="#集合元素的过滤-filter" class="headerlink" title="集合元素的过滤-filter"></a>集合元素的过滤-filter</h4><p>filter：将符合要求的数据(筛选)放置到新的集合中</p>
<p><strong>传入的方法要返回一个boolean类型的</strong></p>
<h5 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h5><p>集合中首字母为’A’的筛选到新的集合</p>
<pre><code class="scala">object FilterDemo01 &#123;
  def main(args: Array[String]): Unit = &#123;
    val names = List(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Nick&quot;)
    //传入一个string返回boolean
    val names2 = names.filter(statA)
    println(&quot;names=&quot;+names)
    println(&quot;names=&quot;+names2)
  &#125;
    //！！必须是boolean返回值类型的
  def statA(s: String): Boolean = &#123;
    s.startsWith(&quot;A&quot;)
  &#125;
&#125;
//names=List(Alice, Bob, Nick)
//names=List(Alice)
</code></pre>
<h4 id="flat扁平化映射"><a href="#flat扁平化映射" class="headerlink" title="flat扁平化映射"></a>flat扁平化映射</h4><p>flatmap：flat即压扁，压平，扁平化，效果就是<strong>将集合中的每个元素的子元素映射到某个函数并返回新的集合</strong>。</p>
<h5 id="应用案例-1"><a href="#应用案例-1" class="headerlink" title="应用案例"></a>应用案例</h5><pre><code class="scala">val names = List(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Nick&quot;)
def upper( s : String ) : String = &#123;
    s. toUpperCase
&#125;
//就是先.Map 然后flatten  扁平化
println(names.flatMap(upper)) 
//List(A, L, I, C, E, B, O, B, N, I, C, K)
</code></pre>
<h4 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h4><h5 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>化简：<strong>将二元函数引用于集合中的函数。</strong></p>
<p><strong>二元函数</strong>：方法入参是两个参数</p>
<h5 id="reduceLeft-机制说明"><a href="#reduceLeft-机制说明" class="headerlink" title="reduceLeft()机制说明"></a>reduceLeft()机制说明</h5><p>def reduceLeft<a href="@deprecatedName('f">B &gt;: A</a> op: (B, A) &#x3D;&gt; B): B<br>reduceLeft(f) 接收的函数需要的形式为 op: (B, A) &#x3D;&gt; B): B<br>reduceleft(f) 的运行规则是 <strong>从左边开始执行将得到的结果返回给第一个参数</strong><br> 然后继续和下一个元素运行，将得到的结果继续返回给第一个参数，继续..<br>即: &#x2F;&#x2F;((((1 + 2)  + 3) + 4) + 5) &#x3D; 15</p>
<h5 id="应用案例-2"><a href="#应用案例-2" class="headerlink" title="应用案例"></a>应用案例</h5><pre><code class="scala">object ReduceDemo01 &#123;
  def main(args: Array[String]): Unit = &#123;
    val list = List(1,20,30,4,5)
    //接受一个函数时，可以直接传入一个匿名函数
    val i = list.reduceLeft(sum)
    //执行流程分析
    //1、sum(1,20)  21
    //2、sum(21+30) 51
    //3、sum(51+4)  55
    //4、sum(55+5)  60
    println(i)
  &#125;
  def sum(n1:Int,n2:Int): Int =&#123;
    println(n1+n2)
    n1+n2
  &#125;
&#125;
</code></pre>
<h6 id="执行逻辑图"><a href="#执行逻辑图" class="headerlink" title="执行逻辑图"></a>执行逻辑图</h6><p><img src="/scala/scala/image-20200229135700804.png" alt="image-20200229135700804"></p>
<p><strong>说明: .reduceRight(_ - _)反之同理</strong></p>
<h5 id="化简练习题"><a href="#化简练习题" class="headerlink" title="化简练习题"></a>化简练习题</h5><p>1)<strong>分析下面的代码输出什么结果</strong></p>
<pre><code class="scala">val list = List(1, 2, 3, 4 ,5)
    def minus( num1 : Int, num2 : Int ): Int = &#123;
      num1 - num2
    &#125;
println(list.reduceLeft(minus)) // 输出-13
println(list.reduceRight(minus)) //输出3
//1-(2-(3-(4-5)))
println(list.reduce(minus)) //调用的是reduceLeft
</code></pre>
<p>2)<strong>使用化简的方法求出</strong> List(3,4,2,7,5) 最小的值</p>
<pre><code class="scala">object aaa &#123;
  def main(args: Array[String]): Unit = &#123;
    val list = List(1,2,3,4,5)
    val i = list.reduce(minfunction)
    println(i)
  &#125;

  def minfunction(n1: Int, n2: Int): Int = &#123;
    if (n1 &gt;= n2) n2 else n1
  &#125;
&#125;
</code></pre>
<h4 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h4><h5 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h5><p><strong>fold函数将上一步返回的值作为函数的第一个参数继续传递参与运算，直到list中的所有元素被遍历。</strong></p>
<p><strong>可以把reduceLeft看做简化版的foldLeft。</strong></p>
<p>如何理解:def reduceLeft<a href="@deprecatedName('f">B &gt;: A</a> op: (B, A) &#x3D;&gt; B): B &#x3D; if (isEmpty) throw new UnsupportedOperationException(“empty.reduceLeft”)  else tail.foldLeft<a href="head">B</a>(op)</p>
<p>大家可以看到. reduceLeft就是调用的foldLeft<a href="head">B</a>，并且是默认从集合的head元素开始操作的。<br>相关函数：fold，foldLeft，foldRight，可以参考reduce的相关方法理解</p>
<h5 id="foldLeft和foldRight-缩写方法"><a href="#foldLeft和foldRight-缩写方法" class="headerlink" title="foldLeft和foldRight 缩写方法"></a>foldLeft和foldRight 缩写方法</h5><p>分别是：&#x2F;:和:\</p>
<pre><code class="scala">val list4 = List(1, 9, 2, 8)
def minus(num1: Int, num2: Int): Int = &#123;
num1 - num2
&#125;
    var i6 = (1 /: list4) (minus) // =等价=&gt; list4.foldLeft(1)(minus)
    println(i6) // 输出?-19
    i6 = (100 /: list4) (minus)
    println(i6) // 输出?80
    i6 = (list4 :\ 10) (minus) // list4.foldRight(10)(minus)
    println(i6) // 输出?-4
</code></pre>
<h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><pre><code class="scala">// 折叠
val list = List(1, 2, 3, 4)
def minus( num1 : Int, num2 : Int ): Int = &#123;
num1 - num2
&#125;
//理解为(5,1,2,3,4)  
//5-1	=4
//(5-1)-2	=2
//((5-1)-2)-3	=-1
//(((5-1)-2)-3)-4	=5
println(list.foldLeft(5)(minus)) // 函数的柯里化
//理解为(1,2,3,4,5)
//4-5	=-1
//3-(4-5)	=4
//2-(3-(4-5))	=-2
//1-(2-(3-(4-5)))-4		=3
println(list.foldRight(5)(minus)) //
</code></pre>
<pre><code class="scala">object Exercise02 &#123;
  def main(args: Array[String]): Unit = &#123;
    val sentence = &quot;AAAAAAAAAABBBBBBBBCCCCCDDDDDDD&quot;
    val arr = ArrayBuffer[Char]()
    sentence.foldLeft(arr)(putArray)
    println(arr)
  &#125;

  def putArray(arr:ArrayBuffer[Char],c:Char): ArrayBuffer[Char] =&#123;
    arr += c
    arr
  &#125;
&#125;
//ArrayBuffer(A, A, A, A, A, A, A, A, A, A, B, B, B, B, B, B, B, B, C, C, C, C, C, D, D, D, D, D, D, D)
</code></pre>
<h4 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h4><h5 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>扫描，即对某个集合的所有元素做fold操作，但是<strong>会把产生的所有中间结果放置于一个集合中保存</strong>，这是和折叠的不同点</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><pre><code class="scala">object ScanDemo01 &#123;
  def main(args: Array[String]): Unit = &#123;
    def minus(num1: Int, num2: Int): Int = &#123;
      num1 - num2
    &#125;

    //5 (1,2,3,4,5) =&gt;(5,4,2,-1,-5,-10)
    val i8 = (1 to 5).scanLeft(5)(minus) //IndexedSeq[Int]
    println(i8)

    def add(num1: Int, num2: Int): Int = &#123;
      num1 + num2
    &#125;

    //5 (1,2,3,4,5) 5=&gt;(20,19,17,14,10,5)
    val i9 = (1 to 5).scanRight(5)(add) //IndexedSeq[Int]
    println(i9)
  &#125;

&#125;
</code></pre>
<h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><p>1、将sentence 中各个字符，通过foldLeft存放到 一个ArrayBuffer中</p>
<pre><code class="scala">object Exercise02 &#123;
  def main(args: Array[String]): Unit = &#123;
    val sentence = &quot;AAAAAAAAAABBBBBBBBCCCCCDDDDDDD&quot;
    val arr = ArrayBuffer[Char]()
    sentence.foldLeft(arr)(putArray)
    println(arr)
  &#125;
  //arr传入第一个参数，
  def putArray(arr:ArrayBuffer[Char],c:Char): ArrayBuffer[Char] =&#123;
    arr += c
    arr
  &#125;
&#125;
</code></pre>
<p>2、使用映射集合，统计一句话中，各个字母出现的次数<br>提示：Map<a href>Char, Int</a></p>
<pre><code class="scala">object Exercise03 &#123;
  def main(args: Array[String]): Unit = &#123;

  &#125;
  val sentence = &quot;AAAAAAAAAABBBBBBBBCCCCCDDDDDDD&quot;
  //可变map
  def charCount(m: mutable.Map[Char, Int], c: Char): mutable.Map[Char, Int] = &#123;
    //可变的map每次返回都是它本身
    //k -&gt; v
    m += (c -&gt; (m.getOrElse(c, 0) + 1))
  &#125;

  //不可变map
  def charCount2(m: Map[Char, Int], c: Char): Map[Char, Int] = &#123;
    //每次返回都是新的map
    m + (c -&gt; (m.getOrElse(c, 0) + 1))
  &#125;
  //可变map无序的
  println((mutable.Map[Char, Int]() /: sentence)(charCount))
  //不可变map是有序的
  println((Map[Char, Int]() /: sentence)(charCount2))
&#125;
</code></pre>
<h4 id="拉链-合并"><a href="#拉链-合并" class="headerlink" title="拉链(合并)"></a>拉链(合并)</h4><h5 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>在开发中，当我们需要将两个集合进行 <strong>对偶元组合并</strong>，可以使用拉链。</p>
<h5 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h5><pre><code class="scala">// 拉链
val list1 = List(1, 2 ,3)
val list2 = List(4, 5, 6)
val list3 = list1.zip(list2) 
// (1,4),(2,5),(3,6) 
println(&quot;list3=&quot; + list3)
</code></pre>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>拉链的本质就是两个集合的合并操作，合并后每个元素是一个 <strong>对偶元组</strong>。<br>操作的规则下图:</p>
<p><img src="/scala/scala/image-20200301133513917.png" alt="image-20200301133513917"></p>
<p>如果<strong>两个集合个数不对应，会造成数据丢失</strong>。<br>集合不限于List, 也可以是其它集合比如 Array<br>如果要取出合并后的各个对偶元组的数据，可以遍历</p>
<pre><code class="scala">for(item&lt;-list3)&#123;
 print(item._1 + &quot; &quot; + item._2) //取出时，按照元组的方式取出即可   
&#125;
</code></pre>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><h5 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h5><p>通过iterator方法从集合获得一个迭代器，通过while循环和for表达式对集合进行遍历.(学习使用迭代器来遍历)</p>
<h5 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h5><pre><code class="scala">val iterator = List(1, 2, 3, 4, 5).iterator // 得到迭代器
    println(&quot;--------遍历方式1 -----------------&quot;)
    while (iterator.hasNext) &#123;
        println(iterator.next())
    &#125;
    println(&quot;--------遍历方式2 for -----------------&quot;)
//for循环  iterator必须是没有遍历过的，iterator跟一个指针一样
    for(enum &lt;- iterator) &#123;
      println(enum) //
    &#125;
</code></pre>
<h5 id="应用案例小结"><a href="#应用案例小结" class="headerlink" title="应用案例小结"></a>应用案例小结</h5><ol>
<li>iterator 的构建实际是 AbstractIterator 的一个匿名子类，该子类提供了</li>
</ol>
<pre><code class="scala">    /*
     def iterator: Iterator[A] = new AbstractIterator[A] &#123;
    var these = self
    def hasNext: Boolean = !these.isEmpty
    def next(): A =
    */
</code></pre>
<p>2）该AbstractIterator 子类提供了  hasNext next 等方法.<br>3）因此，我们可以使用 while的方式，使用hasNext next 方法变量</p>
<h4 id="流-Stream"><a href="#流-Stream" class="headerlink" title="流 Stream"></a>流 Stream</h4><h5 id="基本说明-1"><a href="#基本说明-1" class="headerlink" title="基本说明"></a>基本说明</h5><p><strong>stream是一个集合</strong>。这个集合，可以<strong>用于存放无穷多个元素</strong>，但是这无穷个元素并不会一次性生产出来，而是需要用到多大的区间，就会动态的生产，<strong>末尾元素遵循lazy规则(即：要使用结果才进行计算的) 。</strong></p>
<h5 id="创建Stream对象"><a href="#创建Stream对象" class="headerlink" title="创建Stream对象"></a>创建Stream对象</h5><pre><code class="scala">def numsForm(n: BigInt) : Stream[BigInt] = n #:: numsForm(n + 1)
val stream1 = numsForm(1)
</code></pre>
<h6 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h6><p>1、Stream 集合存放的数据类型是BigInt<br>2、numsForm 是自定义的一个函数，函数名是程序员指定的。<br>3、创建的集合的第一个元素是 n , 后续元素生成的规则是 n + 1<br>4、后续元素生成的规则是可以程序员指定的 ，比如 numsForm( n * 4)…</p>
<pre><code class="scala">//创建Stream
def numsForm(n: BigInt) : Stream[BigInt] = n #:: numsForm(n + 1)
val stream1 = numsForm(1)
println(stream1) //Stream(1, ?)
//取出第一个元素
println(&quot;head=&quot; + stream1.head) //head=1
println(stream1.tail) //Stream(2, ?)
println(stream1) //Stream(1, 2, ?)
</code></pre>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h5><p>如果使用流集合，就不能使用last属性，如果使用last集合就会进行无限循环</p>
<h4 id="视图-View"><a href="#视图-View" class="headerlink" title="视图 View"></a>视图 View</h4><h5 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h5><p><strong>Stream的懒加载特性，也可以对其他集合应用view方法</strong>来得到类似的效果，具有如下特点：<br>1）view方法产出一个总是被懒执行的集合。<br>2）view不会缓存数据，每次都要重新计算，比如遍历View时。</p>
<h5 id="应用案例-3"><a href="#应用案例-3" class="headerlink" title="应用案例"></a>应用案例</h5><p>请找到1-100 中，数字倒序排列 和它本身相同的所有数。(1 2, 11, 22, 33 …)</p>
<pre><code class="scala">def eq(i: Int): Boolean = &#123;
i.toString.equals(i.toString.reverse)
&#125;
//说明: 没有使用view
val viewSquares1 = (1 to 100)
.filter(eq)
println(viewSquares1)//Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99)
//for (x &lt;- viewSquares1) &#123;&#125;
//使用view
val viewSquares2 = (1 to 100)
.view
.filter(eq)
println(viewSquares2)//SeqViewF(...)
</code></pre>
<h4 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h4><h5 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>所有线程安全的集合都是以Synchronized开头的集合，不可变集合也是线程安全的，但是不方便</p>
<p>SynchronizedBuffer<br>SynchronizedMap<br>SynchronizedPriorityQueue<br>SynchronizedQueue<br>SynchronizedSet<br>SynchronizedStack</p>
<h4 id="并行集合"><a href="#并行集合" class="headerlink" title="并行集合"></a>并行集合</h4><h5 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>1）Scala为了充分使用多核CPU，提供了并行集合（有别于前面的串行集合），用于多核环境的并行计算。<br>2）主要用到的算法有： <strong>Divide and conquer : 分治算法</strong>，Scala通过splitters(分解器)，combiners（组合器）等抽象层来实现，主要原理是将计算工作分解很多任务，分发给一些处理器去完成，并将它们处理结果合并返回</p>
<p>Work stealin算法【学数学】，主要用于任务调度负载均衡（load-balancing），通俗点完成自己的所有任务之后，发现其他人还有活没干完，主动（或被安排）帮他人一起干，这样达到尽早干完的目的</p>
<p><strong>.par</strong></p>
<h5 id="应用案例-4"><a href="#应用案例-4" class="headerlink" title="应用案例"></a>应用案例</h5><p>1）打印1~5</p>
<pre><code class="scala">(1 to 5).foreach(println(_))//12345
println()
(1 to 5).par.foreach(println(_))//34152
</code></pre>
<p>2）查看并行集合中元素访问的线程</p>
<pre><code class="scala">object ParDemo02 &#123;
  def main(args: Array[String]): Unit = &#123;
    //获取线程名称，并distinct去重
    val result1 = (0 to 100).map&#123;case _ =&gt; Thread.currentThread().getName&#125;.distinct
    val result2 = (0 to 100).par.map&#123;case _ =&gt; Thread.currentThread().getName&#125;.distinct
    println(result1)//Vector(main)
    println(&quot;___________________________________________&quot;)
    println(result2)//ParVector(ForkJoinPool-1-worker-13, ForkJoinPool-1-worker-15,.....)
  &#125;
&#125;
</code></pre>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><h5 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>这部分内容没有必要刻意去理解和记忆，语法使用的多了，自然就会熟练的使用，该部分内容了解一下即可。</p>
<h5 id="操作符扩展"><a href="#操作符扩展" class="headerlink" title="操作符扩展"></a>操作符扩展</h5><p>1）如果想在变量名、类名等定义中使用语法关键字（保留字），可以配合反引号反引号 val <code>val</code> &#x3D; 42<br>2）中置操作符：A 操作符 B 等同于 A.操作符(B)  </p>
<p>3）后置操作符：A操作符 等同于 A.操作符，如果操作符定义的时候不带()则调用时不能加括号 </p>
<pre><code class="scala">class Operate &#123;
  //定义函数/方法的时候，省略的()
  def ++ = &quot;123&quot; 
&#125;
// 操作符
val oper = new Operate
println(oper++)
println(oper.++)
</code></pre>
<p>4）前置操作符，+、-、！、~等操作符A等同于**A.unary_**操作符 </p>
<pre><code class="scala">class Operate &#123;
  // 声明前置运算符
  //unary ：一元运算符
  def unary_! = println(&quot;!!!!!!!&quot;)
&#125;

// 操作符
val oper = new Operate
!oper //前置运算符
</code></pre>
<p>5）赋值操作符，A 操作符&#x3D; B 等同于 A &#x3D; A 操作符 B  ，比如 A +&#x3D; B 等价 A &#x3D; A + B</p>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>match</p>
<h5 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>Scala中的模式匹配类似于Java中的switch语法，但是更加强大。</p>
<p>模式匹配语法中，采用<strong>match</strong>关键字声明，每个分支采用<strong>case</strong>关键字进行声明，当需要匹配时，会从第一个case分支开始，如果 匹配成功，那么执行对应的逻辑代码，如果匹配不成功，继续执行下一个分支进行判断。如果所有case都不匹配，那么会执行case _ 分支，类似于Java中default语句。</p>
<h5 id="应用案例-5"><a href="#应用案例-5" class="headerlink" title="应用案例"></a>应用案例</h5><pre><code class="scala">val oper = &#39;#&#39;
val n1 = 20
val n2 = 10
var res = 0
oper match &#123;
case &#39;+&#39; =&gt; res = n1 + n2
case &#39;-&#39; =&gt; res = n1 - n2
case &#39;*&#39; =&gt; res = n1 * n2
case &#39;/&#39; =&gt; res = n1 / n2
case _ =&gt; println(&quot;oper error&quot;)
&#125;
println(&quot;res=&quot; + res)//0
</code></pre>
<h5 id="match的细节和注意事项"><a href="#match的细节和注意事项" class="headerlink" title="match的细节和注意事项"></a>match的细节和注意事项</h5><p>1）如果所有case都不匹配，那么会执行case _ 分支，类似于Java中default语句<br>2）如果所有case都不匹配，又没有写case _ 分支，那么会抛出<strong>MatchError</strong><br>3）<strong>每个case中，不用break语句，自动中断case</strong><br>4）可以在match中使用其它类型，而不仅仅是字符</p>
<p>5）&#x3D;&gt; 等价于 java swtich 的 :<br>6）&#x3D;&gt; 后面的代码块到下一个 case， 是作为一个整体执行，可以使用{} 扩起来，也可以不扩。 </p>
<h5 id="模式匹配守卫"><a href="#模式匹配守卫" class="headerlink" title="模式匹配守卫"></a>模式匹配守卫</h5><h6 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a>基本介绍</h6><p>如果想要<strong>表达匹配某个范围的数据</strong>，就需要在模式匹配中增加条件守卫</p>
<h6 id="应用案例-6"><a href="#应用案例-6" class="headerlink" title="应用案例"></a>应用案例</h6><pre><code class="scala">for (ch &lt;- &quot;+-3!&quot;) &#123;
var sign = 0
var digit = 0
ch match &#123;
case &#39;+&#39; =&gt; sign = 1
case &#39;-&#39; =&gt; sign = -1
// 说明..
case _ if ch.toString.equals(&quot;3&quot;) =&gt; digit = 3
case _ =&gt; sign = 2
&#125;
println(ch + &quot; &quot; + sign + &quot; &quot; + digit)
&#125;
//+ 1 0
//- -1 0
//3 0 3
//! 2 0
</code></pre>
<pre><code class="scala">  def main(args: Array[String]): Unit = &#123;
    for (ch &lt;- &quot;+-3!&quot;) &#123;
      var sign = 0
      var digit = 0
      ch match &#123;
        case &#39;+&#39; =&gt; sign = 1
        case &#39;-&#39; =&gt; sign = -1
        // 说明..
        case _ if ch.toString.equals(&quot;3&quot;) =&gt; digit = 3
        //可以有多个默认匹配，但是后面的匹配值无效
          //！！如果把这个写在前面，则一直匹配这个，其他的匹配不到
        case _ =&gt; digit = 3
        case _ =&gt; sign = 2
      &#125;
      println(ch + &quot; &quot; + sign + &quot; &quot; + digit)
    &#125;
  &#125;
</code></pre>
<h5 id="模式中的变量"><a href="#模式中的变量" class="headerlink" title="模式中的变量"></a>模式中的变量</h5><h6 id="基本介绍-13"><a href="#基本介绍-13" class="headerlink" title="基本介绍"></a>基本介绍</h6><p>如果在case关键字后跟变量名，那么match前表达式的值会赋给那个变量</p>
<h6 id="应用案例-7"><a href="#应用案例-7" class="headerlink" title="应用案例"></a>应用案例</h6><pre><code class="scala">val ch = &#39;V&#39;
ch match &#123;
case &#39;+&#39; =&gt; println(&quot;ok~&quot;)
//模式变量，无条件匹配
case mychar =&gt; println(&quot;ok~&quot; + mychar)
case _ =&gt; println (&quot;ok~~&quot;)
&#125;
</code></pre>
<pre><code class="scala">//还可以当作返回值，匹配到的case的最后一行就是返回值 
def main(args: Array[String]): Unit = &#123;
    val ch = &#39;V&#39;
    var ch1 = ch match &#123;
      case &#39;+&#39; =&gt; println(&quot;ok~&quot;)
      case aaa =&gt; ch+&quot;aaa&quot;
      case _ if ch &gt;50 =&gt;println(&quot;ch&gt;5&quot;)
      case _ =&gt; println(&quot;ok&quot;)
    &#125;
    println(ch1)
  &#125;
</code></pre>
<h5 id="类型匹配"><a href="#类型匹配" class="headerlink" title="类型匹配"></a>类型匹配</h5><h6 id="基本介绍-14"><a href="#基本介绍-14" class="headerlink" title="基本介绍"></a>基本介绍</h6><p>可以匹配对象的任意类型，这样做避免了使用isInstanceOf和asInstanceOf方法</p>
<h6 id="应用案例-8"><a href="#应用案例-8" class="headerlink" title="应用案例"></a>应用案例</h6><pre><code class="scala">// 类型匹配, obj 可能有如下的类型
val a = 7
val obj = if(a == 1) 1
else if(a == 2) &quot;2&quot;
else if(a == 3) BigInt(3)
else if(a == 4) Map(&quot;aa&quot; -&gt; 1)
else if(a == 5) Map(1 -&gt; &quot;aa&quot;)
else if(a == 6) Array(1, 2, 3)
else if(a == 7) Array(&quot;aa&quot;, 1)
else if(a == 8) Array(&quot;aa&quot;)

//在:后面匹配数据类型，不匹配就下一个
val result = obj match &#123;
case a : Int =&gt; a
case b : Map[String, Int] =&gt; &quot;对象是一个字符串-数字的Map集合&quot;
case c : Map[Int, String] =&gt; &quot;对象是一个数字-字符串的Map集合&quot;
case d : Array[String] =&gt; &quot;对象是一个字符串数组&quot;
case e : Array[Int] =&gt; &quot;对象是一个数字数组&quot;
case f : BigInt =&gt; Int.MaxValue
case _ =&gt; &quot;啥也不是&quot;
&#125;
println(result)
</code></pre>
<h6 id="类型匹配注意事项"><a href="#类型匹配注意事项" class="headerlink" title="类型匹配注意事项"></a>类型匹配注意事项</h6><p>1）<strong>Map[String, Int] 和Map[Int, String]是两种不同的类型，其它类推。</strong><br>2）在进行类型匹配时，编译器会预先检测是否有可能的匹配，如果没有则报错.</p>
<pre><code class="scala">val obj = 10
val result = obj match &#123;
case a : Int =&gt; a
case b : Map[String, Int] =&gt; &quot;Map集合&quot;
case _ =&gt; &quot;啥也不是&quot;
&#125;
</code></pre>
<p>3）一个说明:val result &#x3D; obj match { case i : Int &#x3D;&gt; i} <strong>case i : Int &#x3D;&gt; i 表示 将 i &#x3D; obj</strong> (其它类推)，然后再判断类型</p>
<p>4）如果 <strong>case _</strong> 出现在match 中间，则<strong>表示隐藏变量名</strong>，即不使用,而不是表示默认匹配。</p>
<pre><code class="scala">val obj = 10
val result = obj match &#123;
case a : Int =&gt; a
case _ : BigInt =&gt; Int.MaxValue
case b : Map[String, Int] =&gt; &quot;Map集合&quot;
case _ =&gt; &quot;啥也不是&quot;
&#125;
</code></pre>
<h5 id="匹配数组"><a href="#匹配数组" class="headerlink" title="匹配数组"></a>匹配数组</h5><h6 id="基本介绍-15"><a href="#基本介绍-15" class="headerlink" title="基本介绍"></a>基本介绍</h6><p><strong>Array(0)</strong> 匹配只有一个元素且为0的数组。<br><strong>Array(x,y)</strong> 匹配数组有两个元素，并将两个元素赋值为x和y。<strong>当然可以依次类推</strong>Array(x,y,z) 匹配数组有3个元素的等等….<br><strong>Array(0,_*)</strong> 匹配数组以0开始</p>
<h6 id="应用案例-9"><a href="#应用案例-9" class="headerlink" title="应用案例"></a>应用案例</h6><pre><code class="scala">for (arr &lt;- Array(Array(0), Array(1, 0), Array(0, 1, 0),
Array(1, 1, 0), Array(1, 1, 0, 1))) &#123;
val result = arr match &#123;
case Array(0) =&gt; &quot;0&quot;
case Array(x, y) =&gt; x + &quot;=&quot; + y
case Array(0, _*) =&gt; &quot;以0开头和数组&quot;
case _ =&gt; &quot;什么集合都不是&quot;
&#125;
println(&quot;result = &quot; + result)
&#125; 
</code></pre>
<h5 id="匹配列表"><a href="#匹配列表" class="headerlink" title="匹配列表"></a>匹配列表</h5><h6 id="应用案例-10"><a href="#应用案例-10" class="headerlink" title="应用案例"></a>应用案例</h6><pre><code class="scala">for (list &lt;- Array(List(0), List(1, 0), List(0, 0, 0), List(1, 0, 0))) &#123;
val result = list match &#123;
case 0 :: Nil =&gt; &quot;0&quot; //
case x :: y :: Nil =&gt; x + &quot; &quot; + y //
case 0 :: tail =&gt; &quot;0 ...&quot; //
case _ =&gt; &quot;something else&quot;
&#125;
println(result)
&#125;
</code></pre>
<p>&#x2F;&#x2F;请思考，如果要匹配 List(88) 这样的<strong>只含有一个元素的列表,并原值返回</strong>.应该怎么写?</p>
<p>Nil是空集合</p>
<pre><code class="scala">object MatchLIst &#123;
  def main(args: Array[String]): Unit = &#123;
    for (list &lt;- Array(List(0), List(1, 0), List(23),List(0, 0, 1), List(1, 0, 0))) &#123;
      val result = list match &#123;
        case 0 :: Nil =&gt; &quot;0&quot; //
        case x :: y :: Nil =&gt; x + &quot; &quot; + y 
        case 0 :: tail =&gt; &quot;0 ...&quot; //
        //返回原值
        case x :: Nil =&gt; x
        case _ =&gt; &quot;something else&quot;
      &#125;
  &#125;
</code></pre>
<h5 id="匹配元组"><a href="#匹配元组" class="headerlink" title="匹配元组"></a>匹配元组</h5><h6 id="应用案例-11"><a href="#应用案例-11" class="headerlink" title="应用案例"></a>应用案例</h6><pre><code class="scala">// 元组匹配
// 元组匹配
for (pair &lt;- Array((0, 1), (1, 0), (1, 1),(1,0,2))) &#123;
val result = pair match &#123; // 
case (0, _) =&gt; &quot;0 ...&quot; //
case (y, 0) =&gt; y // 
case _ =&gt; &quot;other&quot; //
&#125;
println(result)
&#125;
</code></pre>
<p>&#x2F;&#x2F;思考，如果要匹配 (10, 30) 这样任意两个元素的对偶元组，应该如何写?</p>
<pre><code class="scala">    for (pair &lt;- Array((0, 1), (1, 0),(10,30), (1, 1),(1,0,2))) &#123;
      val result = pair match &#123; //
        case (0, _) =&gt; &quot;0 ...&quot; //
        case (y, 0) =&gt; y //
        //任意的对偶元组
        case (x,y) =&gt; (y,x)
        case _ =&gt; &quot;other&quot; //.
      &#125;
</code></pre>
<h5 id="对象匹配"><a href="#对象匹配" class="headerlink" title="对象匹配"></a>对象匹配</h5><h6 id="基本介绍-16"><a href="#基本介绍-16" class="headerlink" title="基本介绍"></a>基本介绍</h6><p>对象匹配，什么才算是匹配呢？，规则如下:<br>case中对象的<strong>unapply</strong>方法(对象提取器**)返回Some集合则为匹配成功**<br><strong>返回none集合则为匹配失败</strong></p>
<h6 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h6><pre><code class="scala">//成功案例
object Square &#123;
  //unapply方法对象提取器
  //接受double类型
  //返回Option[Double]类型
  //返回的值是 Some(math.sqrt(z))
def unapply(z: Double): Option[Double] =&#123;
    println(&quot;被调用&quot;+z)
    Some(math.sqrt(z))
  &#125;
def apply(z: Double): Double = z * z
&#125;
// 模式匹配使用：
val number: Double = 36.0
number match &#123;
//调用unapply方法(z:Double)，z的值是number
//如果返回some(6)，则表示成功
case Square(n) =&gt; println(n)
case _ =&gt; println(&quot;nothing matched&quot;)
&#125;
//被调用36.0
//6.0
</code></pre>
<pre><code class="scala">//失败案例
object Square &#123;
  //unapply方法对象提取器
  //接受double类型
  //返回Option[Double]类型
  //返回的值是 Some(math.sqrt(z))
def unapply(z: Double): Option[Double] =&#123;
    println(&quot;被调用&quot;+z)
    None
  &#125;
def apply(z: Double): Double = z * z
&#125;
// 模式匹配使用：
val number: Double = 36.0
number match &#123;
//调用unapply方法(z:Double)，z的值是number
//如果返回some(6)，则表示成功
case Square(n) =&gt; println(n)
case _ =&gt; println(&quot;nothing matched&quot;)
&#125;
//被调用36.0
//nothing matched
</code></pre>
<h6 id="应用案例1的小结"><a href="#应用案例1的小结" class="headerlink" title="应用案例1的小结"></a>应用案例1的小结</h6><p>构建对象时apply会被调用 ，比如 val n1 &#x3D; Square(5)<br>当将 Square(n) 写在 case 后时[case Square(n) &#x3D;&gt; xxx]，会默认调用<strong>unapply 方法(对象提取器)</strong><br> number 会被 传递给def unapply(z: Double) 的 z 形参<br> 如果返回的是Some集合，则unapply提取器返回的结果会返回给 n 这个形参<br><strong>case中对象的unapply方法(提取器)返回some集合则为匹配成功</strong><br><strong>返回none集合则为匹配失败</strong></p>
<h6 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h6><pre><code class="scala">object MatchTupleDemo02 &#123;
  def main(args: Array[String]): Unit = &#123;
    val namesString = &quot;Alice,Bob,Thomas&quot;
    //说明
    namesString match &#123;
      //调用unapplySeq(str)把namesString传给str
      //返回多个值，如果返回的个数匹配(first, second, third)
      //则成功，如果返回None，表示匹配失败了
      case Names(first, second, third) =&gt; &#123;
        println(&quot;the string contains three people&#39;s names&quot;)
        // 打印字符串
        println(s&quot;$first $second $third&quot;)
      &#125;
      case _ =&gt; println(&quot;nothing matched&quot;)
    &#125;
  &#125;
&#125;

object Names &#123;
  def unapplySeq(str: String): Option[Seq[String]] = &#123;
    if (str.contains(&quot;,&quot;)) Some(str.split(&quot;,&quot;))
    else None
  &#125;
&#125;
</code></pre>
<h6 id="应用案例2的小结"><a href="#应用案例2的小结" class="headerlink" title="应用案例2的小结"></a>应用案例2的小结</h6><p>当case 后面的对象提取器方法的参数为多个，则会默认<strong>调用def unapplySeq() 方法</strong><br><strong>如果unapplySeq返回是Some，获取其中的值,判断得到的sequence中的元素的个数是否是三个,如果是三个，则把三个元素分别取出，赋值给first，second和third</strong><br>其它的规则不变.</p>
<h4 id="for表达式中的模式"><a href="#for表达式中的模式" class="headerlink" title="for表达式中的模式"></a>for表达式中的模式</h4><h5 id="基本介绍-17"><a href="#基本介绍-17" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>for循环也可以进行模式匹配.</p>
<h5 id="应用案例-12"><a href="#应用案例-12" class="headerlink" title="应用案例"></a>应用案例</h5><pre><code class="scala">val map = Map(&quot;A&quot;-&gt;1, &quot;B&quot;-&gt;0, &quot;C&quot;-&gt;3)
for ( (k, v) &lt;- map ) &#123;
println(k + &quot; -&gt; &quot; + v)
&#125;
//只要v是0的key-value，其他的过滤
for ((k, 0) &lt;- map) &#123;
println(k + &quot; --&gt; &quot; + 0)
&#125;
//可以进行范围匹配，更加灵活
for ((k, v) &lt;- map if v == 0) &#123;
println(k + &quot; ---&gt; &quot; + v)
&#125;
</code></pre>
<h4 id="样例类"><a href="#样例类" class="headerlink" title="样例类"></a>样例类</h4><h5 id="基本介绍-18"><a href="#基本介绍-18" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>1）<strong>样例类仍然是类</strong><br>2）样例类用<strong>case关键字</strong>进行声明。<br>3）样例类是为<strong>模式匹配而优化的类</strong><br>4）构造器中的<strong>每一个参数都成为val</strong>——除非它被显式地声明为var（不建议这样做）</p>
<p>5）在样例类对应的伴生对象中提供apply方法让你不用new关键字就能构造出相应的对象<br>6）提供unapply方法让模式匹配可以工作<br>7）将自动生成toString、equals、hashCode和copy方法(有点类似模板类，直接给生成，供程序员使用)<br>8）除上述外，样例类和其他类完全一样。你可以添加方法和字段，扩展它们</p>
<h5 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h5><pre><code class="scala">abstract class Amount
case class Dollar(value: Double) extends Amount 
case class Currency(value: Double, unit: String) extends Amount
case object NoAmount extends Amount 

说明: 这里的 Dollar，Currencry, NoAmount  是样例类。
</code></pre>
<h6 id="实践案例1"><a href="#实践案例1" class="headerlink" title="实践案例1"></a>实践案例1</h6><p>当我们有一个类型为Amount的对象时，可以<strong>用模式匹配来匹配他的类型，并将属性值绑定到变量</strong>(即：把样例类对象的属性值提取到某个变量,该功能有用)</p>
<pre><code class="scala">object CaseClassDemo02 &#123;
  def main(args: Array[String]): Unit = &#123;
    for(amt&lt;-Array(Dollar2(1000.0),Currency2(1000.0,&quot;RMB&quot;),NoAmount2))&#123;
      val result = amt match &#123;
        case Dollar2(v)=&gt;&quot;$&quot;+v
        case Currency2(v,u)=&gt;v+&quot;  &quot;+u
        case NoAmount2 =&gt; &quot;&quot;
      &#125;
      println(amt+&quot;:&quot;+result)
    &#125;
  &#125;
&#125;
abstract class Amount2
//都是样例类
case class Dollar2(value: Double) extends Amount2

case class Currency2(value: Double, unit: String) extends Amount2

case object NoAmount2 extends Amount2
</code></pre>
<h6 id="实践案例2"><a href="#实践案例2" class="headerlink" title="实践案例2"></a>实践案例2</h6><p>样例类的<strong>copy方法和带名参数</strong><br>copy创建一个与现有对象值相同的新对象，并可以通过带名参数来修改某些属性。</p>
<pre><code class="scala">object CaseClassDemo03 &#123;
  def main(args: Array[String]): Unit = &#123;
    val amt = new Currency3(3000.0,&quot;RMB&quot;)
    val amt2: Currency3 = amt.copy()//创建的对象和amt属性一样
    println(amt2)
    val amt3 = amt.copy(value = 8000)
    println(amt3)
    val amt4: Currency3 = amt.copy(unit = &quot;美元&quot;)
    println(amt4)
  &#125;
&#125;
abstract class Amount3
//都是样例类
case class Dollar3(value: Double) extends Amount3

case class Currency3(value: Double, unit: String) extends Amount3

case object NoAmount3 extends Amount3
</code></pre>
<h5 id="case语句的中置-缀-表达式"><a href="#case语句的中置-缀-表达式" class="headerlink" title="case语句的中置(缀)表达式"></a>case语句的中置(缀)表达式</h5><h6 id="基本介绍-19"><a href="#基本介绍-19" class="headerlink" title="基本介绍"></a>基本介绍</h6><p>什么是中置表达式？1 + 2，这就是一个中置表达式。如果unapply方法产出一个元组，你可以在case语句中使用中置表示法。比如可以匹配一个List序列</p>
<h6 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h6><pre><code class="scala">List(1, 3, 5, 9) match &#123; //修改并测试
//1.两个元素间::叫中置表达式,至少first，second两个匹配才行.
//2.first 匹配第一个 second 匹配第二个, rest 匹配剩余部分(5,9)
case first :: second :: rest =&gt; println(first + second + rest.length) //
case _ =&gt; println(&quot;匹配不到...&quot;)
&#125;
</code></pre>
<h4 id="匹配嵌套结构"><a href="#匹配嵌套结构" class="headerlink" title="匹配嵌套结构"></a>匹配嵌套结构</h4><h5 id="基本介绍-20"><a href="#基本介绍-20" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>操作原理类似于正则表达式</p>
<h5 id="最佳实践案例-商品捆绑打折出售"><a href="#最佳实践案例-商品捆绑打折出售" class="headerlink" title="最佳实践案例-商品捆绑打折出售"></a>最佳实践案例-商品捆绑打折出售</h5><p>现在有一些商品，请使用Scala设计相关的样例类，完成商品捆绑打折出售。要求<br>商品捆绑可以是单个商品，也可以是多个商品。<br>打折时按照折扣x元进行设计.<br>能够统计出所有捆绑商品打折后的最终价格</p>
<pre><code class="scala">object SalesDemo &#123;
  def main(args: Array[String]): Unit = &#123;
    //匹配嵌套结构(就是Bundle的对象)
    val sale = Bundle(&quot;书籍&quot;, 10, Book(&quot;漫画&quot;, 40), Bundle(&quot;文学作品&quot;, 20, Book(&quot;《阳关》&quot;, 80), Book(&quot;《围城》&quot;, 30)))
    val res = sale match &#123;
      case Bundle(_, _, Book(desc, sss), _*) =&gt; (desc, sss)
    &#125;
    val result2 = sale match &#123;
      case Bundle(_, _, art@Book(_, _), rest@_*) =&gt; (art, rest)
    &#125;
    val result3 = sale match &#123;
      case Bundle(_, _, art@Book(_, _), rest ) =&gt; (art, rest)
    &#125;
    println(result3)
  &#125;
&#125;
//创建样例类
abstract class Item
//书名，价格
case class Book(description: String, price: Double) extends Item
//什么类型，折扣价格，书
case class Bundle(description: String, discount: Double, item: Item*) extends Item
</code></pre>
<h6 id="知识点1-将descr绑定到第一个Book的描述"><a href="#知识点1-将descr绑定到第一个Book的描述" class="headerlink" title="知识点1-将descr绑定到第一个Book的描述"></a>知识点1-将descr绑定到第一个Book的描述</h6><p>取出这个嵌套结构中的 “漫画”</p>
<pre><code class="scala">val sale = Bundle(&quot;书籍&quot;, 10,  Book(&quot;漫画&quot;, 40), Bundle(&quot;文学作品&quot;, 20, Book(&quot;《阳关》&quot;, 80), Book(&quot;《围城》&quot;, 30)))


val res = sale match  &#123;
//如果我们进行对象匹配时，不想接受某些值，则使用_ 忽略即可，_* 表示所有
case Bundle(_, _, Book(desc, _), _*) =&gt; desc
&#125;
</code></pre>
<h6 id="知识点2-通过-表示法将嵌套的值绑定到变量。-绑定剩余Item到rest"><a href="#知识点2-通过-表示法将嵌套的值绑定到变量。-绑定剩余Item到rest" class="headerlink" title="知识点2-通过@表示法将嵌套的值绑定到变量。_*绑定剩余Item到rest"></a>知识点2-通过@表示法将嵌套的值绑定到变量。_*绑定剩余Item到rest</h6><p>如何将 这个嵌套结构中的 “漫画” 和 第二个Bundle部分 绑定到变量，即赋值到变量中.</p>
<pre><code class="scala">val sale = Bundle(&quot;书籍&quot;, 10,  Book(&quot;漫画&quot;, 40), 
Bundle(&quot;文学作品&quot;, 20, Book(&quot;《阳关》&quot;, 80), Book(&quot;《围城》&quot;, 30)))

//art 代表第一个book，rest代表了后面的可变参数,是一个WrappedArray类型的
val result2 = sale match &#123;
case Bundle(_, _, art @ Book(_, _), rest @ _*) =&gt; (art, rest)
&#125;
println(result2)
println(&quot;art =&quot; + result2._1)
println(&quot;rest=&quot; + result2._2)
</code></pre>
<h6 id="知识点3-不使用-绑定剩余Item到rest"><a href="#知识点3-不使用-绑定剩余Item到rest" class="headerlink" title="知识点3-不使用_*绑定剩余Item到rest"></a>知识点3-不使用_*绑定剩余Item到rest</h6><pre><code class="scala">val result2 = sale match &#123;
//说明因为没有使用 _* 即明确说明没有多个Bundle,所以返回的rest，就不是WrappedArray了。
case Bundle(_, _, art @ Book(_, _), rest) =&gt; (art, rest)
&#125;
println(result2)
println(&quot;art =&quot; + result2._1)
println(&quot;rest=&quot; + result2._2)
</code></pre>
<h6 id="最佳实践案例-商品捆绑打折出售-1"><a href="#最佳实践案例-商品捆绑打折出售-1" class="headerlink" title="最佳实践案例-商品捆绑打折出售"></a>最佳实践案例-商品捆绑打折出售</h6><p>现在有一些商品，请使用Scala设计相关的样例类，完成商品可以捆绑打折出售。要求<br>商品捆绑可以是单个商品，也可以是多个商品。<br>打折时按照折扣xx元进行设计.<br>能够统计出所有捆绑商品打折后的最终价格</p>
<pre><code class="scala">def price (it:Item):Double=&#123;
    it match &#123;
      case Book(description, price) =&gt;price
      //获取书的价格减去折扣的价格
      case Bundle(description, discount, item@_*) =&gt; item.map(price(_)).sum-discount
    &#125;
  &#125;
&#125;
//创建样例类
abstract class Item
//书名，价格
case class Book(description: String, price: Double) extends Item
//什么类型，折扣价格，书
case class Bundle(description: String, discount: Double, item: Item*) extends Item
</code></pre>
<h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><h5 id="基本介绍-21"><a href="#基本介绍-21" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>如果想让case类的所有子类都必须<strong>在申明该类的相同的源文件中定义</strong>，可以将样例类的通用超类声明为<strong>sealed</strong>，这个超类称之为密封类。<br><strong>密封就是不能在其他文件中定义子类。</strong></p>
<pre><code class="scala">abstract sealed class Item
//就算是在同一个包也不行
</code></pre>
<h4 id="偏函数-partial-function"><a href="#偏函数-partial-function" class="headerlink" title="偏函数(partial function)"></a>偏函数(partial function)</h4><h5 id="基本介绍-22"><a href="#基本介绍-22" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>在<strong>对符合某个条件</strong>，而不是所有情况进行逻辑操作时，使用偏函数是一个不错的选择<br>将包在大括号内的一组case语句封装为函数，我们称之为<strong>偏函数</strong>，它只对会作用于指定类型的参数或指定范围值的参数实施计算，超出范围的值会忽略（未必会忽略，这取决于你打算怎样处理）</p>
<p>偏函数在Scala中是一个特质<strong>PartialFunction</strong></p>
<h5 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h5><p>1)将集合list中的所有数字+1，并返回一个新的集合</p>
<p>2)要求忽略掉 非数字 的元素，即返回的 新的集合 形式为 <strong>(2, 3, 4, 5)</strong></p>
<pre><code class="scala">object PartialFunctionDemo02 &#123;
  def main(args: Array[String]): Unit = &#123;
    //使用偏函数解决
    val list = List(1, 2, 3, 4, &quot;hello&quot;)
    //定义一个偏函数
    //接受的类型是Any，返回的类型是Int类型
    //不接收也会报错
    val partialFun = new PartialFunction[Any,Int] &#123;
      //如果返回true，就调用apply方法，构建一个对象实例
      //false，apply就不执行
      override def isDefinedAt(x: Any)=&#123;
        println(&quot;调用·1·&quot;)
        if (x.isInstanceOf[Int]) true else false
      &#125;
      override def apply(v1: Any): Int = &#123;
        println(v1.getClass)
        v1.asInstanceOf[Int]+1
      &#125;
    &#125;
    println(list.collect(partialFun))
  &#125;
&#125;
</code></pre>
<h5 id="偏函数的小结"><a href="#偏函数的小结" class="headerlink" title="偏函数的小结"></a>偏函数的小结</h5><p>1、使用构建特质的实现类(使用的方式是<strong>PartialFunction</strong>的匿名子类)<br>2、<strong>PartialFunction</strong> 是个特质(看源码)<br>3、构建偏函数时，参数形式   [Any, Int]是泛型，第一个表示参数类型，第二个表示返回参数<br>4、当使用偏函数时，会遍历集合的所有元素，编译器执行流程时先执行isDefinedAt()如果为true ,就会执行 apply，构建一个新的Int 对象返回<br>5、执行<strong>isDefinedAt</strong>() 为false 就过滤掉这个元素，即不构建新的Int对象.<br>6、<strong>map函数不支持偏函数</strong>，因为map底层的机制就是所有循环遍历，无法过滤处理原来集合的元素<br>7、<strong>collect</strong>函数支持偏函数</p>
<h6 id="偏函数执行流程"><a href="#偏函数执行流程" class="headerlink" title="偏函数执行流程"></a>偏函数执行流程</h6><p>new PartialFunction类后，定好返回值，重写方法 isDefinedAt()和apply()方法，一个个元素放到isDefinedAt()方法中判断，返回true或false，true则执行apply方法，执行里面的语句并返回</p>
<h5 id="偏函数简化形式"><a href="#偏函数简化形式" class="headerlink" title="偏函数简化形式"></a>偏函数简化形式</h5><h6 id="1-简化形式1"><a href="#1-简化形式1" class="headerlink" title="1)简化形式1"></a>1)简化形式1</h6><pre><code class="scala">def f2: PartialFunction[Any, Int] = &#123;
  case i: Int =&gt; i + 1 // case语句可以自动转换为偏函数
&#125;
val list2 = List(1, 2, 3, 4,&quot;ABC&quot;).collect(f2)
</code></pre>
<h6 id="2-简化形式2"><a href="#2-简化形式2" class="headerlink" title="2)简化形式2"></a>2)简化形式2</h6><pre><code class="scala">val list3 = List(1, 2, 3, 4,&quot;ABC&quot;).collect&#123; case i: Int =&gt; i + 1 
&#125;
println(list3)
</code></pre>
<h4 id="作为参数的函数"><a href="#作为参数的函数" class="headerlink" title="作为参数的函数"></a>作为参数的函数</h4><h5 id="基本介绍-23"><a href="#基本介绍-23" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>函数作为一个变量传入到了另一个函数中，那么该作为参数的函数的类型是：function1，即：(参数类型) &#x3D;&gt; 返回类型</p>
<h5 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h5><pre><code class="scala">def main(args: Array[String]): Unit = &#123;
def plus(x:Int,y: Int) = 3 +x
    val result1 = Array(1,2,3,4).map(plus(_,0))
    println(result1.mkString(&quot;,&quot;))
    //输出它的类型
    println(plus _)
  &#125;
</code></pre>
<h5 id="实例小结"><a href="#实例小结" class="headerlink" title="实例小结"></a>实例小结</h5><p>map(plus(<em>)) 中的plus(</em>) 就是将plus这个函数当做一个参数传给了map，_这里代表从集合中遍历出来的一个元素。</p>
<p>plus(_) 这里也可以写成 plus 表示对 Array(1,2,3,4) 遍历，将每次遍历的元素传给plus的 x<br>进行 3 + x 运算后，返回新的Int ，并加入到新的集合 result1中<br>def map[B, That](f: A &#x3D;&gt; B) 的声明中的 f: A &#x3D;&gt; B 一个函数</p>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><h5 id="基本介绍-24"><a href="#基本介绍-24" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>没有名字的函数就是匿名函数，可以通过函数表达式来设置匿名函数</p>
<h5 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h5><pre><code class="scala">  def main(args: Array[String]): Unit = &#123;
    //不要写返回类型，写上报错,自动类型推导
    //多行使用大括号包起来
    //不需要def函数命
    //多行，使用&#123;&#125;包括
    val triple = (x: Double) =&gt; &#123;
      println(&quot;x=&quot;+x)
      3 * x
    &#125;
    //普通函数不写参数会报错
    //这里会输出他的类型
    println(triple)
    println(triple(3))
  &#125;
</code></pre>
<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><h5 id="基本介绍-25"><a href="#基本介绍-25" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>能够接受函数作为参数的函数，叫做高阶函数 (higher-order function)。可使应用程序更加健壮。</p>
<h5 id="高阶函数基本使用"><a href="#高阶函数基本使用" class="headerlink" title="高阶函数基本使用"></a>高阶函数基本使用</h5><pre><code class="scala">  def main(args: Array[String]): Unit = &#123;
    def test(f: Double =&gt; Double,d: Double=&gt;Double, n1: Double) = &#123;
        //可以函数调用函数
      f(d(n1))
    &#125;

    def mod(d: Double): Int = &#123;
      d.toInt % 2
    &#125;

    def sum(d: Double): Double = &#123;
      d + d
    &#125;

    val unit = test(sum,mod, 1)
    println(unit)
  &#125;
</code></pre>
<pre><code class="scala"> def main(args: Array[String]): Unit = &#123;
    //minusxy是一个高阶函数
    def minusxy(x:Int) =&#123;
      (y:Int)=&gt;x-y//返回一个匿名函数
    &#125;
    //只要 unit对象不变，就一直是3
    val unit = minusxy(3)
    println(minusxy _)
    println(unit(2))
    println(unit(4))
    //也可以这么写
    println(minusxy(9)(4))
  &#125;
</code></pre>
<h6 id="高级函数案例的小结"><a href="#高级函数案例的小结" class="headerlink" title="高级函数案例的小结"></a>高级函数案例的小结</h6><p>函数名为 <strong>minusxy</strong><br>该函数返回一个<strong>匿名函数  (y: Int) &#x3D; &gt; x -y</strong><br>说明val result3 &#x3D; minusxy(3)(5)</p>
<p>minusxy(3)执行minusxy(x: Int)得到 (y: Int) &#x3D;&gt; 3 - y 这个匿名函数<br>minusxy(3)(5)执行 (y: Int) &#x3D;&gt; x - y 这个匿名函数<br>也可以分步执行: val f1 &#x3D; minusxy(3);   val res &#x3D; f1(90)</p>
<h4 id="参数-类型-推断"><a href="#参数-类型-推断" class="headerlink" title="参数(类型)推断"></a>参数(类型)推断</h4><h5 id="基本介绍-26"><a href="#基本介绍-26" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>参数推断省去类型信息（在某些情况下[需要有应用场景]，参数类型是可以推断出来的，如list&#x3D;(1,2,3) list.map()   map中函数参数类型是可以推断的)，同时也可以进行相应的简写。</p>
<h5 id="参数类型推断写法说明"><a href="#参数类型推断写法说明" class="headerlink" title="参数类型推断写法说明"></a>参数类型推断写法说明</h5><p>参数类型是可以推断时，可以省略参数类型<br>当传入的函数，只有单个参数时，可以省去括号<br>如果变量只在&#x3D;&gt;右边只出现一次，可以用_来代替</p>
<h5 id="应用案例-13"><a href="#应用案例-13" class="headerlink" title="应用案例"></a>应用案例</h5><pre><code class="scala">    val list = List(1,2,3,4)
    println(list.map(x=&gt;x+1))//List(2, 3, 4, 5)
    println(list.map((x)=&gt;x+1))//List(2, 3, 4, 5)
    println(list.map(x=&gt;x+1))//List(2, 3, 4, 5)
    println(list.map(_+1))//List(2, 3, 4, 5)
    val res = list.reduce(_+_)//10
</code></pre>
<h4 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包(closure)"></a>闭包(closure)</h4><h5 id="基本介绍-27"><a href="#基本介绍-27" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>基本介绍：<strong>闭包就是一个函数和与其相关的引用环境组合的一个整体(实体)。</strong></p>
<h5 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h5><pre><code class="scala"> def main(args: Array[String]): Unit = &#123;
    //minusxy是一个高阶函数
    def minusxy(x:Int) =&#123;
      (y:Int)=&gt;x-y//返回一个匿名函数
    &#125;
    //只要 unit对象不变，就一直是3
     //这里的unit就是闭包！！！
    val unit = minusxy(3)
    println(minusxy _)
    println(unit(2))
    println(unit(4))
    //也可以这么写
    println(minusxy(9)(4))
  &#125;
</code></pre>
<h5 id="代码小结"><a href="#代码小结" class="headerlink" title="代码小结"></a>代码小结</h5><p>1、第1点  (y: Int) &#x3D;&gt; x – y</p>
<p>2、返回的是一个匿名函数 ，因为该函数引用到到函数外的 x,那么  该函数和x整体形成一个闭包<br>如：这里 val f &#x3D; minusxy(20) 的f函数就是闭包 </p>
<p>你可以这样理解，返回函数是一个对象，而x就是该对象的一个字段，他们共同形成一个闭包<br>3、当多次调用f时（可以理解多次调用闭包），<strong>发现使用的是同一个x, 所以x不变。</strong><br>4、在使用闭包时，主要搞清楚返回函数引用了函数外的哪些变量，因为他们会组合成一个整体(实体),形成一个闭包</p>
<h6 id="闭包的最佳实践"><a href="#闭包的最佳实践" class="headerlink" title="闭包的最佳实践"></a>闭包的最佳实践</h6><p>请编写一个程序，具体要求如下<br>编写一个函数 makeSuffix(suffix: String)  可以接收一个文件后缀名(比如.jpg)，并返回一个闭包<br>调用闭包，可以传入一个文件名，如果该文件名没有指定的后缀(比如.jpg) ,则返回 文件名.jpg , 如果已经有.jpg后缀，则返回原文件名。<br>要求使用闭包的方式完成<br>String.endsWith(xx)</p>
<pre><code class="scala">  def main(args: Array[String]): Unit = &#123;
    val f = makeSuffix(&quot;.jpg&quot;)
    println(f(&quot;asdf&quot;))
    println(f(&quot;asdf.jpg&quot;))
  &#125;
  
  def makeSuffix(suffix: String) =&#123;
    //使用到suffix
    (filename: String) =&gt; &#123;
        //endwith，判断filename是不是以suffix为结尾
      if (filename.endsWith(suffix)) &#123;
        filename
      &#125; else &#123;
        filename + suffix
      &#125;
    &#125;
  &#125;
</code></pre>
<h4 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h4><h5 id="基本介绍-28"><a href="#基本介绍-28" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>函数编程中，<strong>接受多个参数的函数都可以转化为接受单个参数的函数，这个转化过程就叫柯里化</strong></p>
<p><strong>柯里化就是证明了函数只需要一个参数而已</strong>。其实我们刚才的学习过程中，已经涉及到了柯里化操作。</p>
<p>不用设立柯里化存在的意义这样的命题。柯里化就是以函数为主体这种思想发展的必然产生的结果。(即：柯里化是面向函数思想的必然产生结果)</p>
<h5 id="函数柯里化快速入门"><a href="#函数柯里化快速入门" class="headerlink" title="函数柯里化快速入门"></a>函数柯里化快速入门</h5><p>编写一个函数，接收两个整数，可以返回两个数的乘积，要求:</p>
<p>使用常规的方式完成<br>使用闭包的方式完成<br>使用函数柯里化完成</p>
<pre><code class="scala">//说明
def mul(x: Int, y: Int) = x * y
println(mul(10, 10))
//闭包
def mulCurry(x: Int) = (y: Int) =&gt; x * y
println(mulCurry(10)(9))
//柯里化
def mulCurry2(x: Int)(y:Int) = x * y
println(mulCurry2(10)(8))
</code></pre>
<h4 id="控制抽象"><a href="#控制抽象" class="headerlink" title="控制抽象"></a>控制抽象</h4><h5 id="控制抽象基本介绍"><a href="#控制抽象基本介绍" class="headerlink" title="控制抽象基本介绍"></a>控制抽象基本介绍</h5><p>控制抽象是这样的函数，满足如下条件<br><strong>1、参数是函数</strong><br><strong>2、函数参数没有输入值也没有返回值</strong></p>
<h5 id="应用案例-14"><a href="#应用案例-14" class="headerlink" title="应用案例"></a>应用案例</h5><pre><code class="scala">  def main(args: Array[String]): Unit = &#123;
    //接受的函数，没有输入也没有输出的函数
    def myRunInThread(f1: () =&gt; Unit) = &#123;
      new Thread &#123;
        override def run(): Unit = &#123;
          f1()
        &#125;
      &#125;.start()
    &#125;
    myRunInThread &#123;
      () =&gt; println(&quot;干活咯！5秒完成...&quot;)
        Thread.sleep(5000)
        println(&quot;干完咯！&quot;)
    &#125;
  &#125;
</code></pre>
<h5 id="控制抽象while循环案例"><a href="#控制抽象while循环案例" class="headerlink" title="控制抽象while循环案例"></a>控制抽象while循环案例</h5><pre><code class="scala">  def main(args: Array[String]): Unit = &#123;
    var x = 10
    while (x &gt; 0) &#123;
      x -= 1
      println(x)
    &#125;
    //上下等价
    x=10
    until(x&gt;0)&#123;
      x-=1
      println(x)
    &#125;

    //使用控制抽象写出until，实现类似效果
    def until(f: =&gt; Boolean)(f2 : =&gt; Unit): Unit = &#123;
      if(f)&#123;
        f2
        until(f)(f2)
      &#125;
    &#125;
      
  &#125;
</code></pre>
<h4 id="使用递归的方式去思考-去编程"><a href="#使用递归的方式去思考-去编程" class="headerlink" title="使用递归的方式去思考,去编程"></a>使用递归的方式去思考,去编程</h4><h5 id="基本介绍-29"><a href="#基本介绍-29" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>1、<strong>Scala 是运行在 Java 虚拟机（Java Virtual Machine）之上</strong>，因此具有如下特点:<br>2、<strong>轻松实现和丰富的 Java 类库互联互通。</strong><br>3、<strong>它既支持面向对象的编程方式，又支持函数式编程。</strong></p>
<p>4、它写出的程序像动态语言一样简洁，但事实上它确是严格意义上的静态语言。<br>Scala 就像一位武林中的集大成者，将过去几十年计算机语言发展历史中的精萃集于一身，化繁为简，为程序员们提供了一种新的选择。设计者马丁·奥得斯基 希望程序员们将编程作为简洁，高效，令人愉快的工作。同时也让程序员们进行关于编程思想的新的思考。</p>
<h5 id="Scala提倡函数式编程-递归思想"><a href="#Scala提倡函数式编程-递归思想" class="headerlink" title="Scala提倡函数式编程(递归思想)"></a>Scala提倡函数式编程(递归思想)</h5><p>编程范式:<br>1、在所有的编程范式中，面向对象编程（Object-Oriented Programming）无疑是最大的赢家。<br>2、但其实面向对象编程并不是一种严格意义上的编程范式，严格意义上的<strong>编程范式分为：命令式编程（Imperative Programming）、函数式编程（Functional Programming）和逻辑式编程（Logic Programming）</strong>。<strong>面向对象编程只是上述几种范式的一个交叉产物</strong>，更多的还是继承了命令式编程的基因。<br>3、在传统的语言设计中，只有命令式编程得到了强调，那就是程序员要告诉计算机应该怎么做。而递归则通过灵巧的函数定义，告诉计算机做什么。因此在使用命令式编程思维的程序中，是现在多数程序采用的编程方式，递归出镜的几率很少，而在函数式编程中，大家可以随处见到递归的方式。</p>
<h5 id="应用实例-3"><a href="#应用实例-3" class="headerlink" title="应用实例"></a>应用实例</h5><pre><code class="scala">//常规方式 
def main(args: Array[String]): Unit = &#123;
    val now:Date = new Date()
    val dateFormat : SimpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)
    val date = dateFormat.format(now)
    println(date)
    var i = BigInt(1)
    var sum =BigInt(0)
    val maxVal = BigInt(99999991)
    while(i&lt;maxVal)&#123;
      sum += i
      i+=1
    &#125;
    println(sum)
    println(dateFormat.format(new Date()))
  &#125;
</code></pre>
<pre><code class="scala">//递归方，计算时间不会比常规慢，当时递归使用时有陷阱
def main(args: Array[String]): Unit = &#123;
    val now: Date = new Date()
    val dateFormat: SimpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)
    val date = dateFormat.format(now)
    println(date)
    var i = BigInt(1)
    var sum = BigInt(0)
    val int: BigInt = mx(i, sum)
    println(int)
    println(dateFormat.format(new Date()))
  &#125;

  def mx(num: BigInt, sum: BigInt):BigInt = &#123;
    if (num &lt;= 99999991) &#123;
      mx(num + 1, sum + num)
    &#125; else &#123;
      sum
    &#125;
  &#125;
</code></pre>
<h5 id="求最大值"><a href="#求最大值" class="headerlink" title="求最大值"></a>求最大值</h5><pre><code class="scala">def max(xs: List[Int]): Int = &#123;
    if (xs.size == 1) &#123;
      xs.head
    &#125; else if (xs.head &gt; max(xs.tail)) &#123;
      xs.head
    &#125; else &#123;
      max(xs.tail)
    &#125;
  &#125;
</code></pre>
<h5 id="翻转字符串"><a href="#翻转字符串" class="headerlink" title="翻转字符串"></a>翻转字符串</h5><pre><code class="scala">def reverse(xs: String): String =
    if (xs.length == 1) xs else reverse(xs.tail) + xs.head
</code></pre>
<h5 id="求阶乘"><a href="#求阶乘" class="headerlink" title="求阶乘"></a>求阶乘</h5><pre><code class="scala">def factorial(n: Int): Int =
    if (n == 0) 1 else n * factorial(n - 1)
</code></pre>
<h4 id="项目开发流程"><a href="#项目开发流程" class="headerlink" title="项目开发流程"></a>项目开发流程</h4><p>0、可行性分析(干什么，谁来干？)</p>
<p>1、需求分析（需求分析师，分析报告）</p>
<p>2、设计阶段（架构师，什么架构，什么计数，什么系统，设计文档，界面）</p>
<p>3、实现阶段（软件工程师，看懂文档，实现模块）</p>
<p>4、测试阶段(测试工程师，一边开发，一边测试，白盒，黑盒，灰盒)</p>
<p>5、实施阶段（实施工程师，部署到系统上，正确运行）</p>
<p>6、维护阶段（不一定有专人，没人找经理）</p>
<h4 id="Akka-介绍"><a href="#Akka-介绍" class="headerlink" title="Akka 介绍"></a>Akka 介绍</h4><h5 id="基本介绍-30"><a href="#基本介绍-30" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>1、Akka是JAVA虚拟机JVM平台上构建高并发、分布式和容错应用的工具包和运行时，你可以理解成<strong>Akka是编写并发程序的框架。</strong><br>2、Akka用Scala语言写成，<strong>同时提供了Scala和JAVA的开发接口。</strong><br>3、<strong>Akka主要解决的问题是：可以轻松的写出高效稳定的并发程序，程序员不再过多的考虑线程、锁和资源竞争等细节。</strong></p>
<h5 id="Actor-模型用于解决什么问题"><a href="#Actor-模型用于解决什么问题" class="headerlink" title="Actor 模型用于解决什么问题"></a>Actor 模型用于解决什么问题</h5><p>1、处理并发问题关键是要保证共享数据的一致性和正确性，因为程序是多线程时，多个线程对同一个数据进行修改，若不加同步条件，势必会造成数据污染。但是当我们对关键代码加入同步条件synchronized 后，实际上大并发就会阻塞在这段代码，对程序效率有很大影响。</p>
<p>2、若是用单线程处理，不会有数据一致性的问题，但是系统的性能又不能保证。<br>3、Actor 模型的出现解决了这个问题，<strong>简化并发编程，提升程序性能</strong>。 你可以这里理解：Actor 模型是一种处理并发问题的解决方案，很牛!</p>
<h5 id="Actor模型及其说明"><a href="#Actor模型及其说明" class="headerlink" title="Actor模型及其说明"></a>Actor模型及其说明</h5><p><img src="/scala/scala/image-20200310190600614.png" alt="image-20200310190600614"></p>
<p>1、<strong>Akka 处理并发的方法基于 Actor 模型。</strong>(示意图)<br>2、在基于 Actor 的系统里，所有的事物都是 Actor，就好像在面向对象设计里面所有的事物都是对象一样。<br>3、<strong>Actor 模型是作为一个并发模型设计和架构的。Actor 与 Actor 之间只能通过消息通信，如图的信封.</strong></p>
<p>4、Actor 与 Actor 之间只能用消息进行通信，当一个 Actor 给另外一个 Actor发消息，消息是有顺序的(消息队列)，只需要将消息投寄的相应的邮箱即可。</p>
<p>5、怎么处理消息是由接收消息的Actor决定的，发送消息Actor可以等待回复，也可以异步处理【ajax】</p>
<p>6、<strong>ActorSystem 的职责是负责创建并管理其创建的 Actor</strong>， <strong>ActorSystem 是单例的</strong>(可以理解ActorSystem是一个工厂，专门创建Actor)，一个 JVM 进程中有一个即可，而 Acotr 是可以有多个的。</p>
<p>7、Actor模型是对并发模型进行了更高的抽象。</p>
<p>8、Actor模型是异步、非阻塞、高性能的事件驱动编程模型。[什么是异步、非阻塞, 最经典的案例就是ajax异步请求处理 ]</p>
<p>9、<strong>Actor模型是轻量级事件处理（1GB 内存可容纳百万级别个 Actor），因此处理大并发性能高.</strong></p>
<h5 id="Actor模型工作机制说明"><a href="#Actor模型工作机制说明" class="headerlink" title="Actor模型工作机制说明"></a>Actor模型工作机制说明</h5><p><img src="/scala/scala/image-20200310191255505.png" alt="image-20200310191255505"></p>
<pre><code class="scala">B Actor 中
receive 方法 &#123;
//1.消息接收和处理
//2. 通过sender() 方法可以得到发送消息的Actor的ActorRef, 通过这个ActorRef，B Actor 也可以回复消息
&#125;
</code></pre>
<p>1、<strong>ActorySystem创建Actor</strong><br>2、ActorRef:可以理解成是Actor的代理或者引用。消息是通过ActorRef来发送,而不能通过Actor 发送消息，通过哪个ActorRef 发消息，就表示把该消息发给哪个Actor<br>3、消息发送到<strong>Dispatcher Message (消息分发器)<strong>，它得到消息后，会将消息进行分发到对应的</strong>MailBox</strong>。(注: Dispatcher Message 可以理解成是一个线程池, <strong>MailBox</strong> 可以理解成是消息队列，可以缓冲多个消息，遵守FIFO)<br>4、Actor 可以通过 <strong>receive</strong>方法来获取消息，然后进行处理。</p>
<h5 id="Actor间传递消息机制-对照工作机制示意图理解"><a href="#Actor间传递消息机制-对照工作机制示意图理解" class="headerlink" title="Actor间传递消息机制(对照工作机制示意图理解)"></a>Actor间传递消息机制(对照工作机制示意图理解)</h5><p>1、每一个消息就是一个<strong>Message</strong>对象。Message 继承了Runable， 因为Message就是线程类。<br>2、从Actor模型工作机制看上去很麻烦，但是程序员编程时只需要编写Actor就可以了，其它的交给Actor模型完成即可。<br>3、A Actor要给B Actor 发送消息，那么A Actor 要先拿到(也称为持有) B Actor 的 代理对象<strong>ActorRef</strong> 才能发送消息 </p>
<h5 id="Actor模型快速入门"><a href="#Actor模型快速入门" class="headerlink" title="Actor模型快速入门"></a>Actor模型快速入门</h5><p>1、编写一个Actor, 比如SayHelloActor<br>2、SayHelloActor 可以给自己发送消息 ,如图</p>
<p><img src="/scala/scala/image-20200310200039436.png" alt="image-20200310200039436"></p>
<p>3、要求使用Maven的方式来构建项目,这样可以很好的解决项目开发包的依赖关系。[scala 和 akka]</p>
<pre><code class="scala">import akka.actor.&#123;Actor, ActorRef, ActorSystem, Props&#125;

//继承Actor，重写核心方法  receive
class SayHelloActor extends Actor &#123;
  //receive方法会被该MailBox(实现类Runnable方法)调用
  //当MailBox接收到消息，调用receive获取消息
  //  type Receive = PartialFunction[Any, Unit]
  override def receive: Receive = &#123;
    case &quot;hello&quot; =&gt; println(&quot;hello too&quot;)
    case &quot;ok&quot; =&gt; println(&quot;ok too&quot;)
    case &quot;exit&quot;=&gt;&#123;
      println(&quot;退出系统&quot;)
      context.stop(self)//停止Actorref
      context.system.terminate()//退出ActorSystem系统
    &#125;
    case _ =&gt; println(&quot;匹配不到&quot;)
  &#125;
&#125;

object SayHelloActorDemo &#123;
  //先创建一个ActorSystem，专门用于创建Actor
  private val actorFactory: ActorSystem = ActorSystem(&quot;ActorFactory&quot;)
  //创建一个Actor的同时，返回ActorRef
  //说明
  //1、Props[SayHelloActor]创建了一个sayHelloActor的实例，使用了反射机制
  //2、Actor01  名字，名字不要重复
  //3、ActorRef  类型，当前Actor01的引用
  private val actorRef01: ActorRef = actorFactory.actorOf(Props[SayHelloActor], &quot;Actor01&quot;)

  def main(args: Array[String]): Unit = &#123;
    //给自己发消息，测试
    actorRef01!&quot;hello&quot;
    actorRef01!&quot;ok&quot;
    actorRef01!&quot;ok~&quot;
    actorRef01!&quot;exit&quot;
  &#125;
&#125;
</code></pre>
<h5 id="Actor自我通讯机制原理图"><a href="#Actor自我通讯机制原理图" class="headerlink" title="Actor自我通讯机制原理图"></a>Actor自我通讯机制原理图</h5><p><img src="/scala/scala/image-20200310200445268.png" alt="image-20200310200445268"></p>
<h5 id="小结和说明"><a href="#小结和说明" class="headerlink" title="小结和说明"></a>小结和说明</h5><p>当程序执行 aActorRef &#x3D; actorFactory.actorOf(Props[AActor], “aActor”) ，会完成如下任务 [这是非常重要的方法]<br>1、actorFactory 是 <strong>ActorSystem(“ActorFactory”)</strong> 这样创建的。<br>2、这里的 Props[AActor] 会使用反射机制，创建一个AActor 对象，如果是actorFactory.actorOf(Props(new AActor(bActorRef)), “aActorRef”) 形式，就是使用new 的方式创建一个AActor对象, 注意Props() 是小括号。<br>3、会创建一个AActor 对象的代理对象 aActorRef , 使用aActorRef 才能发送消息<br>4、会在底层创建 <strong>Dispather Message</strong> ，是一个<strong>线程池，用于分发消息</strong>， 消息是发送到对应的Actor的 <strong>MailBox</strong></p>
<p>5、会在底层创建AActor 的<strong>MailBox</strong> 对象，该对象是一个<strong>队列</strong>，可<strong>接收Dispatcher Message 发送的消息</strong><br>6、<strong>MailBox 实现了Runnable 接口，是一个线程</strong>，一直运行并调用Actor的receive 方法，因此当Dispather 发送消息到MailBox时，<strong>Actor 在receive 方法就可以得到信息.</strong><br>7、aActorRef <strong>!</strong>  “hello”, 表示把hello消息发送到A Actor 的mailbox （通过Dispatcher Message 转发）</p>
<h5 id="两个Actor的通讯机制原理图"><a href="#两个Actor的通讯机制原理图" class="headerlink" title="两个Actor的通讯机制原理图"></a>两个Actor的通讯机制原理图</h5><p><img src="/scala/scala/image-20200311105610114.png" alt="image-20200311105610114"></p>
<h5 id="两个Actor的通讯小结和说明"><a href="#两个Actor的通讯小结和说明" class="headerlink" title="两个Actor的通讯小结和说明"></a>两个Actor的通讯小结和说明</h5><p>1、两个Actor通讯机制和Actor 自身发消息机制基本一样，只是要注意如下<br>2、如果A Actor 在需要给B Actor 发消息，则需要持有B Actor 的 <strong>ActorRef</strong>，可以通过创建时，传入 B Actor的 代理对象(ActorRef)<br>3、当B Actor 在receive 方法中接收到消息，需要回复时，可以通过sender() 获取到发送Actor的 代理对象。</p>
<h5 id="单机版应用实例"><a href="#单机版应用实例" class="headerlink" title="单机版应用实例"></a>单机版应用实例</h5><p>1、编写2个 Actor , 分别是  AActor 和 BActor<br>2、AActor和BActor之间可以相互发送消息.</p>
<p>3、加强对Actor传递消息机制的理解。</p>
<pre><code class="scala">import akka.actor.&#123;Actor, ActorRef&#125;
//给bActor发消息需要bActorRef，传入一个
class AActor(actorRef:ActorRef) extends Actor &#123;
  val bActorRef: ActorRef = actorRef
  var i = 0
  override def receive: Receive =
    &#123;
      case &quot;star&quot; =&gt; &#123;
        println(&quot;AActor出招了...&quot;)
        self ! &quot;我打&quot;
      &#125;
      case &quot;我打&quot; =&gt; &#123;
        //给bActor发送消息
        println(&quot;黄飞鸿  我打  飞上无影脚&quot;)
        Thread.sleep(1000)
        bActorRef ! &quot;我打&quot; //发给bactor邮箱
      &#125;
  &#125;
&#125;
</code></pre>
<pre><code class="scala">import akka.actor.&#123;Actor, ActorRef&#125;

class BActor extends Actor &#123;
  override def receive: Receive = &#123;
    case &quot;我打&quot; =&gt; &#123;
      println(&quot;乔峰 挺猛  降龙十八掌1&quot;)
      Thread.sleep(1000)
      sender() ! &quot;我打&quot;
    &#125;
  &#125;
&#125;
</code></pre>
<pre><code class="scala">import akka.actor.&#123;ActorRef, ActorSystem, Props&#125;
//运行类
object ActorGame &#123;
  def main(args: Array[String]): Unit = &#123;
    val actorfactory: ActorSystem = ActorSystem(&quot;actorfactory&quot;)
      //bActor的引用
      //这种创建方式是单机版的
    val bActor: ActorRef = actorfactory.actorOf(Props[BActor], &quot;bActor&quot;)
    //因为有参数，所以new
    val aActor: ActorRef = actorfactory.actorOf(Props(new AActor(bActor)), &quot;aActor&quot;)
    aActor ! &quot;star&quot;
  &#125;
&#125;
</code></pre>
<h5 id="如何理解Actor-的receive-方法被调用"><a href="#如何理解Actor-的receive-方法被调用" class="headerlink" title="如何理解Actor 的receive 方法被调用?"></a>如何理解Actor 的receive 方法被调用?</h5><p>1、每个<strong>Actor</strong>对应<strong>MailBox</strong><br>2、<strong>MailBox</strong> 实现了<strong>Runnable</strong> 接口，处于运行的状态<br>3、当有消息到达<strong>MailBox</strong>,就会去调用Actor的<strong>receive</strong>方法，将消息<strong>推送给receive</strong> </p>
<h5 id="Akka执行流程"><a href="#Akka执行流程" class="headerlink" title="Akka执行流程"></a>Akka执行流程</h5><p>1、先创建ActorSystem</p>
<p>2、通过ActorySystem创建对应的Actor&#x2F;ActorRef(关联关系)</p>
<p>3、通过ActorRef！消息[发送ActorRef对应的Actor的milaBox]</p>
<p>4、先将消息发送给Dispatcher  Message（中间件）（Dispatcher线程池）</p>
<p>5、Dispatcher Message将消息抓发对应的Actor的MailBox</p>
<p>6、当Actor的MailBox收到消息后，就会调用Actor的receive方法，把消息推送给Actor</p>
<p>7、如果希望回复消息通过sender()!”消息“（send可以获取到发送消息的ActorRef）</p>
<h5 id="Akka网络编程"><a href="#Akka网络编程" class="headerlink" title="Akka网络编程"></a>Akka网络编程</h5><p>Akka支持<strong>面向大并发后端服务程序</strong>，网络通信这块是服务端程序重要的一部分。</p>
<p>网络编程有两种:<br>1、<strong>TCP socket编程</strong>，是网络编程的主流。之所以叫Tcp socket编程，是因为底层是基于Tcp&#x2F;ip协议的. 比如: QQ聊天 [示意图]</p>
<p>2、<strong>b&#x2F;s结构的http编程</strong>，我们使用浏览器去访问服务器时，使用的就是http协议，而http底层依旧是用tcp socket实现的协议(tcp&#x2F;ip)</p>
<h5 id="协议-tcp-x2F-ip"><a href="#协议-tcp-x2F-ip" class="headerlink" title="协议(tcp&#x2F;ip)"></a>协议(tcp&#x2F;ip)</h5><p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol)的简写,中文译名为传输控制协议&#x2F;因特网互联协议，又叫网络通讯协议，这个协议是Internet最基本的协议、Internet国际互联网络的基础，简单地说，就是由网络层的IP协议和传输层的TCP协议组成的。 比如: 京东商城 【属于 web 开发范畴 】</p>
<h5 id="OSI与Tcp-x2F-ip参考模型-推荐tcp-x2F-ip协议3卷"><a href="#OSI与Tcp-x2F-ip参考模型-推荐tcp-x2F-ip协议3卷" class="headerlink" title="OSI与Tcp&#x2F;ip参考模型 (推荐tcp&#x2F;ip协议3卷)"></a>OSI与Tcp&#x2F;ip参考模型 (推荐tcp&#x2F;ip协议3卷)</h5><p><img src="/scala/scala/image-20200311112906601.png" alt="image-20200311112906601"></p>
<h5 id="网络编程基础知识"><a href="#网络编程基础知识" class="headerlink" title="网络编程基础知识"></a>网络编程基础知识</h5><h6 id="端口-port-分类"><a href="#端口-port-分类" class="headerlink" title="端口(port)-分类"></a>端口(port)-分类</h6><p>1）<strong>0号是保留端口.</strong><br>2）<strong>1-1024是固定端口</strong><br>又叫有名端口,即被某些程序固定使用,一般程序员不使用.<br>22: SSH远程登录协议  23: telnet使用  21: ftp使用<br>25: smtp服务使用     80: iis使用	7: echo服务<br>3）<strong>1025-65535是动态端口</strong> 这些端口，程序员可以使用.</p>
<h6 id="端口-port-使用注意"><a href="#端口-port-使用注意" class="headerlink" title="端口(port)-使用注意"></a>端口(port)-使用注意</h6><p>在计算机(尤其是做服务器)要尽可能的少开端口[]<br>一个端口只能被一个程序监听( )<br>如果使用 <strong>netstat –an</strong> 可以查看本机有哪些端口在监听<br>可以使用 <strong>netstat –anb</strong> 来查看监听端口的pid,在结合任务管理器关闭不安全的端口.</p>
<h5 id="Akka网络编程实例-小黄鸡客服"><a href="#Akka网络编程实例-小黄鸡客服" class="headerlink" title="Akka网络编程实例_小黄鸡客服"></a>Akka网络编程实例_小黄鸡客服</h5><p><img src="/scala/scala/image-20200321132011289.png" alt="image-20200321132011289"></p>
<p><img src="/scala/scala/image-20200321132422962.png" alt="image-20200321132422962"></p>
<p>Client端</p>
<pre><code class="scala">//client
import akka.actor.&#123;Actor, ActorRef, ActorSelection, ActorSystem, Props&#125;
import com.star.akka.yellowchicken.common.&#123;ClientMessage, ServerMessage&#125;
import com.typesafe.config.ConfigFactory

import scala.io.StdIn

class CustomerActor(serverHost: String, serverPort: Int) extends Actor &#123;
  //定义一个YellowChickenServerRef
  var serverActorRef: ActorSelection = _

  //在Actor中有一个方法PreStart方法，他会在actor运行前执行
  //在akka的开发中，通常将初始化的工作，放在preStart方法
  override def preStart(): Unit = &#123;
    println(&quot;preStart() 执行&quot;)
    serverActorRef = context.actorSelection(s&quot;akka.tcp://Server@$&#123;serverHost&#125;:$&#123;serverPort&#125;/user/YellowChickenServer&quot;)

    println(&quot;serverActorRef=&quot; + serverActorRef)
  &#125;

  override def receive: Receive = &#123;
    case &quot;start&quot; =&gt; println(&quot;start,客户端运行，可以咨询问题&quot;)
    case mes: String =&gt; &#123;
      //发给小黄鸡客服
      serverActorRef ! ClientMessage(mes) //使用ClientMessage case class apply
    &#125;
    //如果接收到服务器的回复
    case ServerMessage(mes) =&gt; &#123;
      println(s&quot;收到小黄鸡客服(Server): $mes&quot;)
    &#125;

  &#125;
&#125;


//主程序-入口
object CustomerActor extends App &#123;

  val (clientHost, clientPort, serverHost, serverPort) = (&quot;127.0.0.1&quot;, 9990, &quot;127.0.0.1&quot;, 9999)
  val config = ConfigFactory.parseString(
    s&quot;&quot;&quot;
       |akka.actor.provider=&quot;akka.remote.RemoteActorRefProvider&quot;
       |akka.remote.netty.tcp.hostname=$clientHost
       |akka.remote.netty.tcp.port=$clientPort
        &quot;&quot;&quot;.stripMargin)

  //创建ActorSystem
  val clientActorSystem = ActorSystem(&quot;client&quot;, config)

  //创建CustomerActor的实例和引用
  val customerActorRef: ActorRef = clientActorSystem.actorOf(Props(new CustomerActor(serverHost, serverPort)), &quot;CustomerActor&quot;)

  //启动customerRef/也可以理解启动Actor
  customerActorRef ! &quot;start&quot;

  //客户端可以发送消息给服务器
  while (true) &#123;
    println(&quot;请输入要咨询的问题&quot;)
    val mes = StdIn.readLine()
    customerActorRef ! mes
  &#125;
&#125;
</code></pre>
<p>Common</p>
<pre><code class="scala">//common，他们公用的样例类

//样例类传入参数，默认成为只读属性
//使用样例类来构建协议
//客户端发给服务器协议(序列化的对象)
case class ClientMessage(mes: String)

//服务端发给客户端的协议(样例类对象)
case class ServerMessage(mes: String)
</code></pre>
<p>Server端</p>
<pre><code class="scala">//server端
import akka.actor.&#123;Actor, ActorRef, ActorSystem, Props&#125;
import com.star.akka.yellowchicken.common.&#123;ClientMessage, ServerMessage&#125;
import com.typesafe.config.ConfigFactory

class YellowChickenServer extends Actor&#123;
  override def receive:Receive = &#123;
    case &quot;start&quot; =&gt; println(&quot;start 小黄鸡客服开始工作了....&quot;)
    //如果接收到ClientMessage
    case ClientMessage(mes) =&gt; &#123;
      //使用match --case 匹配(模糊)
      mes match &#123;
        case &quot;大数据学费&quot; =&gt; sender() ! ServerMessage(&quot;35000RMB&quot;)
        case &quot;学校地址&quot; =&gt; sender() ! ServerMessage(&quot;北京昌平xx路xx大楼&quot;)
        case &quot;学习什么技术&quot; =&gt; sender() ! ServerMessage(&quot;大数据 前端 python&quot;)
        case _ =&gt; sender() ! ServerMessage(&quot;你说的啥子~&quot;)
      &#125;
    &#125;
  &#125;
&#125;

//主程序-入口
object YellowChickenServer extends App &#123;
  val host = &quot;127.0.0.1&quot; //服务端ip地址
  val port = 9999
  //创建config对象,指定协议类型，监听的ip和端口
  val config = ConfigFactory.parseString(
    s&quot;&quot;&quot;
       |akka.actor.provider=&quot;akka.remote.RemoteActorRefProvider&quot;
       |akka.remote.netty.tcp.hostname=$host
       |akka.remote.netty.tcp.port=$port
        &quot;&quot;&quot;.stripMargin)

  //创建ActorSystem
  //url (统一资源定位)
  val serverActorSystem = ActorSystem(&quot;Server&quot;,config)
  //创建YellowChickenServer 的actor和返回actorRef
  val yellowChickenServerRef: ActorRef = serverActorSystem.actorOf(Props[YellowChickenServer],&quot;YellowChickenServer&quot;)

  //启动
  yellowChickenServerRef ! &quot;start&quot;
&#125;
</code></pre>
<h5 id="Spark-Master-Worker-进程通讯项目"><a href="#Spark-Master-Worker-进程通讯项目" class="headerlink" title="Spark Master Worker 进程通讯项目"></a>Spark Master Worker 进程通讯项目</h5><p>1)worker注册到Master, Master完成注册，并回复worker注册成功</p>
<p>2)worker定时发送心跳，并在Master接收到</p>
<p>3)Master接收到worker心跳后，要更新该worker的最近一次发送心跳的时间</p>
<p>4)给Master启动定时任务，定时检测注册的worker有哪些没有更新心跳,并将其从hashmap中删除</p>
<p>5)master worker 进行分布式部署(Linux系统)-》如何给maven项目打包-&gt;上传linux</p>
<h6 id="实现功能1"><a href="#实现功能1" class="headerlink" title="实现功能1"></a>实现功能1</h6><p>1)worker注册到Master, Master完成注册，并回复worker注册成功</p>
<p>2)worker定时发送心跳，并在Master接收到</p>
<p>master端</p>
<pre><code class="scala">//master端
class SparkMaster extends Actor &#123;
  //定义一个hashmap，存放注册信息
  val workers = new mutable.HashMap[String, WorkerInfo]()

  override def receive: Receive = &#123;
    case &quot;start&quot; =&gt; println(&quot;master服务器启动&quot;)
    case RegisterWorkerInfo(id, cpu, ram) =&gt; &#123;
      //接收到客户端注册信息
      if (!workers.contains(id)) &#123;
        val workerInfo = new WorkerInfo(id, cpu, ram)
        workers += (id -&gt; workerInfo)
        println(s&quot;服务器数据：$&#123;workers&#125;&quot;)
        sender()!RegisteredWorkerInfo
      &#125;

    &#125;
  &#125;
&#125;

object SparkMaster &#123;
  def main(args: Array[String]): Unit = &#123;
    val host = &quot;127.0.0.1&quot; //服务端ip地址
    val port = 9999
    val conf = ConfigFactory.parseString(
      s&quot;&quot;&quot;
         |akka.actor.provider=&quot;akka.remote.RemoteActorRefProvider&quot;
         |akka.remote.netty.tcp.hostname=$host
         |akka.remote.netty.tcp.port=$port
        &quot;&quot;&quot;.stripMargin)
    val sparkmaster: ActorSystem = ActorSystem(&quot;sparkmaster&quot;, conf)
    val sparkmasterRef: ActorRef = sparkmaster.actorOf(Props[SparkMaster], &quot;sparkmaster01&quot;)
    sparkmasterRef ! (&quot;start&quot;)
  &#125;
&#125;
</code></pre>
<p>worker端</p>
<pre><code class="scala">class SparkWorker(masterHost: String, masterPort: Int) extends Actor &#123;
  //master的代理对象即引用
  var masterPorxy: ActorSelection = _
  //随机数的id值
  val id = UUID.randomUUID().toString

  override def preStart(): Unit = &#123;
    masterPorxy = context.actorSelection(s&quot;akka.tcp://sparkmaster@$&#123;masterHost&#125;:$&#123;masterPort&#125;/user/sparkmaster01&quot;)
  &#125;

  override def receive: Receive = &#123;
    case &quot;start&quot; =&gt; &#123;
      println(&quot;worker启动了&quot;)
      //向master发送注册信息
      masterPorxy ! RegisterWorkerInfo(id, 16, 16 * 1024)
    &#125;
    case RegisteredWorkerInfo=&gt;&#123;
      println(s&quot;workid$&#123;id&#125;注册成功&quot;)
    &#125;
  &#125;
&#125;

object SparkWorker &#123;
  def main(args: Array[String]): Unit = &#123;
    val (workerhost, workerport, masterHost, masterPort) = (&quot;127.0.0.1&quot;, 9990, &quot;127.0.0.1&quot;, 9999)
    val config = ConfigFactory.parseString(
      s&quot;&quot;&quot;
         |akka.actor.provider=&quot;akka.remote.RemoteActorRefProvider&quot;
         |akka.remote.netty.tcp.hostname=$workerhost
         |akka.remote.netty.tcp.port=$workerport
        &quot;&quot;&quot;.stripMargin)
    val sparkwork: ActorSystem = ActorSystem(&quot;sparkwork&quot;, config)
    val sparkworkRef: ActorRef = sparkwork.actorOf(Props(new SparkWorker(masterHost, masterPort)), &quot;sparkwork01&quot;)
    sparkworkRef ! &quot;start&quot;
  &#125;
&#125;
</code></pre>
<p>common，workermaster两个共同使用的</p>
<pre><code class="scala">//id   cpu 内存
case class RegisterWorkerInfo(id:String,cpu:Int,ram:Int)
//保存信息存放到maseter的hashmap中，可以扩展
class WorkerInfo(val id:String,val cpu:Int,val ram:Int)
//worker注册成功，master返回的信息
case object RegisteredWorkerInfo
</code></pre>
<h6 id="实现功能2"><a href="#实现功能2" class="headerlink" title="实现功能2"></a>实现功能2</h6><p>master端</p>
<pre><code class="scala">//接收到心跳 ，刷新对应的信息
case HearBeat(id)=&gt;&#123;
      val info: WorkerInfo = workers(id)
      info.lastHeartBeat = System.currentTimeMillis()
      println(s&quot;更新$&#123;id&#125;时间成功&quot;)
    &#125;
</code></pre>
<p>common端</p>
<pre><code class="scala">//worker每隔一定时间定时器给自己发送消息
case object SendHeartBeat
//worker每隔一定时间由定时器触发，向master发送消息
case class HearBeat(id:String)
//扩展了workerInfo
class WorkerInfo(val id:String,val cpu:Int,val ram:Int)&#123;
  var lastHeartBeat :Long = System.currentTimeMillis()
&#125;
</code></pre>
<p>worker端</p>
<pre><code class="scala">    case RegisteredWorkerInfo=&gt;&#123;
      println(s&quot;workid$&#123;id&#125;注册成功&quot;)
      //注册成功向master发送心跳
      //0 延时时间
      //2、3秒执行一次
      //3、发送给谁  self  发送给自己
      //4、发送的内容
      context.system.scheduler.schedule(0 millis,3000 millis,self,SendHeartBeat)
    &#125;
    case SendHeartBeat=&gt;&#123;
      masterPorxy! HearBeat(id)
    &#125;
</code></pre>
<h6 id="实现功能3"><a href="#实现功能3" class="headerlink" title="实现功能3"></a>实现功能3</h6><p>master启动定时任务，定时检测worker有没有超时（没有worker端的事情）</p>
<p>master端</p>
<pre><code class="scala">    case &quot;start&quot; =&gt; &#123;
      println(&quot;master服务器启动&quot;)
      self ! StartTimeOutWorker
    &#125;
    case StartTimeOutWorker =&gt; &#123;
      println(&quot;开始定时检测&quot;)
      //0 延时时间
      //2、9秒执行一次
      //3、发送给谁  self  发送给自己
      //4、发送的内容RemoveTimeOutWorker
      import context.dispatcher
      context.system.scheduler.schedule(0 millis, 9000 millis, self, RemoveTimeOutWorker)
    &#125;
    case RemoveTimeOutWorker =&gt; &#123;
      val time: Long = System.currentTimeMillis()
      val values: Iterable[WorkerInfo] = workers.values
      values.filter(t =&gt; (time - t.lastHeartBeat) &gt; 6000).foreach(v =&gt; workers.remove(v.id))
      println(s&quot;当前有$&#123;workers.size&#125;个worker存活&quot;)
    &#125;
</code></pre>
<p>common端</p>
<pre><code class="scala">//master给自己发送一个触发检测超时的worker信息
case object StartTimeOutWorker
//master给自己发送信息，检测worker心跳是否超时
case object RemoveTimeOutWorker
</code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">三山</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://star-light-star-bright.github.io/scala/scala/">https://star-light-star-bright.github.io/scala/scala/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">三山</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Scala/">
                                    <span class="chip bg-color">Scala</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/scala/scala-suan-zi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="Scala学习笔记">
                        
                        <span class="card-title">Scala学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-07-27
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Scala/" class="post-category">
                                    Scala
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Scala/">
                        <span class="chip bg-color">Scala</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="far fa-dot-circle"></i>
            </div>
            <div class="card">
                <a href="/scala/scala/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="Scala学习笔记">
                        
                        <span class="card-title">Scala学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-07-27
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Scala/" class="post-category">
                                    Scala
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Scala/">
                        <span class="chip bg-color">Scala</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2025</span>
            
            <a href="/about" target="_blank">三山</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
