<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Spring框架学习, ZWHBlog">
    <meta name="description" content="Spring框架概述Spring是什么Spring是分层的Java se&amp;#x2F;EE 应用full-stack轻量级开源框架，以及ioc(控制反转)和AOP（面向切面编程）为内核，提供了展现层SpringMVC和持久层Spring JD">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    

    <title>Spring框架学习 | ZWHBlog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.2.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">ZWHBlog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">ZWHBlog</div>
        <div class="logo-desc">
            
            这是我的博客网站
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/9.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Spring框架学习</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Spring/">
                                <span class="chip bg-color">Spring</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Java%E6%A1%86%E6%9E%B6/" class="post-category">
                                Java框架
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-01-16
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Spring框架概述"><a href="#Spring框架概述" class="headerlink" title="Spring框架概述"></a>Spring框架概述</h1><h3 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h3><p>Spring是分层的Java se&#x2F;EE 应用full-stack轻量级开源框架，以及ioc(控制反转)和AOP（面向切面编程）为内核，提供了展现层SpringMVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库。逐渐成为使用最多的Java EE企业应用开源框架</p>
<h3 id="Spring两大核心"><a href="#Spring两大核心" class="headerlink" title="Spring两大核心"></a>Spring两大核心</h3><p>IOC和AOP</p>
<h3 id="Spring的优势"><a href="#Spring的优势" class="headerlink" title="Spring的优势"></a>Spring的优势</h3><ol>
<li>方便解耦，简化开发</li>
<li>声明式事务的支持</li>
<li>方便程序的测试</li>
<li>方便集成各种优秀框架</li>
<li>降低javaEE API使用难度</li>
</ol>
<h3 id="Spring体系结构"><a href="#Spring体系结构" class="headerlink" title="Spring体系结构"></a>Spring体系结构</h3><p><img src="https://img-blog.csdnimg.cn/20201125203447667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY3NTg0NA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="程序的耦合及解耦"><a href="#程序的耦合及解耦" class="headerlink" title="程序的耦合及解耦"></a>程序的耦合及解耦</h3><p>使用反射来创建对象，而避免使用new关键字，spring框架主要就是通过ioc来达到解耦效果的，而mysql是用来封装各种操作，将过程简化(个人理解)</p>
<h3 id="曾经案例中问题"><a href="#曾经案例中问题" class="headerlink" title="曾经案例中问题"></a>曾经案例中问题</h3><p>业务层调用持久层，都会new一个实例，这是强耦合的关系，如何解决这个问题</p>
<h3 id="工厂模式解耦"><a href="#工厂模式解耦" class="headerlink" title="工厂模式解耦"></a>工厂模式解耦</h3><p>使用这种方式，可以减少他们的依赖，使用类加载器来进行对象加载，减少他们的耦合度，工厂模式有单例模式和多例模式两种，<br>使用工厂模式有多利和单例两种模式，单例模式中属性尽量保证他们的范围是方法范围而不是类的范围，否则后面可能有产生异常<br>使用类加载器配置文件可以是xml和properties的</p>
<pre><code class="java">/**
 * 一个创建Bean对象的工厂
 *
 * Bean：在计算机英语中，有可重用组件的含义。
 * JavaBean：用java语言编写的可重用组件。
 *      javabean &gt;  实体类
 *
 *   它就是创建我们的service和dao对象的。
 *
 *   第一个：需要一个配置文件来配置我们的service和dao
 *           配置的内容：唯一标识=全限定类名（key=value)
 *   第二个：通过读取配置文件中配置的内容，反射创建对象
 *
 *   我的配置文件可以是xml也可以是properties
 */
public class BeanFactory &#123;
    //定义一个Properties对象
    private static Properties props;

    //定义一个Map,用于存放我们要创建的对象。我们把它称之为容器
    private static Map&lt;String,Object&gt; beans;

    //使用静态代码块为Properties对象赋值
    static &#123;
        try &#123;
            //实例化对象
            props = new Properties();
            //获取properties文件的流对象
            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;);
            props.load(in);
            //实例化容器
            beans = new HashMap&lt;String,Object&gt;();
            //取出配置文件中所有的Key
            Enumeration keys = props.keys();
            //遍历枚举
            while (keys.hasMoreElements())&#123;
                //取出每个Key
                String key = keys.nextElement().toString();
                //根据key获取value
                String beanPath = props.getProperty(key);
                //反射创建对象
                Object value = Class.forName(beanPath).newInstance();
                //把key和value存入容器中
                beans.put(key,value);
            &#125;
        &#125;catch(Exception e)&#123;
            throw new ExceptionInInitializerError(&quot;初始化properties失败！&quot;);
        &#125;
    &#125;

    /**
     * 根据bean的名称获取对象
     * @param beanName
     * @return
     */
    public static Object getBean(String beanName)&#123;
        return beans.get(beanName);
    &#125;
&#125;
</code></pre>
<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="IOC概念和spring中的IOC"><a href="#IOC概念和spring中的IOC" class="headerlink" title="IOC概念和spring中的IOC"></a>IOC概念和spring中的IOC</h2><pre><code>控制反转，原来app和资源之间都是直接联系的
，二控制反转引入后，由工厂来和资源联系并把资源转到app中，实现了应用和资源之间的关系
带来的好处减少了程序之间的耦合
</code></pre>
<h2 id="Spring中基于Xml的IOC环境搭建"><a href="#Spring中基于Xml的IOC环境搭建" class="headerlink" title="Spring中基于Xml的IOC环境搭建"></a>Spring中基于Xml的IOC环境搭建</h2><ol>
<li><p>先导入spring的依赖</p>
<pre><code class="xml"> &lt;dependencies&gt;
     &lt;dependency&gt;
         &lt;groupId&gt;org.springframework&lt;/groupId&gt;
         &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
         &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;
     &lt;/dependency&gt;
 &lt;/dependencies&gt;
</code></pre>
</li>
<li><p>在spring.xml中配置</p>
</li>
</ol>
<p>使用时需要在xml配置文件中添加的头部文件</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context.xsd
   http://www.springframework.org/schema/aop
   http://www.springframework.org/schema/aop/spring-aop.xsd
   http://www.springframework.org/schema/tx
   http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;
  
    &lt;!--开启注解的扫描，希望处理service和dao，controller不需要Spring框架去处理--&gt;
    &lt;context:component-scan base-package=&quot;cn.itcast&quot; &gt;
        &lt;!--配置哪些注解不扫描--&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;
    &lt;/context:component-scan&gt;
    
    &lt;!--配置Spring框架声明式事务管理--&gt;
    &lt;!--配置事务管理器--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--配置事务通知--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!--配置AOP增强--&gt;
    &lt;aop:config&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* cn.itcast.service.impl.*ServiceImpl.*(..))&quot;/&gt;
    &lt;/aop:config&gt;
    
&lt;/beans&gt;
</code></pre>
<ol start="3">
<li>获取到spring的ioc核心容器</li>
</ol>
<pre><code class="java">/**
     * 获取spring的Ioc核心容器，并根据id获取对象
     *
     * ApplicationContext的三个常用实现类：
     *      ClassPathXmlApplicationContext：它可以加载类路径下的配置文件，要求配置文件必须在类路径下。不在的话，加载不了。(更常用)
     *      FileSystemXmlApplicationContext：它可以加载磁盘任意路径下的配置文件(必须有访问权限）
     *
     *      AnnotationConfigApplicationContext：它是用于读取注解创建容器的，前两个是指定配置文件路径的，这个是配置注解的方式
     *
     * 核心容器的两个接口引发出的问题：
     *  ApplicationContext:     单例对象适用              采用此接口
     *      它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。也就是说，只要一读取完配置文件马上就创建配置文件中配置的对象。
     *
     *  BeanFactory:            多例对象使用
     *      它在构建核心容器时，创建对象采取的策略是采用延迟加载的方式。也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象。
     * @param args
     */
        //--------ApplicationContext----------
    public static void main(String[] args) &#123;
        //1.获取核心容器对象
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
//        ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;C:\\Users\\zhy\\Desktop\\bean.xml&quot;);
        //2.根据id获取Bean对象
        IAccountService as  = (IAccountService)ac.getBean(&quot;accountService&quot;);
        IAccountDao adao = ac.getBean(&quot;accountDao&quot;,IAccountDao.class);

        System.out.println(as);
        System.out.println(adao);
        as.saveAccount();


        //--------BeanFactory----------
//        Resource resource = new ClassPathResource(&quot;bean.xml&quot;);
//        BeanFactory factory = new XmlBeanFactory(resource);
//        IAccountService as  = (IAccountService)factory.getBean(&quot;accountService&quot;);
//        System.out.println(as);
    &#125;
</code></pre>
<h2 id="Spring核心容器创建-两个接口的区别"><a href="#Spring核心容器创建-两个接口的区别" class="headerlink" title="Spring核心容器创建 两个接口的区别"></a>Spring核心容器创建 两个接口的区别</h2><p><strong>ApplicationContext</strong><br>构建核心容器，采用的策略是采用立即加载的方式，单例对象适用接口<br>更多的是采用此接口</p>
<p><strong>BeanFactory</strong><br>构建核心容器时，采用的是延迟加载的方式。多例对象适用接口</p>
<pre><code class="xml">&lt;!--把对象的创建交给spring来管理--&gt;
    spring对bean的管理细节
    1.创建bean的三种方式
    2.bean对象的作用范围
    3.bean对象的生命周期
</code></pre>
<h2 id="依赖注入-dependency-injection"><a href="#依赖注入-dependency-injection" class="headerlink" title="依赖注入(dependency injection)"></a>依赖注入(dependency injection)</h2><pre><code class="xml"> spring中的依赖注入
        依赖注入：
            Dependency Injection
        IOC的作用：
            降低程序间的耦合（依赖关系）
        依赖关系的管理：
            以后都交给spring来维护
        在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明
        依赖关系的维护：
            就称之为依赖注入。
         依赖注入：
            能注入的数据：有三类
                基本类型和String
                其他bean类型（在配置文件中或者注解配置过的bean）
                复杂类型/集合类型
             注入的方式：有三种
                第一种：使用构造函数提供
                第二种：使用set方法提供
                第三种：使用注解提供
</code></pre>
<h2 id="三种注入方式"><a href="#三种注入方式" class="headerlink" title="三种注入方式"></a>三种注入方式</h2><h3 id="bean标签的属性"><a href="#bean标签的属性" class="headerlink" title="bean标签的属性"></a>bean标签的属性</h3><p>bean的作用范围调整<br>    bean标签的  <strong>scope</strong>  属性：<br>        作用：用于指定  bean 的作用范围<br>        取值： 常用的就是单例的和多例的<br>            <strong>singleton</strong>：单例的（默认值）<br>            <strong>prototype</strong>：多例的<br>            <strong>request</strong>：作用于web应用的请求范围<br>            <strong>session</strong>：作用于web应用的会话范围<br>            <strong>global-session</strong>：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session</p>
<pre><code class="xml">&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;
</code></pre>
<h4 id="bean对象的生命周期"><a href="#bean对象的生命周期" class="headerlink" title="bean对象的生命周期"></a>bean对象的生命周期</h4><p><strong>单例对象</strong></p>
<pre><code>        出生：当容器创建时对象出生
        活着：只要容器还在，对象一直活着
        死亡：容器销毁，对象消亡
        总结：单例对象的生命周期和容器相同
</code></pre>
<p><strong>多例对象</strong></p>
<pre><code>        出生：当我们使用对象时spring框架为我们创建
        活着：对象只要是在使用过程中就一直活着。
        死亡：当对象长时间不用，且没有别的对象引用时，由Java的垃圾回收器回收
</code></pre>
<pre><code class="xml">&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;
      scope=&quot;prototype&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;&lt;/bean&gt;
</code></pre>
<p>初始化方法和关闭方法</p>
<h3 id="1、构造函数注入"><a href="#1、构造函数注入" class="headerlink" title="1、构造函数注入"></a>1、构造函数注入</h3><pre><code class="xml">&lt;!--构造函数注入：
        使用的标签:constructor-arg
        标签出现的位置：bean标签的内部
        标签中的属性
            type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型
            index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始
            name：用于指定给构造函数中指定名称的参数赋值                                        常用的
            =============以上三个用于指定给构造函数中哪个参数赋值===============================
            value：用于提供基本类型和String类型的数据
            ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象

        优势：
            在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。
        弊端：
            改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。
    --&gt;
    
&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;泰斯特&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

    &lt;!-- 配置一个日期对象 --&gt;
    &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;
//bean中通过ref来引用外部的bean
</code></pre>
<h3 id="2、set方法注入"><a href="#2、set方法注入" class="headerlink" title="2、set方法注入"></a>2、set方法注入</h3><pre><code class="xml">  &lt;!-- set方法注入                更常用的方式
        涉及的标签：property
        出现的位置：bean标签的内部
        标签的属性
            name：用于指定注入时所调用的set方法名称
            value：用于提供基本类型和String类型的数据
            ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象
        优势：
            创建对象时没有明确的限制，可以直接使用默认构造函数
        弊端：
            如果有某个成员必须有值，则获取对象是有可能set方法没有执行。
    --&gt;
    
    &lt;bean id=&quot;accountService2&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl2&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;TEST&quot; &gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;!-- 配置一个日期对象 --&gt;
    &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;
    //这里使用的是property这个标签来进行
</code></pre>
<h3 id="3、复杂类型的依赖注入"><a href="#3、复杂类型的依赖注入" class="headerlink" title="3、复杂类型的依赖注入"></a>3、复杂类型的依赖注入</h3><pre><code class="xml">&lt;!-- 复杂类型的注入/集合类型的注入
        用于给List结构集合注入的标签：
            list array set
        用于个Map结构集合注入的标签:
            map  props
        结构相同，标签可以互换
    --&gt;
    
    &lt;bean id=&quot;accountService3&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl3&quot;&gt;
        &lt;property name=&quot;myStrs&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;AAA&lt;/value&gt;
                &lt;value&gt;BBB&lt;/value&gt;
                &lt;value&gt;CCC&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;

        &lt;property name=&quot;myList&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;AAA&lt;/value&gt;
                &lt;value&gt;BBB&lt;/value&gt;
                &lt;value&gt;CCC&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;

        &lt;property name=&quot;mySet&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;AAA&lt;/value&gt;
                &lt;value&gt;BBB&lt;/value&gt;
                &lt;value&gt;CCC&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;

        &lt;property name=&quot;myMap&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;testC&quot;&gt;ccc&lt;/prop&gt;
                &lt;prop key=&quot;testD&quot;&gt;ddd&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;

        &lt;property name=&quot;myProps&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;testA&quot; value=&quot;aaa&quot;&gt;&lt;/entry&gt;
                &lt;entry key=&quot;testB&quot;&gt;
                    &lt;value&gt;BBB&lt;/value&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</code></pre>
<h2 id="创建Bean的三种方式"><a href="#创建Bean的三种方式" class="headerlink" title="创建Bean的三种方式"></a>创建Bean的三种方式</h2><h3 id="第一种方式：使用默认构造函数创建。"><a href="#第一种方式：使用默认构造函数创建。" class="headerlink" title="第一种方式：使用默认构造函数创建。"></a>第一种方式：使用默认构造函数创建。</h3><p>在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时。<br>采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建。</p>
<pre><code class="xml">&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;
</code></pre>
<h3 id="第二种方式：-使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）"><a href="#第二种方式：-使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）" class="headerlink" title="第二种方式： 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）"></a>第二种方式： 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）</h3><pre><code class="xml">&lt;bean id=&quot;instanceFactory&quot; class=&quot;com.itheima.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;
</code></pre>
<h3 id="第三种方式：使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器"><a href="#第三种方式：使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器" class="headerlink" title="第三种方式：使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器)"></a>第三种方式：使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器)</h3><pre><code class="xml">&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.factory.StaticFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;
</code></pre>
<h2 id="Spring中ioc常用注解"><a href="#Spring中ioc常用注解" class="headerlink" title="Spring中ioc常用注解"></a>Spring中ioc常用注解</h2><h3 id="在Spring容器中注入类的："><a href="#在Spring容器中注入类的：" class="headerlink" title="在Spring容器中注入类的："></a>在Spring容器中注入类的：</h3><h4 id="Component"><a href="#Component" class="headerlink" title="@Component:"></a>@Component:</h4><ul>
<li><p>作用：用于把当前类对象存入spring容器中</p>
</li>
<li><p>属性：</p>
</li>
<li><p>value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。</p>
</li>
</ul>
<h4 id="Controller："><a href="#Controller：" class="headerlink" title="@Controller："></a>@Controller：</h4><p>一般用在表现层</p>
<h4 id="Service："><a href="#Service：" class="headerlink" title="@Service："></a>@Service：</h4><p>一般用在业务层</p>
<h4 id="Repository："><a href="#Repository：" class="headerlink" title="@Repository："></a>@Repository：</h4><p>一般用在持久层</p>
<p>以上三个注解他们的作用和属性与Component是一模一样。</p>
<p>他们三个是spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰<br>当不属于这三层的就可以使用component来调用</p>
<h3 id="用于注入数据的："><a href="#用于注入数据的：" class="headerlink" title="用于注入数据的："></a>用于注入数据的：</h3><ul>
<li><pre><code> 他们的作用就和在xml配置文件中的bean标签中写一个&lt;property&gt;标签的作用是一样的
</code></pre>
</li>
</ul>
<h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired:"></a>@Autowired:</h4><ul>
<li>作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功</li>
</ul>
<p>如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。</p>
<p>如果Ioc容器中有多个类型匹配时：</p>
<ul>
<li>出现位置：</li>
</ul>
<p>可以是变量上，也可以是方法上</p>
<ul>
<li>细节：</li>
</ul>
<p>在使用注解注入时，set方法就不是必须的了。</p>
<h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier:"></a>@Qualifier:</h4><ul>
<li><p>作用：</p>
<p>在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用。但是在给方法参数注入时可以（稍后我们讲）</p>
</li>
<li><p>属性：</p>
</li>
</ul>
<p>value：用于指定注入bean的id。</p>
<h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><ul>
<li><p>作用：直接按照bean的id注入。它可以独立使用</p>
</li>
<li><p>属性：</p>
</li>
</ul>
<p>name：用于指定bean的id。</p>
<p>以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。</p>
<p>   另外，集合类型的注入只能通过XML来实现。</p>
<h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4><ul>
<li><p>作用：用于注入基本类型和String类型的数据</p>
</li>
<li><p>属性：</p>
</li>
</ul>
<p>value：用于指定数据的值。它可以使用spring中SpEL(也就是spring的el表达式）</p>
<p>SpEL的写法：${表达式}   </p>
<h3 id="用于改变作用范围的："><a href="#用于改变作用范围的：" class="headerlink" title="用于改变作用范围的："></a>用于改变作用范围的：</h3><p>他们的作用就和在bean标签中使用scope属性实现的功能是一样的</p>
<h4 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h4><ul>
<li><p>作用：用于指定bean的作用范围</p>
</li>
<li><p>属性：</p>
</li>
</ul>
<p>value：指定范围的取值。常用取值：singleton prototype</p>
<h3 id="和生命周期相关："><a href="#和生命周期相关：" class="headerlink" title="和生命周期相关："></a>和生命周期相关：</h3><p>他们的作用就和在bean标签中使用init-method和destroy-methode的作用是一样的</p>
<h4 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="@PreDestroy"></a>@PreDestroy</h4><p><strong>作用</strong>：用于指定销毁方法</p>
<h4 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h4><p><strong>作用</strong>：用于指定初始化方法 </p>
<h2 id="Spring一些新注解的使用"><a href="#Spring一些新注解的使用" class="headerlink" title="Spring一些新注解的使用"></a>Spring一些新注解的使用</h2><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><ul>
<li><pre><code>作用：指定当前类是一个配置类
</code></pre>
</li>
<li><pre><code>细节：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写。
</code></pre>
</li>
</ul>
<h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><ul>
<li><pre><code> 作用：用于通过注解指定spring在创建容器时要扫描的包(范围)
</code></pre>
</li>
<li><pre><code> 属性：
</code></pre>
</li>
<li><pre><code> value：它和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包。
</code></pre>
</li>
<li><pre><code> 我们使用此注解就等同于在xml中配置了:
</code></pre>
</li>
<li><pre><code> &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt;
</code></pre>
</li>
</ul>
<h4 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h4><ul>
<li><pre><code> 作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中
</code></pre>
</li>
<li><pre><code> 属性:
</code></pre>
</li>
<li><pre><code> name:用于指定bean的id。当不写时，默认值是当前方法的名称
</code></pre>
</li>
<li><pre><code> 细节：
</code></pre>
</li>
<li><pre><code> 当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。
</code></pre>
</li>
<li><pre><code> 查找的方式和Autowired注解的作用是一样的
</code></pre>
</li>
</ul>
<h4 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h4><ul>
<li><pre><code> 作用：用于导入其他的配置类
</code></pre>
</li>
<li><pre><code> 属性：
</code></pre>
</li>
<li><pre><code> value：用于指定其他配置类的字节码。
</code></pre>
</li>
<li><pre><code> 当我们使用Import的注解之后，有Import注解的类就父配置类，而导入的都是子配置类
</code></pre>
</li>
</ul>
<h4 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h4><ul>
<li><pre><code> 作用：用于指定properties文件的位置
</code></pre>
</li>
<li><pre><code> 属性：
</code></pre>
</li>
<li><pre><code> value：指定文件的名称和路径。
</code></pre>
</li>
<li><pre><code> 关键字：classpath，表示类路径下
</code></pre>
</li>
</ul>
<pre><code class="java">//@Configuration
@ComponentScan(&quot;com.itheima&quot;)
@Import(JdbcConfig.class)
@PropertySource(&quot;classpath:jdbcConfig.properties&quot;)
public class SpringConfiguration &#123;

&#125;
</code></pre>
<h2 id="使用纯注解的方式实现ioc案例"><a href="#使用纯注解的方式实现ioc案例" class="headerlink" title="使用纯注解的方式实现ioc案例"></a>使用纯注解的方式实现ioc案例</h2><pre><code>@ComponentScan(&quot;com.itheima&quot;)
@Import(JdbcConfig.class)
@PropertySource(&quot;classpath:jdbcConfig.properties&quot;)
public class SpringConfiguration &#123;
&#125;
</code></pre>
<h2 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h2><h3 id="DBUtils是什么，有什么作用？"><a href="#DBUtils是什么，有什么作用？" class="headerlink" title="DBUtils是什么，有什么作用？"></a>DBUtils是什么，有什么作用？</h3><p>持久层选择DBUtils</p>
<p>DBUtils简化了JDBC的开发步骤，使得我们可以用更少量的代码实现连接数据库的功能</p>
<p>JavaBean是一个用于封装数据的类，在与数据库连接之中，JavaBean其的作用是将获取的数据库的记录封装到JavaBean中。特性如下：</p>
<ol>
<li>需要实现接口：java.io.Serializable ，可以省略不写。</li>
<li>提供私有字段：private 类型 字段名;</li>
<li>提供getter&#x2F;setter方法：</li>
<li>提供无参构造</li>
</ol>
<p>获取getter&#x2F;setter方法，在类中右键-&gt;Source-&gt;Generate Getters and Setters</p>
<h3 id="DBUtils使用"><a href="#DBUtils使用" class="headerlink" title="DBUtils使用"></a>DBUtils使用</h3><p>DBUtils封装了JDBC的操作，核心功能如下：<br>Dbutils三个核心功能介绍</p>
<ol>
<li>QueryRunner中提供对sql语句操作的API.</li>
<li>ResultSetHandler接口，用于定义select操作后，怎样封装结果集.</li>
<li>DbUtils类是一个工具类，定义了关闭资源与事务处理的方法</li>
</ol>
<h3 id="QueryRunner核心类："><a href="#QueryRunner核心类：" class="headerlink" title="QueryRunner核心类："></a>QueryRunner核心类：</h3><ol>
<li>QueryRunner(DataSource ds) ；传入参数为连接池</li>
<li>update(String sql, Object… params) ，执行insert update delete操作</li>
<li>query(String sql, ResultSetHandler rsh, Object… params) ，执行 select操作</li>
</ol>
<h2 id="spring和junit的整合"><a href="#spring和junit的整合" class="headerlink" title="spring和junit的整合"></a>spring和junit的整合</h2><pre><code class="java">/**
 * 使用Junit单元测试：测试我们的配置
 * Spring整合junit的配置
 *      1、导入spring整合junit的jar(坐标)
 *      2、使用Junit提供的一个注解把原有的main方法替换了，替换成spring提供的
 *             @Runwith
 *      3、告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置
 *          @ContextConfiguration
 *                  locations：指定xml文件的位置，加上classpath关键字，表示在类路径下
 *                  classes：指定注解类所在地位置
 *
 *   当我们使用spring 5.x版本的时候，要求junit的jar必须是4.12及以上
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfiguration.class)
public class AccountServiceTest &#123;

    @Autowired
    private IAccountService as = null;


    @Test
    public void testFindAll() &#123;
        //3.执行方法
        List&lt;Account&gt; accounts = as.findAllAccount();
        for(Account account : accounts)&#123;
            System.out.println(account);
        &#125;
    &#125;

    @Test
    public void testFindOne() &#123;
        //3.执行方法
        Account account = as.findAccountById(1);
        System.out.println(account);
    &#125;
</code></pre>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理没听明白<br>视频：123-131   还需要看java基础的反射和基础知识</p>
<p><strong>特点</strong>：字节码随用随创建，随用随加载<br><strong>作用</strong>：不修改源码的基础上对方法增强<br><strong>分类</strong>：<br>基于接口的动态代理<br>基于子类的动态代理</p>
<h3 id="动态代理1：基于接口的动态代理"><a href="#动态代理1：基于接口的动态代理" class="headerlink" title="动态代理1：基于接口的动态代理"></a>动态代理1：基于接口的动态代理</h3><p>基于接口的动态代理：<br>涉及的类：Proxy<br>提供者：JDK官方<br>如何创建代理对象：<br>使用Proxy类中的newProxyInstance方法<br>创建代理对象的要求：</p>
<p><strong>被代理类最少实现一个接口，如果没有则不能使用</strong></p>
<p><strong>newProxyInstance</strong>   方法的参数：</p>
<p>ClassLoader：类加载器<br>    它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法。</p>
<p>Class[]：字节码数组<br>    它是用于让代理对象和被代理对象有相同方法。固定写法。</p>
<p>InvocationHandler：用于提供增强的代码<br>    它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。</p>
<p>此接口的实现类都是谁用谁写。</p>
<pre><code class="java">IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),
                producer.getClass().getInterfaces(),
                new InvocationHandler() &#123;
                    /**
                     * 作用：执行被代理对象的任何接口方法都会经过该方法
                     * 方法参数的含义
                     * @param proxy   代理对象的引用
                     * @param method  当前执行的方法
                     * @param args    当前执行方法所需的参数
                     * @return        和被代理对象方法有相同的返回值
                     * @throws Throwable
                     */
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
                        //提供增强的代码
                        Object returnValue = null;

                        //1.获取方法执行的参数
                        Float money = (Float)args[0];
                        //2.判断当前方法是不是销售
                        if(&quot;saleProduct&quot;.equals(method.getName())) &#123;
                            returnValue = method.invoke(producer, money*0.8f);
                        &#125;
                        return returnValue;
                    &#125;
                &#125;);
        proxyProducer.saleProduct(10000f);
</code></pre>
<h3 id="动态代理2：基于子类的动态代理"><a href="#动态代理2：基于子类的动态代理" class="headerlink" title="动态代理2：基于子类的动态代理"></a>动态代理2：基于子类的动态代理</h3><p><strong>特点</strong>：字节码随用随创建，随用随加载<br><strong>作用</strong>：不修改源码的基础上对方法增强</p>
<p>基于子类的动态代理：<br>涉及的类：Enhancer<br>提供者：第三方cglib库<br>如何创建代理对象：<br>使用Enhancer类中的create方法<br>创建代理对象的要求：<br>被代理类不能是最终类<br>create方法的参数：</p>
<ul>
<li><p>Class：字节码<br>它是用于指定被代理对象的字节码。</p>
</li>
<li><p>Callback：用于提供增强的代码<br>它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。<br> 此接口的实现类都是谁用谁写。</p>
</li>
</ul>
<p>我们一般写的都是该接口的子接口实现类：MethodInterceptor </p>
<pre><code class="java">Producer cglibProducer = (Producer)Enhancer.create(producer.getClass(), new MethodInterceptor() &#123;
 @Override
public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;
//提供增强的代码
    Object returnValue = null;

     //1.获取方法执行的参数
     Float money = (Float)args[0];
     //2.判断当前方法是不是销售
     if(&quot;saleProduct&quot;.equals(method.getName())) &#123;
           returnValue = method.invoke(producer, money*0.8f);
    &#125;
    return returnValue;
    &#125;
    &#125;);
        cglibProducer.saleProduct(12000f);
</code></pre>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>面向切面编程<br>作用：在程序运行期间，不修改源码的基础上对方法进行增强<br>优势：减少重复代码，提高开发效率，维护方便</p>
<p>是否实现了接口来判断<br>基于接口和基于子类的两种方式来动态代理</p>
<h2 id="Spring-Aop相关术语"><a href="#Spring-Aop相关术语" class="headerlink" title="Spring Aop相关术语"></a>Spring Aop相关术语</h2><p><strong>连接点</strong><br>方法就是连接点</p>
<p><strong>切入点</strong><br>被增强的方法就是切入点<br>所有的切入点都是连接点，但不是所有的连接点都是切入点</p>
<p><strong>通知和增强</strong><br>环绕通知是指整个方法调用</p>
<p><strong>四种通知类型</strong><br>前置通知<br>后置通知<br>异常通知<br>最终通知</p>
<p><strong>目标对象</strong><br>被代理对象</p>
<p><strong>织入</strong><br>加入增强功能的过程</p>
<p><strong>代理对象</strong><br>就是增强后的的代理类</p>
<p><strong>引介</strong><br>建立接入点方法</p>
<p><strong>切面</strong><br>切入点和通知(引介)的集合<br>就是一个抽象的概念，一步一步的执行，进行切分就是切入</p>
<h2 id="Spring中AOP配置"><a href="#Spring中AOP配置" class="headerlink" title="Spring中AOP配置"></a>Spring中AOP配置</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;!-- an HTTP Session-scoped bean exposed as a proxy --&gt;
    &lt;bean id=&quot;userPreferences&quot; class=&quot;com.something.UserPreferences&quot; scope=&quot;session&quot;&gt;
        &lt;!-- instructs the container to proxy the surrounding bean --&gt;
        &lt;aop:scoped-proxy/&gt; 
    &lt;/bean&gt;

    &lt;!-- a singleton-scoped bean injected with a proxy to the above bean --&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.something.SimpleUserService&quot;&gt;
        &lt;!-- a reference to the proxied userPreferences bean --&gt;
        &lt;property name=&quot;userPreferences&quot; ref=&quot;userPreferences&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="Spring中标签的AOP配置"><a href="#Spring中标签的AOP配置" class="headerlink" title="Spring中标签的AOP配置"></a>Spring中标签的AOP配置</h2><pre><code>spring中基于XML的AOP配置步骤
        1、把通知Bean也交给spring来管理
        2、使用aop:config标签表明开始AOP的配置
        3、使用aop:aspect标签表明配置切面
                id属性：是给切面提供一个唯一标识
                ref属性：是指定通知类bean的Id。
        4、在aop:aspect标签的内部使用对应标签来配置通知的类型
               我们现在示例是让printLog方法在切入点方法执行之前之前：所以是前置通知
               aop:before：表示配置前置通知
                    method属性：用于指定Logger类中哪个方法是前置通知
                    pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强
</code></pre>
<h2 id="切入点表达式的写法"><a href="#切入点表达式的写法" class="headerlink" title="切入点表达式的写法"></a>切入点表达式的写法</h2><pre><code class="xml">切入点表达式的写法：
                关键字：execution(表达式)
                表达式：
                    访问修饰符  返回值  包名.包名.包名...类名.方法名(参数列表)
                标准的表达式写法：
                    public void com.itheima.service.impl.AccountServiceImpl.saveAccount()
                访问修饰符可以省略
                    void com.itheima.service.impl.AccountServiceImpl.saveAccount()
                返回值可以使用通配符，表示任意返回值
                    * com.itheima.service.impl.AccountServiceImpl.saveAccount()
                包名可以使用通配符，表示任意包。但是有几级包，就需要写几个*.
                    * *.*.*.*.AccountServiceImpl.saveAccount())
                包名可以使用..表示当前包及其子包
                    * *..AccountServiceImpl.saveAccount()
                类名和方法名都可以使用*来实现通配
                    * *..*.*()
                参数列表：
                    可以直接写数据类型：
                        基本类型直接写名称           int
                        引用类型写包名.类名的方式   java.lang.String
                    可以使用通配符表示任意类型，但是必须有参数
                    可以使用..表示有无参数均可，有参数可以是任意类型
                全通配写法：
                    * *..*.*(..)

                实际开发中切入点表达式的通常写法：
                    切到业务层实现类下的所有方法
                        * com.itheima.service.impl.*.*(..)
                
                
    &lt;bean id=&quot;logger&quot; class=&quot;com.itheima.utils.Logger&quot;&gt;&lt;/bean&gt;

    &lt;!--配置AOP--&gt;
    &lt;aop:config&gt;
        &lt;!--配置切面 --&gt;
        &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;
            &lt;!-- 配置通知的类型，并且建立通知方法和切入点方法的关联--&gt;
            &lt;aop:before method=&quot;printLog&quot; pointcut=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:before&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
</code></pre>
<h2 id="Aop通知的四种类型"><a href="#Aop通知的四种类型" class="headerlink" title="Aop通知的四种类型"></a>Aop通知的四种类型</h2><p>基于XML的aop配置</p>
<pre><code class="xml">    &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;


    &lt;!-- 配置Logger类 --&gt;
    &lt;bean id=&quot;logger&quot; class=&quot;com.itheima.utils.Logger&quot;&gt;&lt;/bean&gt;

    &lt;!--配置AOP--&gt;
    &lt;aop:config&gt;
        &lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容
              此标签写在aop:aspect标签内部只能当前切面使用。
              它还可以写在aop:aspect外面，此时就变成了所有切面可用
          --&gt;
        &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;!--配置切面 --&gt;
        &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;
            &lt;!-- 配置前置通知：在切入点方法执行之前执行
            &lt;aop:before method=&quot;beforePrintLog&quot; pointcut-ref=&quot;pt1&quot; &gt;&lt;/aop:before&gt;--&gt;

            &lt;!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个
            &lt;aop:after-returning method=&quot;afterReturningPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-returning&gt;--&gt;

            &lt;!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个
            &lt;aop:after-throwing method=&quot;afterThrowingPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-throwing&gt;--&gt;

            &lt;!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行
            &lt;aop:after method=&quot;afterPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after&gt;--&gt;

            &lt;!-- 配置环绕通知 详细的注释请看Logger类中--&gt;
            &lt;aop:around method=&quot;aroundPringLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:around&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;


    环绕通知
     * 问题：
     *      当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。
     * 分析：
     *      通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。
     * 解决：
     *      Spring框架为我们提供了一个接口：ProceedingJoinPoint。()，此方法就相当于明确调用切入点方法。
     *      该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。
     *
     * spring中的环绕通知：
     *      它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。
     
     
        public Object aroundPringLog(ProceedingJoinPoint pjp)&#123;
        Object rtValue = null;
        try&#123;
            Object[] args = pjp.getArgs();//得到方法执行所需的参数

            System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。前置&quot;);

            rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法）

            System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。后置&quot;);

            return rtValue;
        &#125;catch (Throwable t)&#123;
            System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。异常&quot;);
            throw new RuntimeException(t);
        &#125;finally &#123;
            System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。最终&quot;);
        &#125;
    &#125;
</code></pre>
<h2 id="Spring注解的AOP配置"><a href="#Spring注解的AOP配置" class="headerlink" title="Spring注解的AOP配置"></a>Spring注解的AOP配置</h2><pre><code class="java">@Component(&quot;logger&quot;)
@Aspect//表示当前类是一个切面类
public class Logger &#123;
    @Pointcut(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)
    private void pt1()&#123;&#125;

    /**
     * 前置通知
     */
    @Before(&quot;pt1()&quot;)
    public  void beforePrintLog()&#123;
        System.out.println(&quot;前置通知Logger类中的beforePrintLog方法开始记录日志了。。。&quot;);
    &#125;

    /**
     * 后置通知
     */
    @AfterReturning(&quot;pt1()&quot;)
    public  void afterReturningPrintLog()&#123;
        System.out.println(&quot;后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。&quot;);
    &#125;
    /**
     * 异常通知
     */
    @AfterThrowing(&quot;pt1()&quot;)
    public  void afterThrowingPrintLog()&#123;
        System.out.println(&quot;异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。&quot;);
    &#125;

    /**
     * 最终通知
     */
    @After(&quot;pt1()&quot;)
    public  void afterPrintLog()&#123;
        System.out.println(&quot;最终通知Logger类中的afterPrintLog方法开始记录日志了。。。&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="注解的方式实现环绕增强"><a href="#注解的方式实现环绕增强" class="headerlink" title="注解的方式实现环绕增强"></a>注解的方式实现环绕增强</h2><pre><code class="java">@Component(&quot;logger&quot;)
@Aspect//表示当前类是一个切面类
public class Logger &#123;
    @Pointcut(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)
    private void pt1()&#123;&#125;
    
    @Around(&quot;pt1()&quot;)
    public Object aroundPringLog(ProceedingJoinPoint pjp)&#123;
        Object rtValue = null;
        try&#123;
            Object[] args = pjp.getArgs();//得到方法执行所需的参数

            System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。前置&quot;);

            rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法）

            System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。后置&quot;);

            return rtValue;
        &#125;catch (Throwable t)&#123;
            System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。异常&quot;);
            throw new RuntimeException(t);
        &#125;finally &#123;
            System.out.println(&quot;Logger类中的aroundPringLog方法开始记录日志了。。。最终&quot;);
        &#125;
    &#125;
</code></pre>
<h2 id="注解的方式aop环绕增强启动类"><a href="#注解的方式aop环绕增强启动类" class="headerlink" title="注解的方式aop环绕增强启动类"></a>注解的方式aop环绕增强启动类</h2><pre><code class="java">@EnableAspectJautoProxy
@Configuration
@ComponentScan(basePackage=&quot;com.eeee&quot;)
/**
 * 使用Junit单元测试：测试我们的配置
 */
@RunWith(SpringJUnit4ClassRunner.class)
public class AccountServiceTest &#123;
        @Autowired
    private  IAccountService as;

    @Test
    public void testTransfer()&#123;
        as.transfer(&quot;aaa&quot;,&quot;bbb&quot;,100f);
    &#125;
&#125;
</code></pre>
<h1 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h1><h2 id="Spring中的jdbcTemlate以及Spring事务控制"><a href="#Spring中的jdbcTemlate以及Spring事务控制" class="headerlink" title="Spring中的jdbcTemlate以及Spring事务控制"></a>Spring中的jdbcTemlate以及Spring事务控制</h2><p>JDBCTemplate<br>spring.core包下的工具类</p>
<p>JDBCDaoSupper  自己定义一个公共类<br>抽取dao层的公共代码<br>xml方式注入方式    可以使用继承的方式来减少重复的代码<br>使用注解的方式     就直接autowired就行</p>
<p>如果使用了spring中的jdbcdaosupper类<br>再使用注解的方式注入就变得麻烦了</p>
<h2 id="注解的方式实现aop环境配置"><a href="#注解的方式实现aop环境配置" class="headerlink" title="注解的方式实现aop环境配置"></a>注解的方式实现aop环境配置</h2><pre><code class="xml">   &lt;!--开启spring对注解AOP的支持--&gt;
    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
</code></pre>
<h2 id="基于XML的声明式事务控制配置步骤"><a href="#基于XML的声明式事务控制配置步骤" class="headerlink" title="基于XML的声明式事务控制配置步骤"></a>基于XML的声明式事务控制配置步骤</h2><h3 id="1、配置事务管理器"><a href="#1、配置事务管理器" class="headerlink" title="1、配置事务管理器"></a>1、配置事务管理器</h3><h3 id="2、配置事务的通知"><a href="#2、配置事务的通知" class="headerlink" title="2、配置事务的通知"></a>2、配置事务的通知</h3><p>此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的<br>使用 tx:advice 标签配置事务通知</p>
<p><strong>属性</strong>：</p>
<p><strong>id</strong>：给事务通知起一个唯一标识</p>
<p><strong>transaction-manager</strong>：给事务通知提供一个事务管理器引用</p>
<h3 id="3、配置AOP中的通用切入点表达式"><a href="#3、配置AOP中的通用切入点表达式" class="headerlink" title="3、配置AOP中的通用切入点表达式"></a>3、配置AOP中的通用切入点表达式</h3><h3 id="4、建立事务通知和切入点表达式的对应关系"><a href="#4、建立事务通知和切入点表达式的对应关系" class="headerlink" title="4、建立事务通知和切入点表达式的对应关系"></a>4、建立事务通知和切入点表达式的对应关系</h3><h3 id="5、配置事务的属性"><a href="#5、配置事务的属性" class="headerlink" title="5、配置事务的属性"></a>5、配置事务的属性</h3><p>是在事务的通知tx:advice标签的内部</p>
<pre><code class="xml">&lt;!-- 配置事务管理器 --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
 &lt;!-- 配置事务的通知--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    
&lt;!-- 配置事务的属性
                isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。
                propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。
                read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。
                timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。
                rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。
                no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。
        --&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&gt;
            &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;&gt;&lt;/tx:method&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

 &lt;!-- 配置aop--&gt;
    &lt;aop:config&gt;
        &lt;!-- 配置切入点表达式--&gt;
        &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;!--建立切入点表达式和事务通知的对应关系 --&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:advisor&gt;
    &lt;/aop:config&gt;
</code></pre>
<h2 id="基于注解配置事务管理器"><a href="#基于注解配置事务管理器" class="headerlink" title="基于注解配置事务管理器"></a>基于注解配置事务管理器</h2><pre><code class="xml"> &lt;!-- 配置数据源--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;1234&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;!-- spring中基于XML的声明式事务控制配置步骤
        1、配置事务管理器
        2、配置事务的通知
                此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的
                使用tx:advice标签配置事务通知
                    属性：
                        id：给事务通知起一个唯一标识
                        transaction-manager：给事务通知提供一个事务管理器引用
        3、配置AOP中的通用切入点表达式
        4、建立事务通知和切入点表达式的对应关系
        5、配置事务的属性
               是在事务的通知tx:advice标签的内部
     --&gt;
     
    &lt;!-- 配置事务管理器 --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;!-- 配置事务的通知--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    
        &lt;!-- 配置事务的属性
                isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。
                propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。
                read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。
                timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。
                rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。
                no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。
        --&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&gt;
            &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;&gt;&lt;/tx:method&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!-- 配置aop--&gt;
    &lt;aop:config&gt;
        &lt;!-- 配置切入点表达式--&gt;
        &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;!--建立切入点表达式和事务通知的对应关系 --&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:advisor&gt;
    &lt;/aop:config&gt;
</code></pre>
<h3 id="在你的业务层加上-Transactional注解"><a href="#在你的业务层加上-Transactional注解" class="headerlink" title="在你的业务层加上@Transactional注解"></a>在你的业务层加上@Transactional注解</h3><pre><code class="java">@Service(&quot;accountService&quot;)
@Transactional(propagation= Propagation.SUPPORTS,readOnly=true)//只读型事务的配置
public class AccountServiceImpl implements IAccountService&#123;
    
&#125;
</code></pre>
<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><pre><code class="java">@Configuration
@ComponentScan(&quot;com.itheima&quot;)
@Import(&#123;JdbcConfig.class,TransactionConfig.class&#125;)
@PropertySource(&quot;jdbcConfig.properties&quot;)
@EnableTransactionManagement  //EnableTransactionManagement
public class SpringConfiguration &#123;
&#125;

/**
 * 使用Junit单元测试：测试我们的配置
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes= SpringConfiguration.class)
public class AccountServiceTest &#123;

    @Autowired
    private  IAccountService as;

    @Test
    public  void testTransfer()&#123;
        as.transfer(&quot;aaa&quot;,&quot;bbb&quot;,100f);

    &#125;

&#125;
</code></pre>
<h2 id="编程式事物控制"><a href="#编程式事物控制" class="headerlink" title="编程式事物控制"></a>编程式事物控制</h2><p>没看，视频156-158</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">三山</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://star-light-star-bright.github.io/java/spring/spring-de-jian-dan-shi-yong-kuang-jia-er/">https://star-light-star-bright.github.io/java/spring/spring-de-jian-dan-shi-yong-kuang-jia-er/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">三山</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Spring/">
                                    <span class="chip bg-color">Spring</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/java/spring/spring-chang-yong-zhu-jie-zong-jie/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="Spring常用注解">
                        
                        <span class="card-title">Spring常用注解</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-01-16
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java%E6%A1%86%E6%9E%B6/" class="post-category">
                                    Java框架
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java%E6%A1%86%E6%9E%B6/">
                        <span class="chip bg-color">Java框架</span>
                    </a>
                    
                    <a href="/tags/Spring/">
                        <span class="chip bg-color">Spring</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/linux/shell-jiao-ben/java-jar-jiao-ben-mo-ban/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/4.jpg" class="responsive-img" alt="java -jar脚本模板">
                        
                        <span class="card-title">java -jar脚本模板</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-01-16
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Shell/" class="post-category">
                                    Shell
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Shell/">
                        <span class="chip bg-color">Shell</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2025</span>
            
            <a href="/about" target="_blank">三山</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
