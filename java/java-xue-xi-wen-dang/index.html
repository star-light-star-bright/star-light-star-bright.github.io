<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java基础学习文档, ZWHBlog">
    <meta name="description" content="JavaJava技术体系平台java SE 标准版
支持面向桌面级应用的java平台，提供了完整的java核心API
Java EE 企业版
为企业卡环境下的应用程序提供了一套解决方案。该技术体系中包含的技术如：Servlet、Jsp，主要">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    

    <title>Java基础学习文档 | ZWHBlog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.2.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">ZWHBlog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">ZWHBlog</div>
        <div class="logo-desc">
            
            这是我的博客网站
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/2.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java基础学习文档</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Java/">
                                <span class="chip bg-color">Java</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Java/" class="post-category">
                                Java
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-06-01
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Java技术体系平台"><a href="#Java技术体系平台" class="headerlink" title="Java技术体系平台"></a>Java技术体系平台</h2><pre><code>java SE 标准版
支持面向桌面级应用的java平台，提供了完整的java核心API
Java EE 企业版
为企业卡环境下的应用程序提供了一套解决方案。该技术体系中包含的技术如：Servlet、Jsp，主要针对Web应用程序开发。
Java Me 小型版
支持Java程序运行在移动终端上的平台，对Java API有所精简，并加入了针对移动终端的支持
</code></pre>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ol>
<li>JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在 JDK 中. </li>
<li>对于不同的平台，有不同的虚拟机。</li>
<li>Java 虚拟机机制屏蔽了底层运行平台的差别，实现了”一次编译，到处运行”</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220601193448967.png" alt="image-20220601193448967"></p>
<p>在内存里面只要分配了空间一定会对应一个内存地址。</p>
<h3 id="类和对象的内存分配机制"><a href="#类和对象的内存分配机制" class="headerlink" title="类和对象的内存分配机制"></a>类和对象的内存分配机制</h3><p>Java 内存的结构分析</p>
<ol>
<li>栈： 一般存放基本数据类型(局部变量) </li>
<li>堆： 存放对象(Cat cat , 数组等) </li>
<li>方法区：常量池(常量，比如字符串)， 类加载信息</li>
</ol>
<pre><code class="java">Person p = new Person();
p.name = &quot;jack&quot;;
p.age = 10

//先加载Person类信息，属性和方法，只会加载一次，在方法区中
//堆 开辟空间，并初始化默认值
//常量池中添加&quot;jack&quot;，堆 引用这个位置
//堆内存的基本类型变量直接修改值
//调用构造器，初始化
</code></pre>
<h2 id="JDK和JRE"><a href="#JDK和JRE" class="headerlink" title="JDK和JRE"></a>JDK和JRE</h2><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><ol>
<li>JDK 的全称(Java Development Kit Java 开发工具包) JDK &#x3D; JRE + java 的开发工具 [java, javac,javadoc,javap 等] </li>
<li>JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独 安装 JRE 了</li>
</ol>
<h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><ol>
<li>JRE(Java Runtime Environment Java 运行环境) JRE &#x3D; JVM + Java 的核心类库[类] </li>
<li>包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序， 计算机中只需要安装 JRE 即可</li>
</ol>
<h3 id="JDK、JRE-和-JVM-的包含关系"><a href="#JDK、JRE-和-JVM-的包含关系" class="headerlink" title="JDK、JRE 和 JVM 的包含关系"></a>JDK、JRE 和 JVM 的包含关系</h3><ol>
<li>JDK &#x3D; JRE + 开发工具集（例如 Javac,java 编译工具等)</li>
<li>JRE &#x3D; JVM + Java SE 标准类库（java 核心类库） </li>
<li>如果只想运行开发好的 .class 文件 只需要 JRE</li>
</ol>
<h3 id="下载安装JDK"><a href="#下载安装JDK" class="headerlink" title="下载安装JDK"></a>下载安装JDK</h3><h2 id="Java执行流程"><a href="#Java执行流程" class="headerlink" title="Java执行流程"></a>Java执行流程</h2><p><img src="/java/java-xue-xi-wen-dang/image-20220601193800191.png" alt="image-20220601193800191"></p>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><pre><code>\t ：一个制表位，实现对齐的功能
\n ：换行符
\\ ：一个\
\&quot; :一个&quot;
\&#39; ：一个&#39; 
\r :一个回车
</code></pre>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>被注释的文字，不会被jvm解释执行</p>
<p>单行注解</p>
<pre><code>单行注释 //
</code></pre>
<p>多行注解</p>
<pre><code>多行注释 /* */
</code></pre>
<p>文档注释</p>
<pre><code>文档注释 /** *
</code></pre>
<p>文档注解内容可以被JDK提供的工具javaDoc所解析，生成一套以网页文件形式体现的该程序的说明文档。</p>
<pre><code>javadoc -d 路径  -author -version 类名.java
</code></pre>
<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量相当于内存中一个数据存储空间的表示，你可以把变量看做是一个房间的门牌号，通过门牌号我们可以找到房 间，而通过变量名可以访问到变量(值)</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>java 数据类型分为两大类 基本数据类型， 引用类型 </li>
<li>基本数据类型有 8 中 数值型 [byte , short , int , long , float ,double] char , boolean </li>
<li>引用类型 [类，接口， 数组]</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用存储空间</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte[字节]</td>
<td>1字节</td>
<td>-128-127</td>
</tr>
<tr>
<td>short[短整型]</td>
<td>2字节</td>
<td>-32768-32767</td>
</tr>
<tr>
<td>int[整性]</td>
<td>4字节</td>
<td>-2147483648-2147483647</td>
</tr>
<tr>
<td>long[长整型]</td>
<td>8字节</td>
<td></td>
</tr>
<tr>
<td>float[单精度]</td>
<td>4字节</td>
<td>-3.4.3E38~3.403E38</td>
</tr>
<tr>
<td>Double[双精度]</td>
<td>8字节</td>
<td>-1.798E308~1.798E308</td>
</tr>
<tr>
<td>char[字节]</td>
<td>1字节</td>
<td>本质是整数，直接赋值整数会输出一个unicode字符，Ascll编码表</td>
</tr>
<tr>
<td>Boolean</td>
<td>1字节</td>
<td>只有ture和false两种，没有null</td>
</tr>
</tbody></table>
<p>bit最小存储单位，1 byte &#x3D; 8 bit</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>浮点数运算时存在精度的丢失，不要对运算过后的小数进行相等判断。默认使用Double，float会舍弃掉尾数部分。Math.abs()绝对值</p>
<h3 id="基本数据类型转化"><a href="#基本数据类型转化" class="headerlink" title="基本数据类型转化"></a>基本数据类型转化</h3><p>精度小的类型可以自动转换为精度大的数据类型，这个就是自动转化<br>$$<br>char–&gt;int–&gt;long–&gt;float–&gt;double<br>$$</p>
<p>$$<br>byte–&gt;short–&gt;int–&gt;long–&gt;float–&gt;double<br>$$</p>
<h4 id="类型转换注意事项"><a href="#类型转换注意事项" class="headerlink" title="类型转换注意事项"></a>类型转换注意事项</h4><p>精度大的数据类型赋值给精度小的数据类型时，就会报错，防止就会进行自动类型转换。</p>
<p>byte，short和char之间不会相互自动转换。</p>
<p>byte，short，char可以计算，在计算时首先转换为int类型。</p>
<h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><p>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成 精度降低或溢出,格外要注意。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>中文在线文档：<a target="_blank" rel="noopener" href="https://www.matools.com/">https://www.matools.com/</a></p>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>字符型存储到计算机中，将字符对应的码值（整数）找出来，</p>
<p>比如</p>
<p>存储<code>&#39;a&#39;==&gt;码值97==&gt;二进制（110 0001）==&gt;</code>存储</p>
<p>读取<code>二进制（110 0001）==&gt;97===&gt;&#39;a&#39;=&gt;显示</code></p>
<p>ASCLL编码表</p>
<p>一个字节表示，一个128个字符，只用了128个。缺点是不能表示所有字符</p>
<p>Unicode</p>
<p>两个字节表示，字母和汉字都是统一占用两个字节。Unicode码兼容ASCLL码。</p>
<p>缺点：浪费存储空间</p>
<p>utf-8编码表</p>
<p>大小可变的编码，字母使用1个字节，汉字使用3个字节。是Unicode的实现方式（改进）</p>
<p>gbk编码表</p>
<p>可以表示汉字，字母使用1个字节，汉字两个字节</p>
<p>gb2312 编码表</p>
<p>可以表示汉字，<code>gb2312&lt;gbk</code></p>
<p>big5编码表</p>
<p>繁体中文，台湾香港用的多</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。</p>
<ol>
<li>算术运算符</li>
<li>赋值运算符 </li>
<li>关系运算符 [比较运算符] </li>
<li>逻辑运算符 </li>
<li>位运算符 [需要二进制基础] </li>
<li>三元运算符</li>
</ol>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a><strong>算术运算符</strong></h3><p><img src="/java/java-xue-xi-wen-dang/image-20220607191149589.png" alt="image-20220607191149589"></p>
<h3 id="关系运算符-比较运算符"><a href="#关系运算符-比较运算符" class="headerlink" title="关系运算符 [比较运算符]"></a><strong>关系运算符 [比较运算符]</strong></h3><p><img src="/java/java-xue-xi-wen-dang/image-20220607191959206.png" alt="image-20220607191959206"></p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ol>
<li><p>短路与 &amp;&amp; ， 短路或 ||，取反 !</p>
</li>
<li><p>逻辑与 &amp;，逻辑或 |，^ 逻辑异或</p>
</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220607192458024.png" alt="image-20220607192458024"></p>
<pre><code>1) a&amp;b : &amp; 叫逻辑与：规则：当 a 和 b 同时为 true ,则结果为 true, 否则为 false 
2) a&amp;&amp;b : &amp;&amp; 叫短路与：规则：当 a 和 b 同时为 true ,则结果为 true,否则为 false 
3) a|b : | 叫逻辑或，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false 
4) a||b : || 叫短路或，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false 
5) !a : 叫取反，或者非运算。当 a 为 true, 则结果为 false, 当 a 为 false 是，结果为 true 
6) a^b: 叫逻辑异或，当 a 和 b 不同时，则结果为 true, 否则为 false
</code></pre>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>基本赋值运算符 <code>=</code></p>
<p>复合运算符 <code>+= </code>，<code>-= </code>，<code>*=</code> ，<code> /=</code> ，<code>%=</code> 等 ,</p>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>条件表达式 ? 表达式 1: 表达式</p>
<ol>
<li>如果条件表达式为 true，运算后的结果是表达式 1； </li>
<li>如果条件表达式为 false，运算后的结果是表达式 2；</li>
</ol>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><ol>
<li>包名：多单词组成时所有字母都小写：aaa.bbb.ccc &#x2F;&#x2F;比如 com.hsp.crm </li>
<li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰] 比如： TankShotGame </li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小 驼峰， 简称 驼峰法] 比如： tankShotGame </li>
<li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 比如 ：定义一个所得税率 TAX_RA</li>
</ol>
<h2 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h2><p>顺序控制（前向引用）</p>
<p>分支控制（if，else，switch）</p>
<p>循环控制（for，while，dowhile，多重循环）</p>
<p>break</p>
<p>continue</p>
<p>return</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。</p>
<h3 id="数组存储机制"><a href="#数组存储机制" class="headerlink" title="数组存储机制"></a>数组存储机制</h3><ol>
<li><p>基本数据类型赋值，这个值就是具体的数据，而且相互不影响。 </p>
<p>int n1 &#x3D; 2; int n2 &#x3D; n1;</p>
</li>
<li><p>数组在默认情况下是引用传递，赋的值是地址。 看一个案例，并分析数组赋值的内存图(重点,</p>
</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220608162448143.png" alt="image-20220608162448143"></p>
<h3 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h3><h3 id="数组添加-x2F-扩容"><a href="#数组添加-x2F-扩容" class="headerlink" title="数组添加&#x2F;扩容"></a>数组添加&#x2F;扩容</h3><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><h4 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h4><h4 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h4><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素 的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒</p>
<pre><code class="java">for( int i = 0; i &lt; arr.length - 1; i++) &#123;//外层循环是 4 次
for( int j = 0; j &lt; arr.length - 1 - i; j++) &#123;//4 次比较-3 次-2 次-1 次
//如果前面的数&gt;后面的数，就交换
if(arr[j] &gt; arr[j + 1]) &#123;
temp = arr[j];
arr[j] = arr[j+1];
arr[j+1] = temp;
&#125;
&#125;
</code></pre>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><h1 id="面向对象编程-基础部分"><a href="#面向对象编程-基础部分" class="headerlink" title="面向对象编程(基础部分)"></a>面向对象编程(基础部分)</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><ol>
<li>类是抽象的，概念的，代表一类事物,比如人类,猫类.., 即它是数据类型.</li>
</ol>
<ol start="2">
<li>对象是具体的，实际的，代表一个具体事物, 即 是实例. </li>
<li>类是对象的模板，对象是类的一个个体，对应一个实例</li>
</ol>
<h2 id="对象在内存中的存在形式"><a href="#对象在内存中的存在形式" class="headerlink" title="对象在内存中的存在形式"></a>对象在内存中的存在形式</h2><p>String 是 <code>引用类型</code>，放在方法区中</p>
<p>创建对象时在方法区中初始化类的属性和方法</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220608182943814.png" alt="image-20220608182943814"></p>
<p><strong>基本数据类型是值拷贝的行式</strong></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法的调用机制内存原理"><a href="#方法的调用机制内存原理" class="headerlink" title="方法的调用机制内存原理"></a>方法的调用机制内存原理</h3><ol>
<li><p><strong>main栈</strong>初始化Person对象</p>
</li>
<li><p>执行getSum方法</p>
</li>
<li><p>单独开辟一个独立的<strong>方法栈</strong>空间，执行getSum方法</p>
</li>
<li><p>将结果返回给main栈后，getSum方法的栈空间被释放。</p>
</li>
<li><p>继续执行后面的代码，全部执行完毕后，main栈继续执行，全部执行完毕后程序整个退出。（main栈代表整个程序）</p>
</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220610081802457.png" alt="image-20220610081802457"></p>
<h3 id="成员方法的好处"><a href="#成员方法的好处" class="headerlink" title="成员方法的好处"></a>成员方法的好处</h3><p>1）提高代码的复用性</p>
<ol start="2">
<li>可以将实现的细节封装起来，然后供其他用户来调用即可</li>
</ol>
<h3 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h3><p>遵循驼峰命名法，最好见名知义，表达出该功能的意思即可, 比如 得到两个数的和 getSum, 开发中按照规范</p>
<h2 id="成员方法传参机制"><a href="#成员方法传参机制" class="headerlink" title="成员方法传参机制"></a>成员方法传参机制</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>基本数据类型，传递是值拷贝的方式。形参的任何改变不影响实参。</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220610084335547.png" alt="image-20220610084335547"></p>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>引用类型传递的是地址，可以通过形参影响实参。</p>
<p>各个栈中的单独对象引用的是同一个对象地址，可以不同，互不影响。</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220610085026058.png" alt="image-20220610085026058"></p>
<h2 id="方法递归调用"><a href="#方法递归调用" class="headerlink" title="方法递归调用"></a>方法递归调用</h2><p>递归就是方法自己调用自己,每次调用时传入不同的变量.</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220610090640488.png" alt="image-20220610090640488"></p>
<h3 id="递归重要规则"><a href="#递归重要规则" class="headerlink" title="递归重要规则"></a>递归重要规则</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220610090704330.png" alt="image-20220610090704330"></p>
<h2 id="方法重载-OverLoad"><a href="#方法重载-OverLoad" class="headerlink" title="方法重载(OverLoad)"></a>方法重载(OverLoad)</h2><p>java 中允许同一个类中，多个同名方法的存在，但要求 形参列表不一致！</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>方法名称相同</p>
<p>形参列表：必须不同（类型，数量，顺序，至少有一项不一致）</p>
<p>返回类型无要求</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。</p>
<pre><code class="java">访问修饰符 返回类型 方法名(数据类型... 形参名) &#123;
&#125;
</code></pre>
<pre><code class="java">//接受任意数量的int值。
public int sum(int... nums) &#123;
//System.out.println(&quot;接收的参数个数=&quot; + nums.length);
int res = 0;
for(int i = 0; i &lt; nums.length; i++) &#123;
res += nums[i];
&#125;
return res;
&#125;
&#125;
</code></pre>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>可变参数可以为0哥或者任意多个</li>
<li>可变参数的实参可以为数组</li>
<li>可变参数的实质就是数组</li>
<li>可变参数可以和普通类型参数一起放在形参列表，但必须保证可变参数放在最后</li>
<li>一个形参列表中只能出现一个可变参数。</li>
</ol>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><img src="/java/java-xue-xi-wen-dang/image-20220610092940004.png" alt="image-20220610092940004"></p>
<h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>全局属性和局部变量可以重名，访问时遵循就近原则。</p>
</li>
<li><p>同一个作用域中，两个变量不能重名</p>
</li>
<li><p>属性声明周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量，生命周期较短，伴随着代码块的执行而创建，伴随着代码块的结束而销毁。</p>
</li>
<li><p>作用域范围不同</p>
<p>全局变量&#x2F;属性：可以被本类或其他类使用</p>
<p>局部变量：只能在本类中对应的方法调用</p>
</li>
<li><p>修饰符不同</p>
<p>全局变量&#x2F;属性：可以添加修饰符</p>
<p>局部变量不可以加修饰符</p>
</li>
</ol>
<h2 id="构造方法-x2F-构造器"><a href="#构造方法-x2F-构造器" class="headerlink" title="构造方法&#x2F;构造器"></a>构造方法&#x2F;构造器</h2><p>类的一种特殊方法，主要作用是完成对<strong>新对象的初始化</strong>，不是创建对象</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code class="java">[修饰符] 方法名(形参列表)&#123;
方法体;
&#125;
</code></pre>
<h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>构造器的修饰符可以默认， 也可以是 public protected private</li>
<li>构造器没有返回值</li>
<li>构造器名称和类名字必须一致</li>
<li>构造器是完成对象的初始化，并不是创建对象</li>
<li>如果没有定义构造器，系统会自动给类生成一个默认的无参构造器</li>
<li>一旦定义了自己的构造器，默认的构造器就覆盖了，不能使用默认的无参构造器了，需要显示定义</li>
</ol>
<h2 id="对象创建的流程分析"><a href="#对象创建的流程分析" class="headerlink" title="对象创建的流程分析"></a>对象创建的流程分析</h2><ol>
<li>方法区加载类信息（属性、方法）</li>
<li>分配堆空间创建对象</li>
<li>完成对象默认初始化</li>
<li>基本数据类型初始化</li>
<li>常量在方法区常量池，构造器初始化指向</li>
<li>返回对象地址给’p‘</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220610095235078.png" alt="image-20220610095235078"></p>
<h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p>java虚拟机会给每个对象分配this，代表当前对象。</p>
<p>那个对象调用，this就代表哪个对象。</p>
<h3 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>this 关键字可以用来访问<strong>本类</strong>的属性、方法、构造器 </p>
</li>
<li><p>this 用于区分当前<strong>类</strong>的属性和局部变量 </p>
</li>
<li><p>访问成员方法的语法：this.方法名(参数列表);</p>
</li>
<li><p>访问构造器语法：this(参数列表); 注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一 条语句）</p>
</li>
<li><p>this 不能在类定义的外部使用，只能在类定义的方法中使用。只能和<strong>类</strong>关联。</p>
</li>
</ol>
<h1 id="面向对象编程-中级部分"><a href="#面向对象编程-中级部分" class="headerlink" title="面向对象编程(中级部分)"></a>面向对象编程(中级部分)</h1><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><h2 id="IDEA-常用快捷键"><a href="#IDEA-常用快捷键" class="headerlink" title="IDEA 常用快捷键"></a>IDEA 常用快捷键</h2><ol>
<li>删除当前行, 默认是 ctrl + Y 自己配置 ctrl + d </li>
<li>复制当前行, 自己配置 ctrl + alt + 向下光标 </li>
<li>补全代码 alt + &#x2F;</li>
<li>添加注释和取消注释 ctrl + &#x2F; 【第一次是添加注释，第二次是取消注释】</li>
<li>导入该行需要的类 先配置 auto import , 然后使用 alt+enter 即可 </li>
<li>快速格式化代码 ctrl + alt + L </li>
<li>生成构造器等 alt + insert [提高开发效率] </li>
<li>查看一个类的层级关系 ctrl + H [学习继承后，非常有用] </li>
<li>将光标放在一个方法上，输入 ctrl + B , 可以定位到方法 [学继承后，非常有用] </li>
<li>自动的分配变量名 , 通过在后面加.var</li>
<li>ctrl+J，提示所有的快捷模板。</li>
</ol>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="包的作用"><a href="#包的作用" class="headerlink" title="包的作用"></a>包的作用</h3><ol>
<li><p>区分相同名字的类</p>
</li>
<li><p>很好的进行管理</p>
</li>
<li><p>控制访问范围</p>
</li>
</ol>
<h2 id="包的命名"><a href="#包的命名" class="headerlink" title="包的命名"></a>包的命名</h2><p><img src="/java/java-xue-xi-wen-dang/image-20220610120611399.png" alt="image-20220610120611399"></p>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>java 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）: </p>
<ol>
<li>公开级别:用 public 修饰,对外公开 </li>
<li>受保护级别:用 protected 修饰,对子类和同一个包中的类公开 </li>
<li>默认级别:没有修饰符号,向同一个包的类公开. </li>
<li>私有级别:用 private 修饰,只有类本身可以访问,不对外公开.</li>
</ol>
<h3 id="4中访问修饰符访问范围"><a href="#4中访问修饰符访问范围" class="headerlink" title="4中访问修饰符访问范围"></a>4中访问修饰符访问范围</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220610120901607.png" alt="image-20220610120901607"></p>
<h2 id="面向对象编程三大特征"><a href="#面向对象编程三大特征" class="headerlink" title="面向对象编程三大特征"></a>面向对象编程三大特征</h2><p>面向对象编程有三大特征：封装、继承和多态。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装就是把抽象出的数据和对数据的操作封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作，才能对数据进行操作。</p>
<h4 id="封装的理解和好处"><a href="#封装的理解和好处" class="headerlink" title="封装的理解和好处"></a>封装的理解和好处</h4><ol>
<li>隐藏实现细节</li>
<li>可以对数据进行验证，保证安全合理</li>
</ol>
<h4 id="封装实现步骤"><a href="#封装实现步骤" class="headerlink" title="封装实现步骤"></a>封装实现步骤</h4><ol>
<li>将属性私有化private</li>
<li>提供一个公共的set方法，用于对属性进行判断和赋值</li>
<li>提供一个公共的get方法，用于获取属性的值</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中 抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来 声明继承父类即可</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220610142503441.png" alt="image-20220610142503441"></p>
<h4 id="继承的语法"><a href="#继承的语法" class="headerlink" title="继承的语法"></a>继承的语法</h4><pre><code class="java">class 子类 extends 父类&#123;

&#125;
//1.子类会自动拥有父类定义的属性和方法
//2.父类又叫超类，基类
//3.子类又叫派生类
</code></pre>
<h4 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h4><ol>
<li>代码的复用性提高了</li>
<li>代码的扩展性和维护性提高了</li>
</ol>
<h4 id="继承的深入讨论-x2F-细节问题"><a href="#继承的深入讨论-x2F-细节问题" class="headerlink" title="继承的深入讨论&#x2F;细节问题"></a>继承的深入讨论&#x2F;细节问题</h4><ol>
<li>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访 问，要通过父类提供公共的方法去访问  </li>
<li>子类必须调用父类的构造器， 完成父类的初始化 </li>
<li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过</li>
<li>如果希望指定去调用父类的某个构造器，则显式的调用一下 : super（参数列表）</li>
<li>super 在使用时，必须放在构造器第一行(super 只能在构造器中使用)</li>
<li>super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li>
<li>java 所有类都是 Object 类的子类, Object 是所有类的基类</li>
<li>父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类)</li>
<li>子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制。</li>
<li>不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系</li>
</ol>
<h4 id="继承的本质分析（内存布局）"><a href="#继承的本质分析（内存布局）" class="headerlink" title="继承的本质分析（内存布局）"></a>继承的本质分析（内存布局）</h4><pre><code class="java">package com.hspedu.extend_;
/**
* 讲解继承的本质
*/
public class ExtendsTheory &#123;
public static void main(String[] args) &#123;
Son son = new Son();//内存的布局
//?-&gt; 这时请大家注意，要按照查找关系来返回信息
//(1) 首先看子类是否有该属性
//(2) 如果子类有这个属性，并且可以访问，则返回信息
//(3) 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..)
//(4) 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object... System.out.println(son.name);//返回就是大头儿子
//System.out.println(son.age);//返回的就是 39
//System.out.println(son.getAge());//返回的就是 39
System.out.println(son.hobby);//返回的就是旅游
&#125;
&#125;
class GrandPa &#123; //爷类
String name = &quot;大头爷爷&quot;;
String hobby = &quot;旅游&quot;;
&#125;
class Father extends GrandPa &#123;//父类
String name = &quot;大头爸爸&quot;;
private int age = 39;
public int getAge() &#123;
return age;
&#125;
&#125;
class Son extends Father &#123; //子类
String name = &quot;大头儿子&quot;;
&#125;
</code></pre>
<ol>
<li>先加载父类的信息（Object）</li>
<li>在加载二级父类（GrandPa）</li>
<li>在加载三级父类（Father）</li>
<li>最后加载自己的类（Son）</li>
<li>在堆内存开辟空间默认初始化，然后赋值</li>
<li>最后将地址返回给main栈中的对象。</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220610144741543.png" alt="image-20220610144741543"></p>
<h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><p>super 代表父类的引用，用于访问父类的属性、方法、构造器</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ol>
<li><p>访问父类的属性，但不能访问父类的private属性（super.属性名）</p>
</li>
<li><p>访问父类的方法，不能访问父类的private方法（super。方法名（参数列表））</p>
</li>
<li><p>访问父类的构造器（super(参数列表))，只能放在构造器的第一句，只能出现一次</p>
</li>
</ol>
<h4 id="super的好处"><a href="#super的好处" class="headerlink" title="super的好处"></a>super的好处</h4><ol>
<li>调用父类构造器的好处（分工明确，父类属性由父类初始化，子类的属性由子类初始化）</li>
<li>当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果！</li>
<li>super的访问不限于直接父类，如果爷爷类和本类中有相同的成员，也可以使用super区访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用super访问遵循就近原则。A-&gt;B-&gt;C，也需要遵守访问权限相关规定</li>
</ol>
<h4 id="super-和-this-的比较"><a href="#super-和-this-的比较" class="headerlink" title="super 和 this 的比较"></a>super 和 this 的比较</h4><p><img src="/java/java-xue-xi-wen-dang/image-20220610150344383.png" alt="image-20220610150344383"></p>
<h3 id="方法重写-x2F-覆盖-override"><a href="#方法重写-x2F-覆盖-override" class="headerlink" title="方法重写&#x2F;覆盖(override)"></a>方法重写&#x2F;覆盖(override)</h3><p>方法覆盖（重写）就是子类有一个方法，和父类的某个方法名称、返回类型、参数一样，那么子类的这个方法就覆盖了父类的方法。</p>
<h4 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>子类的方法形参列表，方法名称，要和父类方法的形参列表，方法名称完全一样</li>
<li>子类方法的返回类型和父类方法返回类型一样，或是父类返回类型的子类</li>
<li>子类方法不能缩小父类方法的访问权限</li>
</ol>
<h4 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h4><p><img src="/java/java-xue-xi-wen-dang/image-20220610151004410.png" alt="image-20220610151004410"></p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的！</p>
<ol>
<li>一个对象的编译类型和运行类型可以不一致</li>
<li>编译类型在定义对象时，就确定了，不能改变</li>
<li>运行类型是可以变化的</li>
<li>编译类型看定义时&#x3D;号的左边，运行类型看&#x3D;号的右边</li>
</ol>
<h4 id="多台具体体现在在哪些？"><a href="#多台具体体现在在哪些？" class="headerlink" title="多台具体体现在在哪些？"></a>多台具体体现在在哪些？</h4><ol>
<li><p>方法的多态</p>
<p>重载体现多态，重载体现多态</p>
</li>
<li><p>对象多态</p>
<p>对象的编译类型和运行类型可以不一致，编译类型在定义时，就确定。运行类型是可以动态变化的，可以通过getClass()来查看运行类型</p>
<p>编译类型看&#x3D;号左边，运行类型看&#x3D;号右边。</p>
</li>
</ol>
<h4 id="多态注意事项和细节讨论"><a href="#多态注意事项和细节讨论" class="headerlink" title="多态注意事项和细节讨论"></a>多态注意事项和细节讨论</h4><ul>
<li><p>多态的前提是：两个对象(类)存在继承关系</p>
</li>
<li><p>多态的向上转型</p>
</li>
</ul>
<p><img src="/java/java-xue-xi-wen-dang/image-20220610152047642.png" alt="image-20220610152047642"></p>
<ul>
<li>多态的向下转型</li>
</ul>
<p><img src="/java/java-xue-xi-wen-dang/image-20220610152057979.png" alt="image-20220610152057979"></p>
<ul>
<li>属性没有重写之说！属性的值看编译类型</li>
</ul>
<pre><code class="java">package com.hspedu.poly_.detail_;
public class PolyDetail02 &#123;
public static void main(String[] args) &#123;
//属性没有重写之说！属性的值看编译类型
Base base = new Sub();//向上转型
System.out.println(base.count);// ？ 看编译类型 10
Sub sub = new Sub();
System.out.println(sub.count);//? 20
&#125;
&#125;
class Base &#123; //父类
int count = 10;//属性
&#125;
class Sub extends Base &#123;//子类
int count = 20;//属性
&#125;
</code></pre>
<h4 id="instanceOf比较运算符"><a href="#instanceOf比较运算符" class="headerlink" title="instanceOf比较运算符"></a>instanceOf比较运算符</h4><p>用于判断对象的<strong>运行类型</strong>是否为 XX 类型或 XX 类型的子类型</p>
<pre><code class="java">public class PolyDetail03 &#123;
public static void main(String[] args) &#123;
BB bb = new BB();
System.out.println(bb instanceof BB);// true
System.out.println(bb instanceof AA);// true
//aa 编译类型 AA, 运行类型是 BB
//BB 是 AA 子类
AA aa = new BB();
System.out.println(aa instanceof AA);
//看的是运行类型（BB类型）
System.out.println(aa instanceof BB)//true;
Object obj = new Object();
System.out.println(obj instanceof AA);//false
String str = &quot;hello&quot;;
//System.out.println(str instanceof AA);
System.out.println(str instanceof Object);//true
&#125;
&#125;
class AA &#123;&#125; //父类
</code></pre>
<h4 id="java-的动态绑定机制（重要）"><a href="#java-的动态绑定机制（重要）" class="headerlink" title="java 的动态绑定机制（重要）"></a>java 的动态绑定机制（重要）</h4><ol>
<li>调用对象方法时，该方法与该对象的内存地址&#x2F;运行类型绑定</li>
<li>当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用。</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220610155346181.png" alt="image-20220610155346181"></p>
<pre><code class="java">package com.hspedu.poly_.dynamic_;
public class DynamicBinding &#123;
public static void main(String[] args) &#123;
//a 的编译类型 A, 运行类型 B
A a = new B();//向上转型
System.out.println(a.sum());//?40 -&gt; 方法注释之后：30
System.out.println(a.sum1());//?30-&gt; 方法注释之后：20
&#125;
&#125;

class A &#123;//父类
public int i = 10;
//动态绑定机制:
public int sum() &#123;//父类 sum()
return getI() 
&#125;
//属性没有动态绑定机制
public int sum1() &#123;//父类 sum1()
return i + 10;//10 + 10
&#125;
public int getI() &#123;//父类 getI
return i;
&#125;
&#125;

class B extends A &#123;//子类
public int i = 20;
// public int sum() &#123;
// return i + 20;
// &#125;
public int getI() &#123;//子类 getI()
return i;
&#125;
// public int sum1() &#123;
// return i + 10;
// &#125;
&#125;
</code></pre>
<h4 id="多态的应用"><a href="#多态的应用" class="headerlink" title="多态的应用"></a>多态的应用</h4><h4 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h4><p>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型</p>
<pre><code class="java">public class PloyArray &#123;
public static void main(String[] args) &#123;
//应用实例:现有一个继承结构如下：要求创建 1 个 Person 对象、
// 2 个 Student 对象和 2 个 Teacher 对象, 统一放在数组中，并调用每个对象 say 方法
Person[] persons = new Person[5];
persons[0] = new Person(&quot;jack&quot;, 20);
persons[1] = new Student(&quot;mary&quot;, 18, 100);
persons[2] = new Student(&quot;smith&quot;, 19, 30.1);
persons[3] = new Teacher(&quot;scott&quot;, 30, 20000);
persons[4] = new Teacher(&quot;king&quot;, 50, 25000);
//循环遍历多态数组，调用 say
for (int i = 0; i &lt; persons.length; i++) &#123;
//老师提示: person[i] 编译类型是 Person ,运行类型是是根据实际情况有 JVM 来判断
System.out.println(persons[i].say());//动态绑定机制
//这里大家聪明. 使用 类型判断 + 向下转型. if(persons[i] instanceof Student) &#123;//判断 person[i] 的运行类型是不是 Student
Student student = (Student)persons[i];//向下转型
student.study();
//小伙伴也可以使用一条语句 ((Student)persons[i]).study();
&#125; else if(persons[i] instanceof Teacher) &#123;
Teacher teacher = (Teacher)persons[i];
teacher.teach();
&#125; else if(persons[i] instanceof Person)&#123;
//System.out.println(&quot;你的类型有误, 请自己检查...&quot;);
&#125; else &#123;
System.out.println(&quot;你的类型有误, 请自己检查...&quot;);
&#125;
&#125;
&#125;
&#125;
</code></pre>
<h4 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h4><p>方法定义的形参类型为父类类型，实参类型允许为子类类型</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220610162515574.png" alt="image-20220610162515574"></p>
<h2 id="Object类详解"><a href="#Object类详解" class="headerlink" title="Object类详解"></a>Object类详解</h2><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals 方法"></a>equals 方法</h3><h4 id="x3D-x3D-和-equals-的对比"><a href="#x3D-x3D-和-equals-的对比" class="headerlink" title="&#x3D;&#x3D; 和 equals 的对比"></a>&#x3D;&#x3D; 和 equals 的对比</h4><ol>
<li><p>&#x3D;&#x3D;：既可以判断基本类型，有可以判断引用类型</p>
</li>
<li><p>&#x3D;&#x3D;：如果判断基本类型，判断的是值是否相等</p>
</li>
<li><p>&#x3D;&#x3D;：如果判断引用类型，判断的是，即判断是不是同一个对象</p>
</li>
<li><p>equals：是Object类中的方法，只能判断引用类型</p>
</li>
<li><p>默认判断是地址是否相等，子类往往重写该方法，用于判断内容是否相等。</p>
</li>
</ol>
<h4 id="如何重写-equals"><a href="#如何重写-equals" class="headerlink" title="如何重写 equals"></a>如何重写 equals</h4><pre><code class="java">//重写 Object 的 equals 方法
public boolean equals(Object obj) &#123;
//判断如果比较的两个对象是同一个对象，则直接返回 true
if(this == obj) &#123;
return true;
&#125;
//类型判断
if(obj instanceof Person) &#123;//是 Person，我们才比
//进行 向下转型, 因为我需要得到 obj 的 各个属性
Person p = (Person)obj;
return this.name.equals(p.name) &amp;&amp; this.age == p.age &amp;&amp; this.gender == p.gender;
&#125;
//如果不是 Person ，则直接返回 false
return false;
&#125;
</code></pre>
<h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode 方法"></a>hashCode 方法</h3><ol>
<li>提高具有哈希结构的容器的效率！</li>
<li>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！</li>
<li>两个引用，如果指向的是不同对象，则哈希值是不一样的</li>
<li>哈希值主要根据地址号来的！， 不能完全将哈希值等价于地址</li>
</ol>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString 方法"></a>toString 方法</h3><p>默认返回：全类名+@+哈希值的十六进制</p>
<ol>
<li><p>子类往往重写 toString 方法，用于返回对象的属性信息</p>
</li>
<li><p>重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式.</p>
</li>
<li><p>当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)； 就会默认调用 monster.toString()</p>
</li>
</ol>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize 方法"></a>finalize 方法</h3><ol>
<li>当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作</li>
<li>什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来 销毁该对象，在销毁该对象前，会先调用 finalize 方法</li>
<li>垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 System.gc() 主动触发垃圾回收机制</li>
</ol>
<p>老韩提示： 我们在实际开发中，几乎不会运用 finalize , 所以更多就是为了应付面试</p>
<pre><code class="java">//演示 Finalize 的用法
public class Finalize_ &#123;
public static void main(String[] args) &#123;
Car bmw = new Car(&quot;宝马&quot;);
//这时 car 对象就是一个垃圾,垃圾回收器就会回收(销毁)对象, 在销毁对象前，会调用该对象的 finalize 方法
//,程序员就可以在 finalize 中，写自己的业务逻辑代码(比如释放资源：数据库连接,或者打开文件..)
//,如果程序员不重写 finalize,那么就会调用 Object 类的 finalize, 即默认处理
//,如果程序员重写了 finalize, 就可以实现自己的逻辑
bmw = null;
System.gc();//主动调用垃圾回收器
System.out.println(&quot;程序退出了....&quot;);
&#125;
&#125;
class Car &#123;
private String name;
//属性, 资源。。
public Car(String name) &#123;
this.name = name;
&#125;
//重写 finalize
@Override
protected void finalize() throws Throwable &#123;
System.out.println(&quot;我们销毁 汽车&quot; + name );
System.out.println(&quot;释放了某些资源...&quot;);
&#125;
&#125;
</code></pre>
<h2 id="断点调试-debug"><a href="#断点调试-debug" class="headerlink" title="断点调试(debug)"></a>断点调试(debug)</h2><p>在断点调试过程中，是运行状态，是以对象的<strong>运行类型</strong>来执行的。</p>
<h3 id="断点调试介绍"><a href="#断点调试介绍" class="headerlink" title="断点调试介绍"></a>断点调试介绍</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220610165043839.png" alt="image-20220610165043839"></p>
<h3 id="断点调试的快捷键"><a href="#断点调试的快捷键" class="headerlink" title="断点调试的快捷键"></a>断点调试的快捷键</h3><p>F9(resume,执行到下一个断点) </p>
<p>F7：跳入方法内 </p>
<p>F8: 逐行执行代码. </p>
<p>shift+F8: 跳出方法</p>
<p>可以动态的下断点，在执行过程中也可以下。</p>
<h1 id="面向对象编程-高级部分"><a href="#面向对象编程-高级部分" class="headerlink" title="面向对象编程(高级部分)"></a>面向对象编程(高级部分)</h1><h2 id="Static关键字"><a href="#Static关键字" class="headerlink" title="Static关键字"></a>Static关键字</h2><p>Static静态变量被同一个类的所有对象共享。</p>
<p>Static变量在类加载的时候就生成了。没有创建对象也可以访问（遵循访问权限）。</p>
<h3 id="内变量内存布局"><a href="#内变量内存布局" class="headerlink" title="内变量内存布局"></a>内变量内存布局</h3><p>JDK8之前，静态域是在方法区的。</p>
<p>JDK8之后，静态域是放在堆中的。在class加载时，通过反射机制，在堆中生成一个class对象，static变量保存在class实例的尾部。</p>
<h3 id="类变量使用细节"><a href="#类变量使用细节" class="headerlink" title="类变量使用细节"></a>类变量使用细节</h3><ol>
<li><p>什么时候需要用类变量按我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量。</p>
</li>
<li><p>类变量与实例变量的区别</p>
<p>类变量是该类的所有对象共享的，而实例变量是每个对象独享的。</p>
</li>
<li><p>加上Static成为静态变量或者类变量，否则称为实例变量&#x2F;普通变量&#x2F;非静态变量</p>
</li>
<li><p>类变量可以通过类名。类变量或者对象名.类变量名来访问，但java设计者推荐我们使用类名.类变量名方式访问。【满足访问修饰符的访问权限和范围】</p>
</li>
<li><p>实例变量不能通过类名.类变量名 方式访问</p>
</li>
<li><p>类变量是在类加载时就初始化了，也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量了。</p>
</li>
<li><p>周期是随类的加载开始，随着类的消亡而销毁</p>
</li>
</ol>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>类方法也叫静态方法，<code>类名.类方法名</code> 调用</p>
<pre><code class="java">访问修饰符 static 数据返回类型 方法名()&#123;

&#125;
</code></pre>
<h4 id="类方法注意事项"><a href="#类方法注意事项" class="headerlink" title="类方法注意事项"></a>类方法注意事项</h4><ol>
<li><p>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区</p>
<p>类方法中无this的参数，static和类挂钩，和对象没关系了。</p>
<p>普通方法中隐含着this参数</p>
</li>
<li><p>类方法可以通过类名调用，也可以通过对象名调用</p>
</li>
<li><p>普通方法和对象有关，需要通过对象名调用，不能通过类名调用</p>
</li>
<li><p>类方法中不允许使用和对象有关的关键字，比如this和super，普通方法可以。</p>
</li>
<li><p>静态方法中，只能访问静态变量或静态方法</p>
</li>
<li><p>普通成员方法，及可以访问普通变量(方法)，也可以访问静态变量（方法）</p>
</li>
</ol>
<h2 id="深入理解-main-方法"><a href="#深入理解-main-方法" class="headerlink" title="深入理解 main 方法"></a>深入理解 main 方法</h2><p>main方法的形式：</p>
<pre><code class="java">public static void main(Static[] args)&#123;
&#125;
</code></pre>
<p><img src="/java/java-xue-xi-wen-dang/image-20220612095524793.png" alt="image-20220612095524793"></p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块又称为&#x3D;&#x3D;初始化块&#x3D;&#x3D;，属于类中的成员，类似于方法，讲逻辑语句封装在方法体中，通过{}包围起来</p>
<p>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，不通过对象或类显式调用，而是加载类时，或创建对象时&#x3D;&#x3D;隐式调用&#x3D;&#x3D;</p>
<h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code class="java">[修饰符]&#123;
代码
&#125;
</code></pre>
<ol>
<li><p>修饰符可选，要写也只能选static</p>
</li>
<li><p>代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块。</p>
</li>
<li><p>逻辑语句可以为任何逻辑语句</p>
</li>
</ol>
<h3 id="代码块的好处"><a href="#代码块的好处" class="headerlink" title="代码块的好处"></a>代码块的好处</h3><ol>
<li><p>相当于另一种形式构造器（对构造器的补充机制），可以做初始化操作。</p>
<p>&#x3D;&#x3D;普通代码块在构造器执行之前被调用，被创建一次，就会调用一次&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;静态代码块只会执行一次，在类加载时执行&#x3D;&#x3D;</p>
</li>
</ol>
<h3 id="代码块使用注意事项"><a href="#代码块使用注意事项" class="headerlink" title="代码块使用注意事项"></a>代码块使用注意事项</h3><ol>
<li><p>static代码块也叫静态代码块，作用是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行。</p>
</li>
<li><p>类什么时候被加载</p>
<ol>
<li>创建对象实例时（new）</li>
<li>创建子类对象实例，父类也被加载</li>
<li>使用类的静态成员时（静态属性，静态方法）</li>
</ol>
</li>
<li><p>普通的代码块，在创建对象实例时，会被隐式调用</p>
<p>被创建一次，就会调用一次</p>
<p>如果只是使用类的静态成员时，普通代码块并不会被执行</p>
</li>
<li><p>创建一个对象时，在一个类的调用顺序是：</p>
<ul>
<li>调用静态代码块和静态属性初始化（静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）</li>
<li>调用普通代码块和普通属性的初始化（普通代码块和普通初始化调用优先级一样，如果多个普通代码块和多个普通属性初始化，则按定义顺序调用）</li>
<li>最后调用构造方法</li>
</ul>
</li>
<li><p>构造器最前面其实隐含了super（）和调用普通代码块</p>
</li>
</ol>
<pre><code class="java">class A&#123;
public  A&#123;
1. super()//加载父类
2. 调用普通代码块
System.out.print（&quot;ok&quot;）
    &#125;
&#125;
</code></pre>
<ol start="6">
<li>创建子类对象时，<strong>调用顺序</strong>:<ol>
<li>父类的静态代码块和静态属性（按定义顺序调用）</li>
<li>子类的静态代码块和静态属性（按定义顺序调用）</li>
<li>父类的普通代码块和普通属性（按定义顺序调用）</li>
<li>父类的构造器</li>
<li>子类的普通代码块和普通属性（按定义顺序调用）</li>
<li>子类的构造器</li>
</ol>
</li>
<li>静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员</li>
</ol>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><ol>
<li>静态方法和属性的经典使用</li>
<li>设计模式是大量实践中总结和理论化之后优选的代码结构，编程风格，以及解决问题的思考方式</li>
</ol>
<h3 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h3><ol>
<li>所谓类的单例设计模式，就是采取一定的方法保证在整个软件系统中对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</li>
<li>单例模式有两种方式：1）饿汉式 2）懒汉式</li>
</ol>
<h3 id="单例模式实例"><a href="#单例模式实例" class="headerlink" title="单例模式实例"></a>单例模式实例</h3><ol>
<li>构造器私有化，防止new</li>
<li>类的内部创建对象</li>
<li>向外暴露一个静态的公共方法</li>
</ol>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><pre><code class="java">//有一个类， GirlFriend（饿汉式）
//只能有一个女朋友
class GirlFriend &#123;
private String name;
//为了能够在静态方法中，返回 gf 对象，需要将其修饰为 static
//對象，通常是重量級的對象, 餓漢式可能造成創建了對象，但是沒有使用. 
private static GirlFriend gf = new GirlFriend(&quot;小红红&quot;);
//如何保障我们只能创建一个 GirlFriend 对象
//步骤[单例模式-饿汉式]
//1. 将构造器私有化
//2. 在类的内部直接创建对象(该对象是 static)
//3. 提供一个公共的 static 方法，返回 gf 对象
private GirlFriend(String name) &#123;
System.out.println(&quot;構造器被調用.&quot;);
this.name = name;
&#125;
public static GirlFriend getInstance() &#123;
return gf;
&#125;
@Override
public String toString() &#123;
return &quot;GirlFriend&#123;&quot; +
&quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
&#39;&#125;&#39;;
&#125;
&#125;
</code></pre>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><pre><code class="java">//使用單例模式
class Cat &#123;
private String name;
public static int n1 = 999;
private static Cat cat ; //默認是 null
//步驟
//1.仍然構造器私有化
//2.定義一個 static 靜態屬性對象
//3.提供一個 public 的 static 方法，可以返回一個 Cat 對象
//4.懶漢式，只有當用戶使用 getInstance 時，才返回 cat 對象, 後面再次調用時，會返回上次創建的 cat 對象
// 從而保證了單例
private Cat(String name) &#123;
System.out.println(&quot;構造器調用...&quot;);
this.name = name;
&#125;
    
public static Cat getInstance() &#123;
if(cat == null) &#123;//如果還沒有創建 cat 對象
cat = new Cat(&quot;小可愛&quot;);
&#125;
return cat;
&#125;
    
@Override
public String toString() &#123;
return &quot;Cat&#123;&quot; +
&quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
&#39;&#125;&#39;;
&#125;
&#125;
</code></pre>
<h3 id="饿汉式-VS-懒汉式"><a href="#饿汉式-VS-懒汉式" class="headerlink" title="饿汉式 VS 懒汉式"></a>饿汉式 VS 懒汉式</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220612105855835.png" alt="image-20220612105855835"></p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final中文意思：最终的，最后的</p>
<p>final可以修饰类、属性、方法、局部变量</p>
<p>某些情况下有以下需求，就会使用到final</p>
<ol>
<li>不希望类被继承时，使用final</li>
<li>不希望父类的某个方法被子类重写（override），使用final</li>
<li>不希望类的某个属性值被修改，使用final</li>
<li>不希望某个局部变量被修改，使用final</li>
</ol>
<h3 id="final注意事项"><a href="#final注意事项" class="headerlink" title="final注意事项"></a>final注意事项</h3><ol>
<li>final修饰的属性又叫常量，一般用XX_XX_XX命名</li>
<li>final修饰的属性在定义是，必须赋初值，并以后不能修改，赋值位置可以在以下位置：<ol>
<li>定义时</li>
<li>构造器</li>
<li>代码块</li>
</ol>
</li>
<li>如果final修饰的属性是静态的，则初始化的位置只能是<ol>
<li>定义时</li>
<li>静态代码块，不能再构造器中赋值</li>
</ol>
</li>
<li>final类不能被继承，但可以实例化对象</li>
<li>如果类不是final类，但含有final方法，该方法不能被重写，但可以被继承。</li>
<li>一般来说，一个类已经是final类了，就没有必要再将方法修饰成final方法</li>
<li>final不能修饰构造方法（即构造器）</li>
<li>final和static往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化。</li>
<li>包装类都是final，String也是final</li>
</ol>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>当父类的某些方法，需要声明，但不确定如何实现，可以将其声明为抽象方法，那么这个类就是抽象类。</p>
<pre><code class="java">abstract class Animal &#123;
private String name;
public Animal(String name) &#123;
this.name = name;
&#125;
//思考：这里 eat 这里你实现了，其实没有什么意义
//即： 父类方法不确定性的问题
//===&gt; 考虑将该方法设计为抽象(abstract)方法
//===&gt; 所谓抽象方法就是没有实现的方法
//===&gt; 所谓没有实现就是指，没有方法体
//===&gt; 当一个类中存在抽象方法时，需要将该类声明为 abstract 类
//===&gt; 一般来说，抽象类会被继承，有其子类来实现抽象方法. // public void eat() &#123;
// System.out.println(&quot;这是一个动物，但是不知道吃什么..&quot;);
// &#125;
public abstract void eat() ;
&#125;
</code></pre>
<h3 id="抽象类语法"><a href="#抽象类语法" class="headerlink" title="抽象类语法"></a>抽象类语法</h3><pre><code class="java">abstract class Animal&#123;
String name;
int age;
    abstract public void cry();
&#125;
</code></pre>
<ol>
<li>用abstract 关键字修饰一个类，这个类就叫抽象类</li>
<li>用abstract关键字修饰一个方法，这个方法就叫抽象方法</li>
<li>抽象类的价值更多在于设计，设计者设计好后，让子类继承并实现</li>
<li>抽象类，在框架和设计模式使用较多。</li>
</ol>
<h3 id="抽象类注意事项"><a href="#抽象类注意事项" class="headerlink" title="抽象类注意事项"></a>抽象类注意事项</h3><ol>
<li><p>抽象类<strong>不能被实例化</strong></p>
</li>
<li><p>抽象类不一定要包含abstract方法，也就是说抽象类可以没有抽象方法，还可以有实现方法</p>
</li>
<li><p>一旦类包含了abstract方法，则这个类必须声明为abstract</p>
</li>
<li><p>abstract只能修饰类和方法，不能修饰属性和其他</p>
</li>
<li><p>抽象类可以有任意成员，非抽象方法，构造器，静态属性等等</p>
</li>
<li><p>抽象方法不能有主体（方法体）</p>
</li>
<li><p>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非他自己也声明为abstract类</p>
</li>
<li><p>抽象方法不能使用 private、final 和 static 来修饰，因为这些关键字都是和重写相违背的</p>
</li>
</ol>
<h2 id="模板设计模式-抽象类最佳实践"><a href="#模板设计模式-抽象类最佳实践" class="headerlink" title="模板设计模式-抽象类最佳实践"></a>模板设计模式-抽象类最佳实践</h2><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展，改造，当子类总体上汇保留抽象类的行为方式</p>
<h3 id="模板设计模式解决的问题"><a href="#模板设计模式解决的问题" class="headerlink" title="模板设计模式解决的问题"></a>模板设计模式解决的问题</h3><ol>
<li>当一部分实现是确定的，一部分实现不确定时。可以把不确定的部分暴露出去，让子类实现。</li>
<li>抽象父类，父类提供多个子类通用方法，并把一个或多个方法留给子类实现，就是一种模板模式。</li>
</ol>
<h3 id="模板模式实例"><a href="#模板模式实例" class="headerlink" title="模板模式实例"></a>模板模式实例</h3><pre><code class="java">abstract public class Template &#123; //抽象类-模板设计模式
public abstract void job();//抽象方法
public void calculateTime() &#123;//实现方法，调用 job 方法
//得到开始的时间
long start = System.currentTimeMillis();
job(); //动态绑定机制
//得的结束的时间
long end = System.currentTimeMillis();
System.out.println(&quot;任务执行时间 &quot; + (end - start));
&#125;
&#125;



public class AA extends Template &#123;
 @Override
public void job() &#123; //实现 Template 的抽象方法 job
long num = 0;
for (long i = 1; i &lt;= 800000; i++) &#123;
num += i;
&#125;   
&#125;
    
    
public class BB extends Template&#123;
public void job() &#123;//这里也去，重写了 Template 的 job 方法
long num = 0;
for (long i = 1; i &lt;= 80000; i++) &#123;
num *= i;
&#125;
&#125;
&#125;
    
    
public class TestTemplate &#123;
public static void main(String[] args) &#123;
AA aa = new AA();
aa.calculateTime(); //这里还是需要有良好的 OOP 基础，对多态
BB bb = new BB();
bb.calculateTime();
&#125;
&#125;
</code></pre>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是更加抽象的抽象类，抽象类里的方法可以有方法体，接口里的所有方法都没有方法体。接口体现了程序设计的多肽和高内聚低耦合的设计思想。</p>
<p>特别说明：JDK8.0之后的接口类可以有<strong>静态方法</strong>，<strong>默认方法</strong>（default修饰方法），也就是说接口可以有方法的具体实现。JDK7.0之前接口的所有方法都没有方法体。</p>
<h3 id="接口注意事项"><a href="#接口注意事项" class="headerlink" title="接口注意事项"></a>接口注意事项</h3><ol>
<li><p>接口不能被实例化</p>
</li>
<li><p>接口中所有方法都是public方法，就口中抽象方法，不用abstract修饰</p>
</li>
<li><p>一个普通类实现接口，就必须将接口的所有方法都实现</p>
</li>
<li><p>抽象类实现接口，可以不用实现接口的方法</p>
</li>
<li><p>一个类可以实现多个接口</p>
</li>
<li><p>接口的属性，只能是final的，而且是public static final 修饰符。</p>
<p>例如：int n1 &#x3D; 10; &#x2F;&#x2F;等价 public static final int n1 &#x3D; 10</p>
</li>
<li><p>接口中属性的访问形式：接口名.属性名</p>
</li>
<li><p>接口不能继承其他类，但是可以继承多个别的接口</p>
</li>
<li><p>接口修饰符只能是public和默认，这点和类的修饰符是一样的</p>
</li>
</ol>
<h2 id="接口-VS-抽象类（继承类）"><a href="#接口-VS-抽象类（继承类）" class="headerlink" title="接口 VS 抽象类（继承类）"></a>接口 VS 抽象类（继承类）</h2><ul>
<li>解决的问题不同</li>
</ul>
<p>继承的价值在于：解决代码的复用性和可维护性</p>
<p>接口的价值在于：设计，设计好各种规范（方法），让其它类去实现这个方法。及更加的灵活。</p>
<ul>
<li>接口比继承更加灵活</li>
</ul>
<p>接口比继承更加灵活，继承是is-a的关系，而接口只需要满足like -a的关系</p>
<ul>
<li>接口一定程度上实现代码解耦【接口规范性+动态绑定机制】</li>
</ul>
<ol>
<li>多态参数</li>
<li>多态数组</li>
<li>接口存在多态传递现象。</li>
</ol>
<pre><code class="java">/**
* 演示多态传递现象
*/
public class InterfacePolyPass &#123;
public static void main(String[] args) &#123;
//接口类型的变量可以指向，实现了该接口的类的对象实例
IG ig = new Teacher();
//如果 IG 继承了 IH 接口，而 Teacher 类实现了 IG 接口
//那么，实际上就相当于 Teacher 类也实现了 IH 接口. //这就是所谓的 接口多态传递现象. IH ih = new Teacher();
&#125;
&#125;
interface IH &#123;
void hi();
&#125;
interface IG extends IH&#123; &#125;
class Teacher implements IG &#123;
@Override
public void hi() &#123;
&#125;
&#125;
</code></pre>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类被称为内部类（inner class），嵌套其他类的类称为外部类（outer class）。是我们类的第五大成员【属性，方法，构造器，代码块，内部类】内部类的最大特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。</p>
<p>注意，内部类是学习的难点，同时也是重点，底层源码有大量的内部类</p>
<h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code class="java">class Outer&#123;//外部类
    class intter&#123;//内部类
    
    &#125;
&#125;
</code></pre>
<h3 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h3><p>如果定义类在局部位置(方法中&#x2F;代码块) :</p>
<p>(1) 局部内部类（有类名） </p>
<p>(2) 匿名内部类（没有类名，重点） </p>
<p>定义在成员位置 </p>
<p>(1) 成员内部类 （没用static修饰）</p>
<p>(2) 静态内部类（使用static修饰）</p>
<h3 id="局部内部类的使用"><a href="#局部内部类的使用" class="headerlink" title="局部内部类的使用"></a>局部内部类的使用</h3><ol>
<li><p>可以直接访问外部类的所有成员，包含私有</p>
</li>
<li><p>不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量不能使用访问修饰符。但是可以使用final修饰，因为局部变量也可以使用final</p>
</li>
<li><p>作用域：仅仅在定义它的方法或代码块中。</p>
</li>
<li><p>局部内部类–》访问–》外部类的成员【访问方式：直接访问】</p>
</li>
<li><p>外部类–》访问–》局部内部类的成员</p>
<p>访问方式：创建对象，在访问（必须在作用域内）</p>
<p>记住：</p>
<ol>
<li><p>局部内部类定义在方法中&#x2F;代码块</p>
</li>
<li><p>作用于在方法体或者代码块中 </p>
</li>
<li><p>本质仍然是一个类</p>
</li>
</ol>
</li>
<li><p>外部其他类–&gt;不能访问–&gt;局部内部类（因为局部内部类地位是一个局部变量）</p>
</li>
<li><p>如果外部类和局部内部类的成员重名，遵循就近原则，如果想要访问外部类的成员，可以使用（外部类名.this.成员）去访问</p>
</li>
</ol>
<h3 id="匿名内部类的使用"><a href="#匿名内部类的使用" class="headerlink" title="匿名内部类的使用"></a>匿名内部类的使用</h3><ol>
<li><p>本质还是类、内部类，该类没有名字，同时还是一个对象</p>
<p>说明：匿名内部类是定在外部类的局部位置，比如方法中，并且没有类名</p>
</li>
<li><p>匿名内部类语法</p>
</li>
</ol>
<pre><code class="java">new 类或者接口（参数列表）&#123;

&#125;
</code></pre>
<ol start="2">
<li>匿名内部类的既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，对前面代码分析可以看出这个特点，因此可以调用匿名内部类方法。</li>
<li>可以直接访问外部类的所有成员，包含私有的</li>
<li>不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量不能使用访问修饰符。</li>
<li>作用域：仅仅在定义它的方法或代码块中。</li>
<li>匿名内部类–》访问–》外部类的成员【访问方式：直接访问】</li>
<li>外部其他类–》不能访问–》匿名内部类（匿名内部类地位是一个局部变量）</li>
<li>外部类和匿名内部类成员重名时，匿名内部类访问遵循就近原则。如果想要访问外部类的成员，可以使用（外部类名.this.成员）去访问</li>
</ol>
<h4 id="匿名内部类实例"><a href="#匿名内部类实例" class="headerlink" title="匿名内部类实例"></a>匿名内部类实例</h4><p>匿名类的名称是调用匿名类的外部类名称+$1，如果有多个匿名类则累加值</p>
<h5 id="基于接口的匿名内部类"><a href="#基于接口的匿名内部类" class="headerlink" title="基于接口的匿名内部类"></a>基于接口的匿名内部类</h5><pre><code class="java">public class AnonymousInnerClass &#123;
    public static void main(String[] args) &#123;
        IA anony = new IA() &#123;

            @Override
            public void cry() &#123;
                System.out.println(&quot;匿名内部类&quot;);
            &#125;
        &#125;;
        anony.cry();
        //编译类型是：interface hsppedu.Homework.anonymousInnerhomework.IA
        System.out.println(&quot;编译类型是：&quot;+IA.class);
        //运行类型是:class hsppedu.Homework.anonymousInnerhomework.AnonymousInnerClass$1
        System.out.println(&quot;运行类型是:&quot;+anony.getClass());
    &#125;
&#125;

interface IA &#123;//接口
    public void cry();
&#125;
</code></pre>
<h5 id="基于类的匿名内部类"><a href="#基于类的匿名内部类" class="headerlink" title="基于类的匿名内部类"></a>基于类的匿名内部类</h5><pre><code class="java">public class AnonymousInnerClass &#123;
    public static void main(String[] args) &#123;
     Father anony = new Father(&quot;ff&quot;)&#123;
            @Override
            public void test() &#123;
                System.out.println(&quot;重写了test方法&quot;);
            &#125;
        &#125;;
        anony.test();
        //编译类型是：class hsppedu.Homework.anonymousInnerhomework.Father
        System.out.println(&quot;编译类型是：&quot;+Father.class);
        //运行类型是:class hsppedu.Homework.anonymousInnerhomework.AnonymousInnerClass$1
        System.out.println(&quot;运行类型是:&quot;+anony.getClass());
    &#125;
&#125;

class Father&#123;
    public Father(String name) &#123;//构造器
        System.out.println(&quot;接收到 name=&quot; + name);
    &#125;
    public void test() &#123;//方法
    &#125;
&#125;

//重写了test方法
//编译类型是：class hsppedu.Homework.anonymousInnerhomework.Father
//运行类型是:class hsppedu.Homework.anonymousInnerhomework.AnonymousInnerClass$1
</code></pre>
<h4 id="匿名内部类最佳实践"><a href="#匿名内部类最佳实践" class="headerlink" title="匿名内部类最佳实践"></a>匿名内部类最佳实践</h4><pre><code class="java">public class InnerClassExercise01 &#123;
public static void main(String[] args) &#123;
//当做实参直接传递，简洁高效
f1(new IL() &#123;
@Override
public void show() &#123;
System.out.println(&quot;这是一副名画~~...&quot;);
&#125;
&#125;);
    
//传统方法
f1(new Picture());
&#125;
    
//静态方法,形参是接口类型
public static void f1(IL il) &#123;
il.show();
&#125;
&#125;


//接口
interface IL &#123;
void show();
&#125;

//类-&gt;实现 IL =&gt; 编程领域 (硬编码)
class Picture implements IL &#123;
@Override
public void show() &#123;
System.out.println(&quot;这是一副名画 XX...&quot;);
&#125;
&#125;
</code></pre>
<pre><code class="java">public class InnerClassExercise01 &#123;
public static void main(String[] args) &#123;
//当做实参直接传递，简洁高效
f1(new IL() &#123;
@Override
public void show() &#123;
System.out.println(&quot;这是一副名画~~...&quot;);
&#125;
&#125;);
    
//传统方法
f1(new Picture());
&#125;
    
//静态方法,形参是接口类型
public static void f1(IL il) &#123;
il.show();
&#125;
&#125;


//接口
interface IL &#123;
void show();
&#125;

//类-&gt;实现 IL =&gt; 编程领域 (硬编码)
class Picture implements IL &#123;
@Override
public void show() &#123;
System.out.println(&quot;这是一副名画 XX...&quot;);
&#125;
&#125;
</code></pre>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类是<strong>定义在外部类的成员位置</strong>，并且没有static修饰</p>
<ol>
<li>可以直接访问外部类的所有成员，包含私有</li>
<li>可以添加任意访问修饰符（public,protected,默认,private）,因为他的地位就是一个成员。</li>
<li>作用域 MemberInnerClass01和外部类的其他成员一样，为整个类</li>
<li>成员内部类–&gt;访问–&gt;外部类成员【访问方式：直接访问】</li>
<li>外部类–&gt;访问–&gt;成员内部类【访问方式：创建对象，在访问】</li>
<li>外部其他类–&gt;访问–&gt;成员内部类</li>
<li>如果外部类和内部类的成员重名时，内部类访问，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问</li>
</ol>
<pre><code class="java">class  outer01&#123;
private int n1 = 10;
    class Innter01&#123;
        public void say()&#123;
        System.out.println(&quot;Outer01 n1&quot;+n1);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">//外部其他类使用内部类
outer01 outer01 = new outer01();
Innter01 innter01 = outer01.new Innter01();
</code></pre>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类是定义在外部类的成员位置上，并且<strong>有static修饰</strong></p>
<ol>
<li>可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员</li>
<li>可以添加任意访问修饰符（public、protected、默认、private）,因为他的地位就是一个成员</li>
<li>作用域：同其他的成员，为整个类体</li>
<li>静态内部类–&gt;访问–&gt;外部类【可以直接访问所有静态成员】</li>
<li>外部类–&gt;访问–&gt;静态内部类【创建对象，在访问】</li>
<li>外部其他类–访问–&gt;静态内部类</li>
<li>如果外部类和静态内部类的成员重名时，静态内部类访问的时，默认遵守就近原则，如果先访问外部类的成员，则可以使用（外部类.成员）访问</li>
</ol>
<pre><code class="java">class Outer10 &#123; //外部类
private int n1 = 10;
private static String name = &quot;张三&quot;;
private static void cry() &#123;&#125;
/Inner10 就是静态内部类
//1. 放在外部类的成员位置
//2. 使用 static 修饰
//3. 可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员
//4. 可以添加任意访问修饰符(public、protected 、默认、private),因为它的地位就是一个成员
//5. 作用域 ：同其他的成员，为整个类体
static class Inner10 &#123;
private static String name = &quot;韩顺平教育&quot;;
public void say() &#123;
//如果外部类和静态内部类的成员重名时，静态内部类访问的时，
//默认遵循就近原则，如果想访问外部类的成员，则可以使用 （外部类名.成员）
System.out.println(name + &quot; 外部类 name= &quot; + Outer10.name);
cry();
&#125;
&#125;


public void m1() &#123; //外部类---访问------&gt;静态内部类 访问方式：创建对象，再访问
Inner10 inner10 = new Inner10();
inner10.say();
&#125;

public Inner10 getInner10() &#123;
return new Inner10();
&#125;
public static Inner10 getInner10_() &#123;
return new Inner10();
&#125;

&#125;
</code></pre>
<h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ol>
<li>枚举对应英文(enumeration, 简写 enum)</li>
<li>枚举是一组常量的集合。</li>
<li>可以这里理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象。</li>
</ol>
<h2 id="枚举的两种实现方式"><a href="#枚举的两种实现方式" class="headerlink" title="枚举的两种实现方式"></a>枚举的两种实现方式</h2><ol>
<li>自定义类实现枚举</li>
<li>使用enum 关键字实现枚举</li>
</ol>
<h3 id="自定义实现枚举"><a href="#自定义实现枚举" class="headerlink" title="自定义实现枚举"></a>自定义实现枚举</h3><ol>
<li>构造器私有化，防止直接new  </li>
<li>不需要提供set方法，因为枚举对象是只读的，防止修改</li>
<li>对枚举对象&#x2F;属性使用final+static共同修饰，实现底层优化</li>
<li>枚举对象名通常使用全部大写，常量的命名规范</li>
<li>枚举对象根据需要，也可以有多个属性</li>
</ol>
<pre><code class="java">//演示字定义枚举实现
class Season &#123;//类
private String name;
private String desc;//描述
//定义了四个对象, 固定. 
public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;);
public static final Season WINTER = new Season(&quot;冬天&quot;, &quot;寒冷&quot;);
public static final Season AUTUMN = new Season(&quot;秋天&quot;, &quot;凉爽&quot;);
public static final Season SUMMER = new Season(&quot;夏天&quot;, &quot;炎热&quot;);
//1. 将构造器私有化,目的防止 直接 new
//2. 去掉 setXxx 方法, 防止属性被修改
//3. 在 Season 内部，直接创建固定的对象
//4. 优化，可以加入 final 修饰
private Season(String name, String desc) &#123;
this.name = name;
this.desc = desc;
&#125;
public String getName() &#123;
return name;
&#125;
public String getDesc() &#123;
return desc;
&#125;
@Override
public String toString() &#123;
return &quot;Season&#123;&quot; +
&quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
&quot;, desc=&#39;&quot; + desc + &#39;\&#39;&#39; +
&#39;&#125;&#39;;
&#125;
&#125;
</code></pre>
<h3 id="enum关键字实现枚举"><a href="#enum关键字实现枚举" class="headerlink" title="enum关键字实现枚举"></a>enum关键字实现枚举</h3><pre><code class="java">//演示使用 enum 关键字来实现枚举类
enum Season2 &#123;//类
//定义了四个对象, 固定. 
// public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;);
// public static final Season WINTER = new Season(&quot;冬天&quot;, &quot;寒冷&quot;);
// public static final Season AUTUMN = new Season(&quot;秋天&quot;, &quot;凉爽&quot;);
// public static final Season SUMMER = new Season(&quot;夏天&quot;, &quot;炎热&quot;);
//如果使用了 enum 来实现枚举类
//1. 使用关键字 enum 替代 class
//2. public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;) 直接使用
// SPRING(&quot;春天&quot;, &quot;温暖&quot;) 解读 常量名(实参列表)
//3. 如果有多个常量(对象)， 使用 ,号间隔即可
//4. 如果使用 enum 来实现枚举，要求将定义常量对象，写在前面
//5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 ()
SPRING(&quot;春天&quot;, &quot;温暖&quot;), WINTER(&quot;冬天&quot;, &quot;寒冷&quot;), AUTUMN(&quot;秋天&quot;, &quot;凉爽&quot;), SUMMER(&quot;夏天&quot;, &quot;炎热&quot;)/*, What()*/;
private String name;
private String desc;//描述
private Season2() &#123;//无参构造器
&#125;
private Season2(String name, String desc) &#123;
this.name = name;
this.desc = desc;
&#125;
public String getName() &#123;
return name;
&#125;
public String getDesc() &#123;
return desc;
&#125;
@Override
public String toString() &#123;
return &quot;Season&#123;&quot; +
&quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
&quot;, desc=&#39;&quot; + desc + &#39;\&#39;&#39; +
&#39;&#125;&#39;;
&#125;
&#125;
</code></pre>
<h3 id="enum-关键字实现枚举注意事项"><a href="#enum-关键字实现枚举注意事项" class="headerlink" title="enum 关键字实现枚举注意事项"></a>enum 关键字实现枚举注意事项</h3><ol>
<li>当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类, 而且是一个 final 类</li>
<li>传统的 public static final Season2 SPRING &#x3D; new Season2(“春天”, “温暖”); 简化成 SPRING(“春天”, “温暖”)， 这里必须知道，它调用的是哪个构造器.</li>
<li>如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略</li>
<li>当有多个枚举对象时，使用’,’间隔，最后有一个分号结尾</li>
<li>枚举对象必须放在枚举类的行首</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220612184831178.png" alt="image-20220612184831178"></p>
<h3 id="enum常用方法说明"><a href="#enum常用方法说明" class="headerlink" title="enum常用方法说明"></a>enum常用方法说明</h3><p>使用关键字&#x3D;&#x3D;enum&#x3D;&#x3D;时，会隐式继承Enum类，这样我们就可以使用Enum类相关方法</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220612190548580.png" alt="image-20220612190548580"></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>获取枚举对象的名称</td>
</tr>
<tr>
<td>ordinal</td>
<td>获取枚举对象的次序，从0开始</td>
</tr>
<tr>
<td>values</td>
<td>隐藏方法，返回一个数组，class【】，包含所有的枚举对象</td>
</tr>
<tr>
<td>valueof</td>
<td>传入字符串，在枚举类中查找，如果找到了，就返回一个枚举对象，没有则会报错。java.lang.IllegalArgumentException</td>
</tr>
<tr>
<td>compareTo</td>
<td>比较两个枚举对象的大小编号，就是ordinal的次序号码，返回数值</td>
</tr>
</tbody></table>
<h2 id="enum-实现接口"><a href="#enum-实现接口" class="headerlink" title="enum 实现接口"></a>enum 实现接口</h2><ol>
<li>使用enum关键字后，就不能在继承其他类了，因为enum会隐式继承Enum，而java是单继承机制。</li>
<li>枚举类和普通类一样，可以实现接口</li>
</ol>
<pre><code class="java">enum 类名 implements 接口1,接口2&#123;&#125;
</code></pre>
<h2 id="注解的理解"><a href="#注解的理解" class="headerlink" title="注解的理解"></a>注解的理解</h2><ol>
<li>注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息。</li>
<li>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。 </li>
<li>在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角 色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置</li>
</ol>
<h2 id="JDK内置的基本注解类型"><a href="#JDK内置的基本注解类型" class="headerlink" title="JDK内置的基本注解类型"></a>JDK内置的基本注解类型</h2><p>使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元 素 三个基本的 Annotation: </p>
<ol>
<li><p>@Override: 限定某个方法，是重写父类方法, 该注解只能用于方法</p>
<ul>
<li>@Override表示重写父类方法，如果父类方法没有被修饰的方法，则会报错</li>
<li>如果不写@Override注解，而父类仍有相同方法，仍构成重写</li>
<li>查看@Override注解源码为@Target(ElementType.METHOD),说明只能修饰方法</li>
<li>@Target是修饰注解的注解，称为元注解。</li>
</ul>
</li>
<li><p>@Deprecated: 用于表示某个程序元素(类, 方法等)已过时</p>
<ul>
<li>即不再推荐使用，仍然可以使用</li>
<li>可以修饰方法，类，字段，包，参数，等等</li>
<li>做版本升级过渡使用</li>
</ul>
</li>
<li><p>@SuppressWarnings: 抑制编译器警告</p>
<ul>
<li>但不希望看到警告时，可以使用@SuppressWarnings抑制警告</li>
<li>在{“”}中，可以写入你希望抑制的警告信息</li>
<li>作用范围和你放置的位置相关，通常我们放在具体的语句，方法，类上</li>
</ul>
<pre><code>@SuppressWarning 中的属性介绍以及属性说明

all，抑制所有警告
boxing，抑制与封装/拆装作业相关的警告
cast，抑制与强制转型作业相关的警告
dep-ann，抑制与淘汰注释相关的警告
deprecation，抑制与淘汰的相关警告
fallthrough，抑制与switch陈述式中遗漏break相关的警告
finally，抑制与未传回finally区块相关的警告
hiding，抑制与隐藏变数的区域变数相关的警告
incomplete-switch，抑制与switch陈述式(enum case)中遗漏项目相关的警告
javadoc，抑制与javadoc相关的警告
nls，抑制与非nls字串文字相关的警告
null，抑制与空值分析相关的警告
rawtypes，抑制与使用raw类型相关的警告
resource，抑制与使用Closeable类型的资源相关的警告
restriction，抑制与使用不建议或禁止参照相关的警告
serial，抑制与可序列化的类别遗漏serialVersionUID栏位相关的警告
static-access，抑制与静态存取不正确相关的警告
static-method，抑制与可能宣告为static的方法相关的警告
super，抑制与置换方法相关但不含super呼叫的警告
synthetic-access，抑制与内部类别的存取未最佳化相关的警告
sync-override，抑制因为置换同步方法而遗漏同步化的警告
unchecked，抑制与未检查的作业相关的警告
unqualified-field-access，抑制与栏位存取不合格相关的警告
unused，抑制与未用的程式码及停用的程式码相关的警告
</code></pre>
</li>
</ol>
<h2 id="元注解：对注解进行注解"><a href="#元注解：对注解进行注解" class="headerlink" title="元注解：对注解进行注解"></a>元注解：对注解进行注解</h2><p>JDK的元Annotation用于修饰其他Annotation<br>了解即可</p>
<h3 id="元注解种类"><a href="#元注解种类" class="headerlink" title="元注解种类"></a>元注解种类</h3><ol>
<li>@Retention	指定注解作用范围，三种 SOURCE,CLASS,RUNTIME</li>
<li>@Target	指定注解可以在那些地方使用</li>
<li>@Documented	指定该注解是否在javadoc体现</li>
<li>@Inherited	子类会继承成父类注解</li>
</ol>
<h3 id="Retention注解"><a href="#Retention注解" class="headerlink" title="@Retention注解"></a>@Retention注解</h3><p>只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 可以保留多长时间, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值: @Retention 的三种值</p>
<ol>
<li>RetentionPolicy.SOURCE: 编译器使用后，直接丢弃这种策略的注释</li>
<li>RetentionPolicy.CLASS: 编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 不会保留注解。 这是默认值</li>
<li>RetentionPolicy.RUNTIME:编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注解. 程序可以 通过反射获取该注解</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220612202436410.png" alt="image-20220612202436410"></p>
<h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220612202507148.png" alt="image-20220612202507148"></p>
<h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220612202538634.png" alt="image-20220612202538634"></p>
<h3 id="Inherited-注解"><a href="#Inherited-注解" class="headerlink" title="@Inherited 注解"></a>@Inherited 注解</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220612202601365.png" alt="image-20220612202601365"></p>
<h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><h2 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h2><p>Java语言中，将程序执行中发生的不正常情况称为异常。（开发过程中的语法错误和逻辑错误不是异常）</p>
<p>执行过程中的异常事件分为两大类</p>
<ol>
<li>Error（错误），Java虚拟机无法解决的严重问题。如：Java系统内部错误、资源耗尽等严重情况。如：StackOverflowError【栈溢出】和OOM【out of memory】，Error是严重错误，程序会崩溃。</li>
<li>Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，Exception分为两大类：运行时异常【程序运行时，发生的异常】和编译时异常【编译器检查出的异常】。</li>
</ol>
<h2 id="异常体系图"><a href="#异常体系图" class="headerlink" title="异常体系图"></a>异常体系图</h2><p><img src="/java/java-xue-xi-wen-dang/image-20220613105233801.png" alt="image-20220613105233801"></p>
<h3 id="异常体系图小结"><a href="#异常体系图小结" class="headerlink" title="异常体系图小结"></a>异常体系图小结</h3><p>1．异常分为两大类，运行时异常和编译时异常．</p>
<p>2．运行时异常，编译器检查不出来。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时 异常</p>
<p>3．对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响</p>
<p>4．编译时异常，是编译器要求必须处置的异常。</p>
<h2 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h2><h3 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h3><ol>
<li>NullPointerException 空指针异常</li>
<li>ArithmeticException 数学运算异常 </li>
<li>ArrayIndexOutOfBoundsException 数组下标越界异常 </li>
<li>ClassCastException 类型转换异常 </li>
<li>NumberFormatException 数字格式不正确异常[]</li>
</ol>
<h3 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h3><p>编译异常是指在编译期间，就必须处理的异常，否则代码不能通过编译。</p>
<h3 id="常见的编译异常"><a href="#常见的编译异常" class="headerlink" title="常见的编译异常"></a>常见的编译异常</h3><ol>
<li>SQLException／／操作数据库时，查询表可能发生异常</li>
<li>IOException／／操作文件时，发生的异常</li>
<li>FileNotFoundException／／当操作一个不存在的文件时，发生异常</li>
<li>ClassNotFoundException／／加载类，而该类不存在时，异常 </li>
<li>EOFException／／操作文件，到文件末尾，发生异常</li>
<li>IllegalArguementException／／参数异常</li>
</ol>
<h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>异常处理就是当异常发生时，对异常处理的方式</p>
<h3 id="异常处理的方式"><a href="#异常处理的方式" class="headerlink" title="异常处理的方式"></a>异常处理的方式</h3><ol>
<li>try-catch-finally</li>
</ol>
<p>程序员在代码中捕获发生的异常，自行处理</p>
<ol start="2">
<li>throws</li>
</ol>
<p>将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613110120165.png" alt="try-catch-finally机制图"></p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613110208766.png" alt="throws处理机制图"></p>
<h3 id="异常处理分类"><a href="#异常处理分类" class="headerlink" title="异常处理分类"></a>异常处理分类</h3><h4 id="try-catch-异常处理"><a href="#try-catch-异常处理" class="headerlink" title="try-catch 异常处理"></a>try-catch 异常处理</h4><p><img src="/java/java-xue-xi-wen-dang/image-20220613110534485.png" alt="image-20220613110534485"></p>
<h4 id="try-catch方式处理异常-注意事项"><a href="#try-catch方式处理异常-注意事项" class="headerlink" title="try-catch方式处理异常-注意事项"></a>try-catch方式处理异常-注意事项</h4><ol>
<li><p>如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块.</p>
</li>
<li><p>如果异常没有发生，则顺序执行try的代码块，不会进入到catch.</p>
</li>
<li><p>如果希望不管是否发生异常，都执行某段代码（比如关闭连接，释放资源等）则使用如下代码— finally{}</p>
</li>
</ol>
<pre><code class="java">try&#123;
int a = Integer.parselnt(str);
System.out.println（&quot;数字： &quot;+a）;
&#125;
catch (Exception e)&#123;
e.printStackTrace(); 
&#125; finally&#123;
System.out.println(&quot;不管是否发生异常，始终执行的代码～～&quot;);
&#125;
</code></pre>
<ol start="4">
<li>可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求父类异常在后，自雷异常在前，比如（Exception在后，NullPointerException在前），如果发生异常，只会匹配一个catch。</li>
</ol>
<pre><code class="java">public static void main(String[] args) &#123;
//老韩解读
//1.如果 try 代码块有可能有多个异常
//2.可以使用多个 catch 分别捕获不同的异常，相应处理
//3.要求子类异常写在前面，父类异常写在后面
try &#123;
Person person = new Person();
//person = null;
System.out.println(person.getName());//NullPointerException
int n1 = 10;
int n2 = 0;
int res = n1 / n2;//ArithmeticException
&#125; catch (NullPointerException e) &#123;
System.out.println(&quot;空指针异常=&quot; + e.getMessage());
&#125; catch (ArithmeticException e) &#123;
System.out.println(&quot;算术异常=&quot; + e.getMessage());
&#125; catch (Exception e) &#123;
System.out.println(e.getMessage());
&#125; finally &#123;
&#125;
&#125;
&#125;
class Person &#123;
private String name = &quot;jack&quot;;
public String getName() &#123;
return name;
&#125;
&#125;
</code></pre>
<ol start="5">
<li>可以进行try-finally配合使用，这种用法相当于没有捕获异常，因此程序会直接崩掉&#x2F;退出。应用场景，就是执行一段代码，不管是否发生异常，都必须执行某个业务逻辑。</li>
</ol>
<pre><code class="java">public static void main(String[] args) &#123;
/*
可以进行 try-finally 配合使用, 这种用法相当于没有捕获异常，
因此程序会直接崩掉/退出。应用场景，就是执行一段代码，不管是否发生异常，
都必须执行某个业务逻辑
*/
try&#123;
int n1 = 10;
int n2 = 0;
System.out.println(n1 / n2);
&#125;finally &#123;
System.out.println(&quot;执行了 finally..&quot;);
&#125;
System.out.println(&quot;程序继续执行..&quot;);
&#125;
</code></pre>
<h4 id="throws-异常处理"><a href="#throws-异常处理" class="headerlink" title="throws 异常处理"></a>throws 异常处理</h4><ol>
<li>如果一个方法中的语句执行时，可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示的声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</li>
<li>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</li>
</ol>
<h4 id="throws-异常处理-注意事项"><a href="#throws-异常处理-注意事项" class="headerlink" title="throws 异常处理-注意事项"></a>throws 异常处理-注意事项</h4><ol>
<li>对于编译异常，程序中必须处理，比如 try-catch或者 throws</li>
<li>对于运行时异常，程序中如果没有处理，默认就是throws的方式判断</li>
<li>子类重写父类方法是，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么韦弗蕾抛出的异常的类型的子类型</li>
<li>在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必throws。</li>
</ol>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>当程序中出现了某些“错误“，但该错误信息井没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息。</p>
<h3 id="自定义异常的步骤"><a href="#自定义异常的步骤" class="headerlink" title="自定义异常的步骤"></a>自定义异常的步骤</h3><p>1）定义类：自定义异常类名（稷序员自己写》继承Exception或RuntimeException<br>2）如果继承Exception,属于编译异常<br>3）如果继属于运行异常（一般来说，继承RuntimeException)</p>
<h3 id="自定义异常的应用实例-CustomException-java"><a href="#自定义异常的应用实例-CustomException-java" class="headerlink" title="自定义异常的应用实例 CustomException.java"></a>自定义异常的应用实例 CustomException.java</h3><p>当我们接收Person对象年龄时，要求范围在18_120之间，否则抛出一个自定义异常<br>继承RuntimeExcetion,并给出提示信息</p>
<pre><code class="java">/**
* @author 韩顺平
* @version 1.0
*/
public class CustomException &#123;
public static void main(String[] args) /*throws AgeException*/ &#123;
int age = 180;
//要求范围在 18 – 120 之间，否则抛出一个自定义异常
if(!(age &gt;= 18 &amp;&amp; age &lt;= 120)) &#123;
//这里我们可以通过构造器，设置信息
throw new AgeException(&quot;年龄需要在 18~120 之间&quot;);
&#125;
System.out.println(&quot;你的年龄范围正确.&quot;);
&#125;
&#125;
//自定义一个异常
//老韩解读
//1. 一般情况下，我们自定义异常是继承 RuntimeException
//2. 即把自定义异常做成 运行时异常，好处时，我们可以使用默认的处理机制
//3. 即比较方便
class AgeException extends RuntimeException &#123;
public AgeException(String message) &#123;//构造器
super(message);
&#125;
&#125;
</code></pre>
<h2 id="throw和throws对比"><a href="#throw和throws对比" class="headerlink" title="throw和throws对比"></a>throw和throws对比</h2><p><img src="/java/java-xue-xi-wen-dang/image-20220613113145687.png" alt="image-20220613113145687"></p>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ol>
<li>针对八种基本数据类型相应的引用类型—包装类</li>
</ol>
<ol start="2">
<li>有了类的特点，就可以调用类中的方法。</li>
<li>如图</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613113534832.png" alt="image-20220613113534832"></p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613113747935.png" alt="image-20220613113747935"></p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613113805756.png" alt="image-20220613113805756"></p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613113819170.png" alt="image-20220613113819170"></p>
<h3 id="包装类和基本数据的转换"><a href="#包装类和基本数据的转换" class="headerlink" title="包装类和基本数据的转换"></a>包装类和基本数据的转换</h3><ol>
<li>jdk5前的手动装箱和拆箱方式，装箱：基本类型·&gt;包装类型，反之，拆箱</li>
<li>jdk5以后（含jdk5》的自动装箱和拆箱方式</li>
<li>自动装箱底层调用的是valueOf方法，比如Integer.valueOf()</li>
<li>其它包装类的用法类似，不一一举例</li>
</ol>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><pre><code class="java">public static void main(String[] args) &#123;
//演示 int &lt;--&gt; Integer 的装箱和拆箱
//jdk5 前是手动装箱和拆箱
//手动装箱 int-&gt;Integer
int n1 = 100;
Integer integer = new Integer(n1);
Integer integer1 = Integer.valueOf(n1);
//手动拆箱
//Integer -&gt; int
int i = integer.intValue();
//jdk5 后，就可以自动装箱和自动拆箱
int n2 = 200;
//自动装箱 int-&gt;Integer
Integer integer2 = n2; //底层使用的是 Integer.valueOf(n2)
//自动拆箱 Integer-&gt;int
int n3 = integer2; //底层仍然使用的是 intValue()方法
&#125;
</code></pre>
<h3 id="包装类型和-String-类型的相互转换-WrapperVSString-java"><a href="#包装类型和-String-类型的相互转换-WrapperVSString-java" class="headerlink" title="包装类型和 String 类型的相互转换 WrapperVSString.java"></a>包装类型和 String 类型的相互转换 WrapperVSString.java</h3><pre><code class="java">/**
* @author 韩顺平
* @version 1.0
*/
public class WrapperVSString &#123;
public static void main(String[] args) &#123;
//包装类(Integer)-&gt;String
Integer i = 100;//自动装箱
//方式 1
String str1 = i + &quot;&quot;;
//方式 2
String str2 = i.toString();
//方式 3
String str3 = String.valueOf(i);
//String -&gt; 包装类(Integer)
String str4 = &quot;12345&quot;;
Integer i2 = Integer.parseInt(str4);//使用到自动装箱
Integer i3 = new Integer(str4);//构造器
System.out.println(&quot;ok~~&quot;);
&#125;
&#125;
</code></pre>
<h3 id="Integer-类和-Character类常用方法"><a href="#Integer-类和-Character类常用方法" class="headerlink" title="Integer 类和 Character类常用方法"></a>Integer 类和 Character类常用方法</h3><pre><code class="java">public class WrapperMethod &#123;
public static void main(String[] args) &#123;
System.out.println(Integer.MIN_VALUE); //返回最小值
System.out.println(Integer.MAX_VALUE);//返回最大值
System.out.println(Character.isDigit(&#39;a&#39;));//判断是不是数字
System.out.println(Character.isLetter(&#39;a&#39;));//判断是不是字母
System.out.println(Character.isUpperCase(&#39;a&#39;));//判断是不是大写
System.out.println(Character.isLowerCase(&#39;a&#39;));//判断是不是小写
System.out.println(Character.isWhitespace(&#39;a&#39;));//判断是不是空格
System.out.println(Character.toUpperCase(&#39;a&#39;));//转成大写
System.out.println(Character.toLowerCase(&#39;A&#39;));//转成小写
&#125;
&#125;
</code></pre>
<h3 id="Integer-类面试题-1"><a href="#Integer-类面试题-1" class="headerlink" title="Integer 类面试题 1"></a>Integer 类面试题 1</h3><p>WrapperExercise02.java</p>
<pre><code class="java">public static void main(String[] args) &#123;
Integer i = new Integer(1);
Integer j = new Integer(1);
System.out.println(i == j); //False
//所以，这里主要是看范围 -128 ~ 127 就是直接返回
/*
老韩解读
//1. 如果 i 在 IntegerCache.low(-128)~IntegerCache.high(127),就直接从数组返回
//2. 如果不在 -128~127,就直接 new Integer(i)
public static Integer valueOf(int i) &#123;
if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
return IntegerCache.cache[i + (-IntegerCache.low)];
return new Integer(i);
&#125;
*/
Integer m = 1; //底层 Integer.valueOf(1); -&gt; 阅读源码
Integer n = 1;//底层 Integer.valueOf(1);
System.out.println(m == n); //T
//所以，这里主要是看范围 -128 ~ 127 就是直接返回
//，否则，就 new Integer(xx);
Integer x = 128;//底层 Integer.valueOf(1);
Integer y = 128;//底层 Integer.valueOf(1);
System.out.println(x == y);//False
&#125;
&#125;
</code></pre>
<h3 id="Intege-类面试题总结"><a href="#Intege-类面试题总结" class="headerlink" title="Intege 类面试题总结"></a>Intege 类面试题总结</h3><pre><code class="java">public class WrapperExercise03 &#123;
public static void main(String[] args) &#123;
    
//示例一，不是调用valueof，而是创建新对象
Integer i1 = new Integer(127);
Integer i2 = new Integer(127);
System.out.println(i1 == i2);//F
    
//示例二
Integer i3 = new Integer(128);
Integer i4 = new Integer(128);
System.out.println(i3 == i4);//F
    
//示例三
Integer i5 = 127;//底层 Integer.valueOf(127)
Integer i6 = 127;//-128~127
System.out.println(i5 == i6); //T
    
//示例四
Integer i7 = 128;
Integer i8 = 128;
System.out.println(i7 == i8);//F
    
//示例五
Integer i9 = 127; //Integer.valueOf(127)
Integer i10 = new Integer(127);
System.out.println(i9 == i10);//F
    
//示例六
Integer i11=127;
int i12=127;
//只有有基本数据类型，判断的是
//值是否相同，会自动拆箱操作称为int比较
System.out.println(i11==i12); //T
    
//示例七
Integer i13=128;
int i14=128;
System.out.println(i13==i14);//T
&#125;
&#125;
</code></pre>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String-类的理解和创建对象"><a href="#String-类的理解和创建对象" class="headerlink" title="String 类的理解和创建对象"></a>String 类的理解和创建对象</h3><ol>
<li>String 对象用于保存字符串，也就是一组字符序列</li>
<li>字符串常量对象用双引号括起的字符序列。</li>
<li>字符串的字符使用Unicode字符编码，一个字符（不区分字母还是汉字），占两个字符</li>
<li>String类较常用构造器</li>
</ol>
<pre><code class="java">String s1 = new String();
String s2 = new String(String original);
String s3 = new String(char[] a);
String s4 = new String(char[] a,int startIndex,int count);
</code></pre>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613122622418.png" alt="image-20220613122622418"></p>
<ol start="5">
<li><p>String 类实现了接口 Serializable【String 可以串行化:可以在网络传输】 </p>
<p>实现了接口 Comparable [String 对象可以比较大小]</p>
</li>
<li><p>String 是 final 类，不能被其他的类继承</p>
</li>
<li><p>String 有属性 private final char value[]; 用于存放字符串内容</p>
</li>
<li><p>一定要注意：value 是一个 final 类型，不可以修改，即value不能指向新的地址，但是单个字符串内容可以变化。</p>
</li>
</ol>
<h3 id="创建-String-对象的两种方式"><a href="#创建-String-对象的两种方式" class="headerlink" title="创建 String 对象的两种方式"></a>创建 String 对象的两种方式</h3><ol>
<li>直接赋值String s &#x3D;””;</li>
<li>直接构造器 String s2 &#x3D; new String(“”);</li>
</ol>
<h3 id="两种创建-String-对象的区别"><a href="#两种创建-String-对象的区别" class="headerlink" title="两种创建 String 对象的区别"></a>两种创建 String 对象的区别</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220613144636121.png" alt="image-20220613144636121"></p>
<h3 id="String练习题"><a href="#String练习题" class="headerlink" title="String练习题"></a>String练习题</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220613144730748.png" alt="image-20220613144730748"></p>
<h3 id="字符串的特性"><a href="#字符串的特性" class="headerlink" title="字符串的特性"></a>字符串的特性</h3><ol>
<li>String是一个final类，代表不可变的字符串序列</li>
<li>字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613144945734.png" alt="image-20220613144945734"></p>
<h3 id="面试题-第二题是难题"><a href="#面试题-第二题是难题" class="headerlink" title="面试题(第二题是难题)"></a>面试题(第二题是难题)</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220613145040765.png" alt="image-20220613145040765"></p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613150045820.png" alt="image-20220613150045820"></p>
<p>c&#x3D;a+b;</p>
<ol>
<li>先创建StringBuilder，先append（hello），在append（abc），然后调用tostring方法返回。</li>
<li>c对象指向堆内存的String类型，String指向内存的helloabc!!难点</li>
<li>intern方法返回的是方法区的引用</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613150814848.png" alt="image-20220613150814848"></p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613150143809.png" alt="image-20220613150143809"></p>
<h3 id="String-类的常见方法"><a href="#String-类的常见方法" class="headerlink" title="String 类的常见方法"></a>String 类的常见方法</h3><p>String类是保存字符串常量的。每次更新都需要开辟新的空间，效率很低，因此java设计者还提供了StringBuilder和StringBuffer来增强String功能，并提高效率。</p>
<pre><code class="java">String s = new String(&quot;&quot;);
for(int i = 0;i&lt;80000;i++)&#123;
    s += &quot;hello&quot;;
&#125;
</code></pre>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613151247544.png" alt="image-20220613151247544"></p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613151628898.png" alt="image-20220613151628898"></p>
<pre><code class="java">public class StringMethod01 &#123;
public static void main(String[] args) &#123;
//1. equals 前面已经讲过了. 比较内容是否相同，区分大小写
String str1 = &quot;hello&quot;;
String str2 = &quot;Hello&quot;;
System.out.println(str1.equals(str2));//
// 2.equalsIgnoreCase 忽略大小写的判断内容是否相等
String username = &quot;johN&quot;;
if (&quot;john&quot;.equalsIgnoreCase(username)) &#123;
System.out.println(&quot;Success!&quot;);
&#125; else &#123;
System.out.println(&quot;Failure!&quot;);
&#125;
// 3.length 获取字符的个数，字符串的长度
System.out.println(&quot;韩顺平&quot;.length());
// 4.indexOf 获取字符在字符串对象中第一次出现的索引，索引从 0 开始，如果找不到，返回-1
String s1 = &quot;wer@terwe@g&quot;;
int index = s1.indexOf(&#39;@&#39;);
System.out.println(index);// 3
System.out.println(&quot;weIndex=&quot; + s1.indexOf(&quot;we&quot;));//0
// 5.lastIndexOf 获取字符在字符串中最后一次出现的索引，索引从 0 开始，如果找不到，返回-1
s1 = &quot;wer@terwe@g@&quot;;
index = s1.lastIndexOf(&#39;@&#39;);
System.out.println(index);//11
System.out.println(&quot;ter 的位置=&quot; + s1.lastIndexOf(&quot;ter&quot;));//4
// 6.substring 截取指定范围的子串
String name = &quot;hello,张三&quot;;
//下面 name.substring(6) 从索引 6 开始截取后面所有的内容
System.out.println(name.substring(6));//截取后面的字符
//name.substring(0,5)表示从索引 0 开始截取，截取到索引 5-1=4 位置
System.out.println(name.substring(2,5));//llo
&#125;
&#125;
</code></pre>
<pre><code class="java">public class StringMethod02 &#123;
public static void main(String[] args) &#123;
// 1.toUpperCase 转换成大写
String s = &quot;heLLo&quot;;
System.out.println(s.toUpperCase());//HELLO
// 2.toLowerCase
System.out.println(s.toLowerCase());//hello
// 3.concat 拼接字符串
String s1 = &quot;宝玉&quot;;
s1 = s1.concat(&quot;林黛玉&quot;).concat(&quot;薛宝钗&quot;).concat(&quot;together&quot;);
System.out.println(s1);//宝玉林黛玉薛宝钗 together
// 4.replace 替换字符串中的字符
s1 = &quot;宝玉 and 林黛玉 林黛玉 林黛玉&quot;;
//在 s1 中，将 所有的 林黛玉 替换成薛宝钗
// 老韩解读: s1.replace() 方法执行后，返回的结果才是替换过的. // 注意对 s1 没有任何影响
String s11 = s1.replace(&quot;宝玉&quot;, &quot;jack&quot;);
System.out.println(s1);//宝玉 and 林黛玉 林黛玉 林黛玉
System.out.println(s11);//jack and 林黛玉 林黛玉 林黛玉
// 5.split 分割字符串, 对于某些分割字符，我们需要 转义比如 | \\等
String poem = &quot;锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦&quot;;
//老韩解读：
// 1. 以 , 为标准对 poem 进行分割 , 返回一个数组
// 2. 在对字符串进行分割时，如果有特殊字符，需要加入 转义符 \
String[] split = poem.split(&quot;,&quot;);
poem = &quot;E:\\aaa\\bbb&quot;;
split = poem.split(&quot;\\\\&quot;);
System.out.println(&quot;==分割后内容===&quot;);
for (int i = 0; i &lt; split.length; i++) &#123;
System.out.println(split[i]);
&#125;
// 6.toCharArray 转换成字符数组
s = &quot;happy&quot;;
char[] chs = s.toCharArray();
for (int i = 0; i &lt; chs.length; i++) &#123;
System.out.println(chs[i]);
&#125;
// 7.compareTo 比较两个字符串的大小，如果前者大，
// 则返回正数，后者大，则返回负数，如果相等，返回 0
// 老韩解读
// (1) 如果长度相同，并且每个字符也相同，就返回 0
// (2) 如果长度相同或者不相同，但是在进行比较时，可以区分大小
// 就返回 if (c1 != c2) &#123;
// return c1 - c2;
// &#125;
// (3) 如果前面的部分都相同，就返回 str1.len - str2.len
String a = &quot;jcck&quot;;// len = 3
String b = &quot;jack&quot;;// len = 4
System.out.println(a.compareTo(b)); // 返回值是 &#39;c&#39; - &#39;a&#39; = 2 的值
// 8.format 格式字符串
/* 占位符有:
* %s 字符串 %c 字符 %d 整型 %.2f 浮点型
*
*/
String name = &quot;john&quot;;
int age = 10;
double score = 56.857;
char gender = &#39;男&#39;;
//将所有的信息都拼接在一个字符串. String info =
&quot;我的姓名是&quot; + name + &quot;年龄是&quot; + age + &quot;,成绩是&quot; + score + &quot;性别是&quot; + gender + &quot;。希望大家喜欢我！
&quot;;
System.out.println(info);
//老韩解读
//1. %s , %d , %.2f %c 称为占位符
//2. 这些占位符由后面变量来替换
//3. %s 表示后面由 字符串来替换
//4. %d 是整数来替换
//5. %.2f 表示使用小数来替换，替换后，只会保留小数点两位, 并且进行四舍五入的处理
//6. %c 使用 char 类型来替换
String formatStr = &quot;我的姓名是%s 年龄是%d，成绩是%.2f 性别是%c.希望大家喜欢我！&quot;;
String info2 = String.format(formatStr, name, age, score, gender);
System.out.println(&quot;info2=&quot; + info2);
&#125;
&#125;
</code></pre>
<h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p>java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删。</p>
<p>很多方法与String相同，带式StringBuffer是可变长度的。</p>
<p>StringBuffer是一个容器。</p>
<pre><code class="java">//老韩解读
//1. StringBuffer 的直接父类 是 AbstractStringBuilder
//2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化
//3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final
// 该 value 数组存放 字符串内容，引出存放在堆中的
//4. StringBuffer 是一个 final 类，不能被继承
//5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)
// 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String
</code></pre>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613152337110.png" alt="image-20220613152337110"></p>
<h3 id="String-VS-StringBuffer"><a href="#String-VS-StringBuffer" class="headerlink" title="String VS StringBuffer"></a>String VS StringBuffer</h3><ol>
<li>String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低&#x2F;&#x2F;private final char value[]</li>
<li>StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不更新地址，效率较高。</li>
</ol>
<h3 id="String-和-StringBuffer相互转换"><a href="#String-和-StringBuffer相互转换" class="headerlink" title="String 和 StringBuffer相互转换"></a>String 和 StringBuffer相互转换</h3><pre><code class="java">public class StringAndStringBuffer &#123;
public static void main(String[] args) &#123;
    
//看 String——&gt;StringBuffer
String str = &quot;hello tom&quot;;
//方式 1 使用构造器
//注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响
StringBuffer stringBuffer = new StringBuffer(str);
//方式 2 使用的是 append 方法
StringBuffer stringBuffer1 = new StringBuffer();
stringBuffer1 = stringBuffer1.append(str);
    
//看看 StringBuffer -&gt;String
StringBuffer stringBuffer3 = new StringBuffer(&quot;韩顺平教育&quot;);
//方式 1 使用 StringBuffer 提供的 toString 方法
String s = stringBuffer3.toString();
//方式 2: 使用构造器来搞定
String s1 = new String(stringBuffer3);
&#125;
&#125;
</code></pre>
<h3 id="StringBuffer类常见方法"><a href="#StringBuffer类常见方法" class="headerlink" title="StringBuffer类常见方法"></a>StringBuffer类常见方法</h3><pre><code class="java">/**
* @author 韩顺平
* @version 1.0
*/
public class StringBufferMethod &#123;
public static void main(String[] args) &#123;
StringBuffer s = new StringBuffer(&quot;hello&quot;);
//增
s.append(&#39;,&#39;);// &quot;hello,&quot;
s.append(&quot;张三丰&quot;);//&quot;hello,张三丰&quot;
s.append(&quot;赵敏&quot;).append(100).append(true).append(10.5);//&quot;hello,张三丰赵敏 100true10.5&quot; System.out.println(s);//&quot;hello,张三丰赵敏 100true10.5&quot;
//删
/*
* 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符
* 解读: 删除 11~14 的字符 [11, 14)
*/
s.delete(11, 14);
System.out.println(s);//&quot;hello,张三丰赵敏 true10.5&quot;
//改
//老韩解读，使用 周芷若 替换 索引 9-11 的字符 [9,11)
s.replace(9, 11, &quot;周芷若&quot;);
System.out.println(s);//&quot;hello,张三丰周芷若 true10.5&quot;
//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1
int indexOf = s.indexOf(&quot;张三丰&quot;);
System.out.println(indexOf);//6
//插
//老韩解读，在索引为 9 的位置插入 &quot;赵敏&quot;,原来索引为 9 的内容自动后移
s.insert(9, &quot;赵敏&quot;);
System.out.println(s);//&quot;hello,张三丰赵敏周芷若 true10.5&quot;
//长度
System.out.println(s.length());//22
System.out.println(s);
&#125;
&#125;
</code></pre>
<h3 id="StringBuffer练习题"><a href="#StringBuffer练习题" class="headerlink" title="StringBuffer练习题"></a>StringBuffer练习题</h3><pre><code class="java">public class StringBufferExercise01 &#123;
public static void main(String[] args) &#123;
String str = null;// ok
StringBuffer sb = new StringBuffer(); //ok
sb.append(str);//需要看源码 , 底层调用的是 AbstractStringBuilder 的 appendNull
System.out.println(sb.length());//4
System.out.println(sb);//null
//下面的构造器，会抛出 NullpointerException
StringBuffer sb1 = new StringBuffer(str);//看底层源码 super(str.length() + 16);str.length因为是null，所以报nullpointer
System.out.println(sb1);
&#125;
&#125;
</code></pre>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613154705966.png" alt="image-20220613154705966"></p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613154725124.png" alt="image-20220613154725124"></p>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><ol>
<li>一个可变的字符序列。此类提供一个于StringBuffer兼容的API，但不保证同步（StringBuilder不是线程安全）。该类被设计用作String Buffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，优先采用该类，因为大多数实现中，它比StringBuffer要快。</li>
<li>在StringBuilder上的主要操作是append和instert方法，可重载这些方法，以接收任意类型的数据。</li>
</ol>
<pre><code class="java">//老韩解读
//1. StringBuffer 的直接父类 是 AbstractStringBuilder
//2. 实现了 Serializable ,说明 StringBuilder 对象是可以串行化(对象可以网络传输,可以保存到文件)
//3. StringBuilder 是 final 类, 不能被继承
//4. StringBuilder 对象字符序列仍然是存放在其父类 		           	      AbstractStringBuilder 的 char[] value;
//   不是final修饰的
// 该 value 数组存放 字符串内容，引出存放在堆中
//4. StringBuffer 是一个 final 类，不能被继承
//5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)
//6. . StringBuilder 的方法，没有做互斥的处理,即没有 synchronized 关键字,因此在单线程的情况下使用
// 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 Strin
</code></pre>
<h3 id="StringBuilder常用方法"><a href="#StringBuilder常用方法" class="headerlink" title="StringBuilder常用方法"></a>StringBuilder常用方法</h3><p>StringBuilder和StringBuffer都代表可变的字符序列，方法是一样的。</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613155521045.png" alt="image-20220613155521045"></p>
<h3 id="String、StringBuffer和StringBuilder的比较"><a href="#String、StringBuffer和StringBuilder的比较" class="headerlink" title="String、StringBuffer和StringBuilder的比较"></a>String、StringBuffer和StringBuilder的比较</h3><ol>
<li><p>StringBuilder和StringBuffer非常类似，均代表可变字符序列，而且方法也一样。</p>
</li>
<li><p>String：不可变字符序列，效率低，但是<strong>复用率高</strong></p>
</li>
<li><p>StringBuffer：可变字符序列、效率较高（增删）、线程安全，看源码</p>
</li>
<li><p>StringBuilder：可变字符序列、效率最高，线程不安全</p>
</li>
<li><p>String实用注意：</p>
<p>String s&#x3D;”a”;&#x2F;&#x2F;创建了一个字符串</p>
<p>s +&#x3D; “b”;&#x2F;&#x2F;实际上原来的”a”字符串已经丢弃了，现在又产生了一个字符串s+”b”,也就是”ab”。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象六存在内存中，降低效率。如果这样的操作放到循环中，会极大地影响性能。结论：如果我们对String做大量频繁修改，不要使用String；</p>
</li>
</ol>
<h3 id="String、StringBuffer-和-StringBuilder-的效率测试"><a href="#String、StringBuffer-和-StringBuilder-的效率测试" class="headerlink" title="String、StringBuffer 和 StringBuilder 的效率测试"></a>String、StringBuffer 和 StringBuilder 的效率测试</h3><pre><code class="java">public class StringVsStringBufferVsStringBuilder &#123;
    public static void main(String[] args) &#123;
        long startTime = 0L;
        long endTime = 0L;

        StringBuffer buffer = new StringBuffer(&quot;&quot;);
        startTime = System.currentTimeMillis();
        for (int i = 0; i &lt; 80000; i++) &#123;//StringBuffer 拼接 20000 次
            buffer.append(String.valueOf(i));
        &#125;
        endTime = System.currentTimeMillis();
        System.out.println(&quot;StringBuffer 的执行时间：&quot; + (endTime - startTime));

        StringBuilder builder = new StringBuilder(&quot;&quot;);
        startTime = System.currentTimeMillis();
        for (int i = 0; i &lt; 80000; i++) &#123;//StringBuilder 拼接 20000 次
            builder.append(String.valueOf(i));
        &#125;
        endTime = System.currentTimeMillis();
        System.out.println(&quot;StringBuilder 的执行时间：&quot; + (endTime - startTime));

        String text = &quot;&quot;;
        startTime = System.currentTimeMillis();
        for (int i = 0; i &lt; 80000; i++) &#123;//String 拼接 20000
            text = text + i;
        &#125;
        endTime = System.currentTimeMillis();
        System.out.println(&quot;String 的执行时间：&quot; + (endTime - startTime));
    &#125;


&#125;
/*
StringBuffer 的执行时间：28
StringBuilder 的执行时间：19
String 的执行时间：7698
*/
</code></pre>
<h3 id="String、StringBuffer-和-StringBuilder的选择"><a href="#String、StringBuffer-和-StringBuilder的选择" class="headerlink" title="String、StringBuffer 和 StringBuilder的选择"></a>String、StringBuffer 和 StringBuilder的选择</h3><ol>
<li>如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder</li>
<li>如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder</li>
<li>如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer</li>
<li>如果我们字符串很少修改，被多个对象引用，使用String，比如配置文件等</li>
</ol>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。</p>
<h3 id="Math常见方法"><a href="#Math常见方法" class="headerlink" title="Math常见方法"></a>Math常见方法</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220613174057742.png" alt="image-20220613174057742"></p>
<pre><code class="java">public class MathMethod &#123;
public static void main(String[] args) &#123;
//看看 Math 常用的方法(静态方法)
//1.abs 绝对值
int abs = Math.abs(-9);
System.out.println(abs);//9
//2.pow 求幂
double pow = Math.pow(2, 4);//2 的 4 次方
System.out.println(pow);//16
//3.ceil 向上取整,返回&gt;=该参数的最小整数(转成 double);
double ceil = Math.ceil(3.9);
System.out.println(ceil);//4.0
//4.floor 向下取整，返回&lt;=该参数的最大整数(转成 double)
double floor = Math.floor(4.001);
System.out.println(floor);//4.0
//5.round 四舍五入 Math.floor(该参数+0.5)
long round = Math.round(5.51);
System.out.println(round);//6
//6.sqrt 求开方
double sqrt = Math.sqrt(9.0);
System.out.println(sqrt);//3.0
//7.random 求随机数
// random 返回的是 0 &lt;= x &lt; 1 之间的一个随机小数
// 思考：请写出获取 a-b 之间的一个随机整数,a,b 均为整数 ，比如 a = 2, b=7
// 即返回一个数 x 2 &lt;= x &lt;= 7
// 老韩解读 Math.random() * (b-a) 返回的就是 0 &lt;= 数 &lt;= b-a
// (1) (int)(a) &lt;= x &lt;= (int)(a + Math.random() * (b-a +1) )
// (2) 使用具体的数给小伙伴介绍 a = 2 b = 7
// (int)(a + Math.random() * (b-a +1) ) = (int)( 2 + Math.random()*6)
// Math.random()*6 返回的是 0 &lt;= x &lt; 6 小数
// 2 + Math.random()*6 返回的就是 2&lt;= x &lt; 8 小数
// (int)(2 + Math.random()*6) = 2 &lt;= x &lt;= 7
// (3) 公式就是 (int)(a + Math.random() * (b-a +1) )
for(int i = 0; i &lt; 100; i++) &#123;
System.out.println((int)(2 + Math.random() * (7 - 2 + 1)));
&#125;
//max , min 返回最大值和最小值
int min = Math.min(1, 9);
int max = Math.max(45, 90);
System.out.println(&quot;min=&quot; + min);
System.out.println(&quot;max=&quot; + max);
&#125;
&#125;
</code></pre>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>该类包含用于操作数组的各种静态方法（如排序和搜索）。 </p>
<p>该类还包含一个静态工厂，可以将数组视为列表。 </p>
<p>用于管理或操作数组（比如索引和搜索）</p>
<h3 id="Arrays常用方法"><a href="#Arrays常用方法" class="headerlink" title="Arrays常用方法"></a>Arrays常用方法</h3><pre><code class="java">1. toString 返回数组的字符串形式
Arrays.toString(arr);

2. sort 排序（自然排序和定制排序）
    
3. binarySearch通过二分搜索法进行查找，要求必须排好序
   没有排好序的数组进行查找就返回应在 -（索引下标+1），看源码
int index = Arrays.binarySearch(arr,3);

4. copyOf 数组元素的复制
   如果拷贝的长度大于arr.length，在后面添加NULL默认值
Integer[] newArr = Arrays.copyOf(arr,arr.length);

5. fill 数组元素的填充
   把数组中的元素都替换成99
Integer[] num = new Integer[]&#123;9,3,2&#125;;
Arrays.fill(num,99);

6. equals 比较两个数组元素内容是否完全一致
boolean equals = Arrays.equals(arr,arr2);

7. asList 将一组值，转换成list
List&lt;Integer&gt; asList = Arrays.asList(2,3,4,5,6,1);

8. 
</code></pre>
<h3 id="冒泡-定制排序"><a href="#冒泡-定制排序" class="headerlink" title="冒泡+定制排序"></a>冒泡+定制排序</h3><pre><code class="java">//结合冒泡 + 定制
public static void bubble02(int[] arr, Comparator c) &#123;
int temp = 0;
for (int i = 0; i &lt; arr.length - 1; i++) &#123;
for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;
//数组排序由 c.compare(arr[j], arr[j + 1])返回的值决定
if (c.compare(arr[j], arr[j + 1]) &gt; 0) &#123;
temp = arr[j];
arr[j] = arr[j + 1];
arr[j + 1] = temp;
&#125;
&#125;
&#125;
&#125;


//简化版本
        int temp ;
        for(int i =0;i&lt;integers.length-1;i++)&#123;
            for(int j = 0;j&lt;integers.length-1-i;j++)&#123;
                //integers[j+1]-integers[j])  从大到小
                //integers[j]-integers[j+1])  从小到大
                if((integers[j+1]-integers[j])&lt;0)&#123;
                    temp = integers[j+1];
                    integers[j+1] = integers[j];
                    integers[j] = temp;
                &#125;
            &#125;
        &#125;
</code></pre>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><h3 id="System-类常见方法和案例"><a href="#System-类常见方法和案例" class="headerlink" title="System 类常见方法和案例"></a>System 类常见方法和案例</h3><ol>
<li>exit退出当前程序</li>
<li>arraycopy：复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组</li>
<li>currentTimeMillens()，返回当前时间距离1970-1-1的毫秒数</li>
<li>gc：运行垃圾回收机制 System.gc();</li>
</ol>
<pre><code class="java">exit退出当前程序
//exit(0) 正常退出
//exit(1) 异常退出
System.exit(0);
</code></pre>
<h2 id="BigInteger-BigDecimal"><a href="#BigInteger-BigDecimal" class="headerlink" title="BigInteger BigDecimal"></a>BigInteger BigDecimal</h2><p>BigInteger适合保存比较大的整数</p>
<p>BigDecimal适合保存精度更高的浮点型（小数）</p>
<h3 id="BigInteger-和-BigDecimal-常见方法"><a href="#BigInteger-和-BigDecimal-常见方法" class="headerlink" title="BigInteger 和 BigDecimal 常见方法"></a>BigInteger 和 BigDecimal 常见方法</h3><ol>
<li>add</li>
<li>subtract（减去）</li>
<li>multiply（乘）</li>
<li>divide（除）</li>
</ol>
<pre><code class="java">BigInteger bigInteger = new BigInteger(&quot;23788888899999999999999999999&quot;);
BigInteger bigInteger2 = new BigInteger(&quot;10099999999999999999999999999999999999999999999999999999999999999999999999999999999&quot;);
//老韩解读
//1. 在对 BigInteger 进行加减乘除的时候，需要使用对应的方法，不能直接进行 + - * /
//2. 可以创建一个 要操作的 BigInteger 然后进行相应操作
BigInteger add = bigInteger.add(bigInteger2);
System.out.println(add);//
BigInteger subtract = bigInteger.subtract(bigInteger2);
System.out.println(subtract);//减
BigInteger multiply = bigInteger.multiply(bigInteger2);
System.out.println(multiply);//乘
BigInteger divide = bigInteger.divide(bigInteger2);
System.out.println(divide);//除
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
//当我们需要保存一个精度很高的数时，double 不够用
//可以是 BigDecimal
// double d = 1999.11111111111999999999999977788d;
// System.out.println(d);
BigDecimal bigDecimal = new BigDecimal(&quot;1999.11&quot;);
BigDecimal bigDecimal2 = new BigDecimal(&quot;3&quot;);
System.out.println(bigDecimal);
//老韩解读
//1. 如果对 BigDecimal 进行运算，比如加减乘除，需要使用对应的方法
//2. 创建一个需要操作的 BigDecimal 然后调用相应的方法即可
System.out.println(bigDecimal.add(bigDecimal2));
System.out.println(bigDecimal.subtract(bigDecimal2));
System.out.println(bigDecimal.multiply(bigDecimal2));
//System.out.println(bigDecimal.divide(bigDecimal2));//可能抛出异常 ArithmeticException
//在调用 divide 方法时，指定精度即可. BigDecimal.ROUND_CEILING
//如果有无限循环小数，就会保留 分子 的精度
System.out.println(bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING));
&#125;
</code></pre>
<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="Date-第一代日期类"><a href="#Date-第一代日期类" class="headerlink" title="Date-第一代日期类"></a>Date-第一代日期类</h3><ol>
<li><p>Date：精确到毫秒，代表特定的瞬间</p>
</li>
<li><p>SimpleDateFormat：格式和解析日期的类</p>
<p>SimpleDateFormat 格式化和解析日期的具体类</p>
</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613195327856.png" alt="image-20220613195327856"></p>
<pre><code class="java">//1. 获取当前系统时间
//2. 这里的 Date 类是在 java.util 包
//3. 默认输出的日期格式是国外的方式, 因此通常需要对格式进行转换
Date d1 = new Date(); //获取当前系统时间
System.out.println(&quot;当前日期=&quot; + d1);
Date d2 = new Date(9234567); //通过指定毫秒数得到时间
System.out.println(&quot;d2=&quot; + d2); //获取某个时间对应的毫秒数

SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy 年 MM 月 dd 日 hh:mm:ss E&quot;);
String format = sdf.format(d1); // format:将日期转换成指定格式的字符串
System.out.println(&quot;当前日期=&quot; + format);

//1. 可以把一个格式化的 String 转成对应的 Date
//2. 得到 Date 仍然在输出时，还是按照国外的形式，如果希望指定格式输出，需要转换
//3. 在把 String -&gt; Date ， 使用的 sdf 格式需要和你给的 String 的格式一样，否则会抛出转换异常 
String s = &quot;1996 年 01 月 01 日 10:20:30 星期一&quot;;
Date parse = sdf.parse(s);
System.out.println(&quot;parse=&quot; + sdf.format(parse))
</code></pre>
<h3 id="Calendar-第二代日期类"><a href="#Calendar-第二代日期类" class="headerlink" title="Calendar-第二代日期类"></a>Calendar-第二代日期类</h3><ol>
<li>第二代日期类，主要就是Calender类（日历）</li>
<li>Calendar类是一个抽象类，他为特定瞬间与一组诸如Year，MONTH\DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法</li>
</ol>
<pre><code class="java">import java.util.Calendar;
/**
* @author 韩顺平
* @version 1.0
*/
public class Calendar_ &#123;
public static void main(String[] args) &#123;
//老韩解读
//1. Calendar 是一个抽象类， 并且构造器是 private
//2. 可以通过 getInstance() 来获取实例
//3. 提供大量的方法和字段提供给程序员
//4. Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)
//5. 如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成=&gt; Calendar.HOUR_OF_DAY
Calendar c = Calendar.getInstance(); //创建日历类对象//比较简单，自由
System.out.println(&quot;c=&quot; + c);
//2.获取日历对象的某个日历字段
System.out.println(&quot;年：&quot; + c.get(Calendar.YEAR));
// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号
System.out.println(&quot;月：&quot; + (c.get(Calendar.MONTH) + 1));
System.out.println(&quot;日：&quot; + c.get(Calendar.DAY_OF_MONTH));
System.out.println(&quot;小时：&quot; + c.get(Calendar.HOUR));
System.out.println(&quot;分钟：&quot; + c.get(Calendar.MINUTE));
System.out.println(&quot;秒：&quot; + c.get(Calendar.SECOND));
//Calender 没有专门的格式化方法，所以需要程序员自己来组合显示
System.out.println(c.get(Calendar.YEAR) + &quot;-&quot; + (c.get(Calendar.MONTH) + 1) + &quot;-&quot; +
c.get(Calendar.DAY_OF_MONTH) +
&quot; &quot; + c.get(Calendar.HOUR_OF_DAY) + &quot;:&quot; + c.get(Calendar.MINUTE) + &quot;:&quot; + c.get(Calendar.SECOND) );
&#125;
&#125;
</code></pre>
<h3 id="LocalDate-第三代日期类"><a href="#LocalDate-第三代日期类" class="headerlink" title="LocalDate-第三代日期类"></a>LocalDate-第三代日期类</h3><h4 id="前面两代的不足"><a href="#前面两代的不足" class="headerlink" title="前面两代的不足"></a>前面两代的不足</h4><p>JDK1.0包含了一个java.util.Date类，但是他的大多数方法在JDK1.1引入Calendar类之后被弃用了。</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613200338257.png" alt="image-20220613200338257"></p>
<h4 id="类和方法"><a href="#类和方法" class="headerlink" title="类和方法"></a>类和方法</h4><ol>
<li>LocalDate（日期&#x2F;年月日）</li>
<li>LocalTime（时间&#x2F;时分秒）</li>
<li>LocalDateTime（日期时间&#x2F;年月日时分秒）JDK8加入</li>
</ol>
<p>LocalDate只包含日期，可以获取日期字段</p>
<p>LocalTime只包含时间，可以获取时间字段</p>
<p>LocalDateTime包含日期+时间，可以获取日期和时间字段</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613201622392.png" alt="image-20220613201622392"></p>
<h4 id="DateTimeFormatter-格式日期类"><a href="#DateTimeFormatter-格式日期类" class="headerlink" title="DateTimeFormatter 格式日期类"></a>DateTimeFormatter 格式日期类</h4><p>类似于SimpleDateFormat</p>
<pre><code class="java">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
</code></pre>
<h4 id="Instant时间戳"><a href="#Instant时间戳" class="headerlink" title="Instant时间戳"></a>Instant时间戳</h4><p>类似于Date</p>
<p>提供了一系列和Date类转换的方式</p>
<pre><code class="java">//Instant——&gt;Date
Date date = Date.from(instant);
//Date——&gt;Instant
Instant instant = date.toInstant();

    public static void main(String[] args) &#123;
        Instant now = Instant.now();
        System.out.println(now);
        Date from = Date.from(now);
        System.out.println(from);
        Instant instant = from.toInstant();
        System.out.println(instant);
        &#125;
/*
2022-06-13T12:15:34.762Z
Mon Jun 13 20:15:34 CST 2022
2022-06-13T12:15:34.762Z
*/
</code></pre>
<pre><code class="java">import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collection;
/*
* @author 韩顺平
* @version 1.0
*/
public class LocalDate_ &#123;
public static void main(String[] args) &#123;
//第三代日期
//老韩解读
//1. 使用 now() 返回表示当前日期时间的 对象
LocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now()
System.out.println(ldt);
//2. 使用 DateTimeFormatter 对象来进行格式化
// 创建 DateTimeFormatter 对象
DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
String format = dateTimeFormatter.format(ldt);
System.out.println(&quot;格式化的日期=&quot; + format);
System.out.println(&quot;年=&quot; + ldt.getYear());
System.out.println(&quot;月=&quot; + ldt.getMonth());
System.out.println(&quot;月=&quot; + ldt.getMonthValue());
System.out.println(&quot;日=&quot; + ldt.getDayOfMonth());
System.out.println(&quot;时=&quot; + ldt.getHour());
System.out.println(&quot;分=&quot; + ldt.getMinute());
System.out.println(&quot;秒=&quot; + ldt.getSecond());
LocalDate now = LocalDate.now(); //可以获取年月日
LocalTime now2 = LocalTime.now();//获取到时分秒
    
//提供 plus 和 minus 方法可以对当前时间进行加或者减
//看看 890 天后，是什么时候 把 年月日-时分秒
LocalDateTime localDateTime = ldt.plusDays(890);
System.out.println(&quot;890 天后=&quot; + dateTimeFormatter.format(localDateTime));
//看看在 3456 分钟前是什么时候，把 年月日-时分秒输出
LocalDateTime localDateTime2 = ldt.minusMinutes(3456);
System.out.println(&quot;3456 分钟前 日期=&quot; + dateTimeFormatter.format(localDateTime2));
&#125;
&#125;
</code></pre>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="数组的不足"><a href="#数组的不足" class="headerlink" title="数组的不足"></a>数组的不足</h2><ol>
<li>长度开始时必须指定，一旦指定后，不能更改</li>
<li>保存的必须为同一类型的元素</li>
<li>使用数组进行增加&#x2F;删除元素的示意代码，比较麻烦</li>
</ol>
<h2 id="集合的好处"><a href="#集合的好处" class="headerlink" title="集合的好处"></a>集合的好处</h2><ol>
<li>可以动态保存任意多个对象，使用比较方便</li>
<li>提供了一系列方便的操作对象的方法，add、remove、set、get等</li>
<li>使用集合添加，删除元素，简洁明了</li>
</ol>
<h2 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h2><p>Java 的集合类很多，主要分为两大类，如图 ：[背下来]</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613232138059.png" alt="image-20220613232138059"></p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220613232151016.png" alt="image-20220613232151016"></p>
<h2 id="Collection-接口和常用方法"><a href="#Collection-接口和常用方法" class="headerlink" title="Collection 接口和常用方法"></a>Collection 接口和常用方法</h2><pre><code class="java">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;

&#125;
</code></pre>
<ol>
<li>Collection 实现子类可以存放多个元素，每个元素可以是Object</li>
<li>有些Collection的实现类，可以存放重复的元素，有些不可以</li>
<li>有些Collection的实现类，有些是有序的（List），有些不是有序（Set）</li>
<li>Collection 接口没有直接的实现子类，是通过他的子接口Set和List实现的</li>
</ol>
<pre><code class="java">    public static void main(String[] args) &#123;
        List list = new ArrayList();
        // add:添加单个元素
        list.add(&quot;jack&quot;);
        list.add(10);//list.add(new Integer(10))
        list.add(true);
        System.out.println(&quot;list=&quot; + list);
        
        // remove:删除指定元素
        //list.remove(0);//删除第一个元素
        list.remove(true);//指定删除某个元素
        System.out.println(&quot;list=&quot; + list);
        
        // contains:查找元素是否存在
        System.out.println(list.contains(&quot;jack&quot;));//T
        
        // size:获取元素个数
        System.out.println(list.size());//2
        
        // isEmpty:判断是否为空
        System.out.println(list.isEmpty());//F
        
        // clear:清空
        list.clear();
        System.out.println(&quot;list=&quot; + list);
        
        // addAll:添加多个元素
        ArrayList list2 = new ArrayList();
        list2.add(&quot;红楼梦&quot;);
        list2.add(&quot;三国演义&quot;);
        list.addAll(list2);
        System.out.println(&quot;list=&quot; + list);
        
        // containsAll:查找多个元素是否都存在
        System.out.println(list.containsAll(list2));//T
        // removeAll：删除多个元素
        list.add(&quot;聊斋&quot;);
        list.removeAll(list2);
        System.out.println(&quot;list=&quot; + list);//[聊斋]
        // 说明：以 ArrayList 实现类来演示. &#125;
    &#125;
</code></pre>
<h3 id="Collection-接口遍历-Iterator（迭代器）"><a href="#Collection-接口遍历-Iterator（迭代器）" class="headerlink" title="Collection 接口遍历-Iterator（迭代器）"></a>Collection 接口遍历-Iterator（迭代器）</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220614001447883.png" alt="image-20220614001447883"></p>
<ol>
<li>Iterator对象成为迭代器，主要用于便利Collection集合中的元素</li>
<li>所有实现了Collection接口的集合类都有一个iterator()方法，用以返回<br>一个实现了Iterator接口的对象，即可以返回一个迭代器。</li>
<li>Iterator接口，看上图。</li>
<li>Iterator仅用于遍历集合，Iterator本身并不存放对象</li>
</ol>
<h4 id="迭代器执行原理"><a href="#迭代器执行原理" class="headerlink" title="迭代器执行原理"></a>迭代器执行原理</h4><p>Iterator iterator &#x3D; collection.iterator();得到一个集合的迭代器</p>
<p>hasNext()：判断是否还有下一个元素</p>
<p>next()：1.下移2.将下移以后集合位置上的元素返回</p>
<p>在调用next()；方法之前调用hasNext()；方法进行检测。若不检测，如果下一条记录无效，调用next();方法，会抛出NoSuchElementException异常。</p>
<pre><code class="java">while(iterator.hasNext())&#123;
//next()作用1.下移2.将下移以后集合位置上的元素返回
&#125;
</code></pre>
<h4 id="迭代器实例"><a href="#迭代器实例" class="headerlink" title="迭代器实例"></a>迭代器实例</h4><pre><code class="java">/**
* @author 韩顺平
* @version 1.0
*/
public class CollectionIterator &#123;
    @SuppressWarnings(&#123;&quot;all&quot;&#125;)
public static void main(String[] args) &#123;
Collection col = new ArrayList();
col.add(new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;, 10.1));
col.add(new Book(&quot;小李飞刀&quot;, &quot;古龙&quot;, 5.1));
col.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 34.6));
//System.out.println(&quot;col=&quot; + col);
//现在老师希望能够遍历 col 集合
//1. 先得到 col 对应的 迭代器
Iterator iterator = col.iterator();
//2. 使用 while 循环遍历
// while (iterator.hasNext()) &#123;//判断是否还有数据
// //返回下一个元素，类型是 Object
// Object obj = iterator.next();
// System.out.println(&quot;obj=&quot; + obj);
// &#125;
//老师教大家一个快捷键，快速生成 while =&gt; itit
//显示所有的快捷键的的快捷键 ctrl + j
while (iterator.hasNext()) &#123;
Object obj = iterator.next();
System.out.println(&quot;obj=&quot; + obj);
&#125;
//3. 当退出 while 循环后 , 这时 iterator 迭代器，指向最后的元素
// iterator.next();//NoSuchElementException
//4. 如果希望再次遍历，需要重置我们的迭代器
iterator = col.iterator();
System.out.println(&quot;===第二次遍历===&quot;);
while (iterator.hasNext()) &#123;
Object obj = iterator.next();
System.out.println(&quot;obj=&quot; + obj);
&#125;
&#125;
&#125;
class Book &#123;
private String name;
private String author;
private double price;
public Book(String name, String author, double price) &#123;
this.name = name;
this.author = author;
this.price = price;
&#125;
public String getName() &#123;
return name;
&#125;
public void setName(String name) &#123;
this.name = name;
&#125;
public String getAuthor() &#123;
return author;
&#125;
public void setAuthor(String author) &#123;
this.author = author;
&#125;
public double getPrice() &#123;
return price;
&#125;
public void setPrice(double price) &#123;
this.price = price;
&#125;
@Override
public String toString()&#123;
return &quot;Book&#123;&quot; +
&quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
&quot;, author=&#39;&quot; + author + &#39;\&#39;&#39; +
&quot;, price=&quot; + price +
&#39;&#125;&#39;;
&#125;
&#125;
</code></pre>
<h3 id="Collection接口遍历2-for循环增强"><a href="#Collection接口遍历2-for循环增强" class="headerlink" title="Collection接口遍历2-for循环增强"></a>Collection接口遍历2-for循环增强</h3><p>增强for循环，可以代替iterator迭代器，特点，增强for就是简化版的iterator，本质一样，之恩那个用于遍历集合或数组。</p>
<pre><code class="java">for(元素类型 元素名: 集合名或数组名)&#123;
访问元素
&#125;
</code></pre>
<h2 id="List接口和常用方法"><a href="#List接口和常用方法" class="headerlink" title="List接口和常用方法"></a>List接口和常用方法</h2><p>List接口是Collection接口的子接口</p>
<ol>
<li><p>List集合类中元素有序（即添加顺序和取出顺序一致）、且可重复</p>
</li>
<li><p>List集合中的每个元素都有其对应的顺序索引，即支持索引</p>
</li>
<li><p>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</p>
</li>
<li><p>List接口的实现类有：</p>
</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220614005058239.png" alt="image-20220614005058239"></p>
<h3 id="List常用方法"><a href="#List常用方法" class="headerlink" title="List常用方法"></a>List常用方法</h3><pre><code class="java">public class ListMethod &#123;
@SuppressWarnings(&#123;&quot;all&quot;&#125;)
public static void main(String[] args) &#123;
List list = new ArrayList();
list.add(&quot;张三丰&quot;);
list.add(&quot;贾宝玉&quot;);
// void add(int index, Object ele):在 index 位置插入 ele 元素
//在 index = 1 的位置插入一个对象
list.add(1, &quot;韩顺平&quot;);
System.out.println(&quot;list=&quot; + list
                   
// boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来
List list2 = new ArrayList();
list2.add(&quot;jack&quot;);
list2.add(&quot;tom&quot;);
list.addAll(1, list2);
System.out.println(&quot;list=&quot; + list);
                   
// Object get(int index):获取指定 index 位置的元素
//说过
                   
// int indexOf(Object obj):返回 obj 在集合中首次出现的位置
System.out.println(list.indexOf(&quot;tom&quot;));//2
                   
// int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置
list.add(&quot;韩顺平&quot;);
System.out.println(&quot;list=&quot; + list);
System.out.println(list.lastIndexOf(&quot;韩顺平&quot;));
                   
// Object remove(int index):移除指定 index 位置的元素，并返回此元素
list.remove(0);
System.out.println(&quot;list=&quot; + list);
                   
// Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换. list.set(1, &quot;玛丽&quot;);
System.out.println(&quot;list=&quot; + list);
                   
// List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合
// 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex
List returnlist = list.subList(0, 2);
System.out.println(&quot;returnlist=&quot; + returnlist);
&#125;
&#125;


/*
list=[张三丰, 韩顺平, 贾宝玉]
list=[张三丰, jack, tom, 韩顺平, 贾宝玉]
2
list=[张三丰, jack, tom, 韩顺平, 贾宝玉, 韩顺平]
5
list=[jack, tom, 韩顺平, 贾宝玉, 韩顺平]
list=[jack, tom, 韩顺平, 贾宝玉, 韩顺平]
returnlist=[jack, tom]
*/
</code></pre>
<h3 id="List-的三种遍历方式-ArrayList，LinkedList，Vector"><a href="#List-的三种遍历方式-ArrayList，LinkedList，Vector" class="headerlink" title="List 的三种遍历方式 [ArrayList，LinkedList，Vector]"></a>List 的三种遍历方式 [ArrayList，LinkedList，Vector]</h3><ol>
<li>使用iterator</li>
</ol>
<pre><code class="java">//遍历
//1. 迭代器
Iterator iterator = list.iterator();
while (iterator.hasNext()) &#123;
Object obj = iterator.next();
System.out.println(obj);
&#125;
</code></pre>
<ol start="2">
<li>增强for</li>
</ol>
<pre><code class="java">for (Object o : list) &#123;
System.out.println(&quot;o=&quot; + o);
&#125;
</code></pre>
<ol start="3">
<li>使用普通for</li>
</ol>
<pre><code class="java">for (int i = 0; i &lt; list.size()&#123;
System.out.println(&quot;对象=&quot; + list.get(i));
&#125;
</code></pre>
<h3 id="ArrayList注意事项"><a href="#ArrayList注意事项" class="headerlink" title="ArrayList注意事项"></a>ArrayList注意事项</h3><ol>
<li>permits all elements,including nulll,ArrayList可以加入null，并且多个</li>
<li>ArrayList是由数组来实现数组存储的</li>
<li>ArrayList基本等同于Vector，除了ArrayList是线程不安全的（执行效率高），看源码，没有<code>synchronized</code>修饰。在多线程情况下，不建议使用ArrayList。</li>
</ol>
<h3 id="ArrayList底层操作即源码分析"><a href="#ArrayList底层操作即源码分析" class="headerlink" title="ArrayList底层操作即源码分析"></a>ArrayList底层操作即源码分析</h3><ol>
<li><p>ArrayList中维护了一个Object类型的数组elementData</p>
<pre><code class="java">    /**
     * The array buffer into which the elements of the ArrayList are stored.
     * The capacity of the ArrayList is the length of this array buffer. Any
     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
     * will be expanded to DEFAULT_CAPACITY when the first element is added.
     */
    transient Object[] elementData; // non-private to simplify nested class access
//transient 表示不会被序列化，短暂的，瞬间的。
</code></pre>
</li>
<li><p>当创建ArrayList对象时，如果使用的是无参构造器，则初始化容量为0，第一次添加，扩容elementData为10，如果需要再次扩容，则扩容elementData为1.5倍。10*1.5&#x3D;15</p>
</li>
<li><p>如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍。</p>
</li>
</ol>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><pre><code class="java">@SuppressWarnings(&#123;&quot;all&quot;&#125;)
public class ArrayListSource&#123;
public static void main(String[] args) &#123;
//老韩解读源码
//注意，注意，注意，Idea 默认情况下，Debug 显示的数据是简化后的，如果希望看到完整的数据
//需要做设置. //使用无参构造器创建 ArrayList 对象
//ArrayList list = new ArrayList();
ArrayList list = new ArrayList(8);
//使用 for 给 list 集合添加 1-10 数据
for (int i = 1; i &lt;= 10; i++) &#123;
list.add(i);
&#125;
//使用 for 给 list 集合添加 11-15 数据
for (int i = 11; i &lt;= 15; i++) &#123;
list.add(i);
&#125;
list.add(100);
list.add(200);
list.add(null);
&#125;
&#125;
</code></pre>
<p>IDEA设置</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220614122529062.png" alt="IDEA设置"></p>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="/java/java-xue-xi-wen-dang/image-20220614121227957.png" alt="image-20220614121227957"></p>
<h3 id="Vector-底层结构和源码剖析"><a href="#Vector-底层结构和源码剖析" class="headerlink" title="Vector 底层结构和源码剖析"></a>Vector 底层结构和源码剖析</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220614121347236.png" alt="image-20220614121347236"></p>
<ol>
<li>Vector类定义如上图</li>
<li>Vector底层也是一个对象数组，Protected Object[] elementData；</li>
<li>Vector是线程同步的，及线程安全的，Vector类操作方法带有<code>synchronized</code></li>
<li>开发中，需要线程同步安全时，使用Vector</li>
</ol>
<p>下面是代码的实例，要看具体过程自己查看源码</p>
<pre><code class="java">/**
* @author 韩顺平
* @version 1.0
*/
@SuppressWarnings(&#123;&quot;all&quot;&#125;)
public class Vector_ &#123;
public static void main(String[] args) &#123;
//无参构造器
//有参数的构造
Vector vector = new Vector(8);
for (int i = 0; i &lt; 10; i++) &#123;
vector.add(i);
&#125;
vector.add(100);
System.out.println(&quot;vector=&quot; + vector);


//老韩解读源码
//1. new Vector() 底层
/*
public Vector() &#123;
this(10);
&#125;
补充：如果是 Vector vector = new Vector(8);
走的方法:
public Vector(int initialCapacity) &#123;
this(initialCapacity, 0);
&#125;
2. vector.add(i)
2.1 //下面这个方法就添加数据到 vector 集合
public synchronized boolean add(E e) &#123;
modCount++;
ensureCapacityHelper(elementCount + 1);
elementData[elementCount++] = e;
return true;
&#125;
2.2 //确定是否需要扩容 条件 ： minCapacity - elementData.length&gt;0
private void ensureCapacityHelper(int minCapacity) &#123;
// overflow-conscious code
if (minCapacity - elementData.length &gt; 0
grow(minCapacity);
&#125;
2.3 //如果 需要的数组大小 不够用，就扩容 , 扩容的算法
//newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?
// capacityIncrement : oldCapacity);
//就是扩容两倍. private void grow(int minCapacity) &#123;
// overflow-conscious code
int oldCapacity = elementData.length;
int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?
capacityIncrement : oldCapacity);
if (newCapacity - minCapacity &lt; 0)
newCapacity = minCapacity;
if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
newCapacity = hugeCapacity(minCapacity);
elementData = Arrays.copyOf(elementData, newCapacity);
&#125;
*/
&#125;
&#125;
</code></pre>
<h3 id="Vector底层结构和ArrayList比较"><a href="#Vector底层结构和ArrayList比较" class="headerlink" title="Vector底层结构和ArrayList比较"></a>Vector底层结构和ArrayList比较</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220614121730002.png" alt="image-20220614121730002"></p>
<h3 id="LinkedList底层结构"><a href="#LinkedList底层结构" class="headerlink" title="LinkedList底层结构"></a>LinkedList底层结构</h3><ol>
<li><p>LinkedList底层实现了双向链表</p>
</li>
<li><p>可以添加任意元素（元素可以重复），包含null</p>
</li>
<li><p>线程不安全，没有实现同步</p>
</li>
</ol>
<h4 id="LinkedList-的底层操作机制"><a href="#LinkedList-的底层操作机制" class="headerlink" title="LinkedList 的底层操作机制"></a>LinkedList 的底层操作机制</h4><ol>
<li><p>LinkedList底层维护了一个双向链表</p>
</li>
<li><p>LinkedList中维护了两个属性first和last分别指向 首节点和尾节点</p>
</li>
<li><p>每个节点（Node对象）,俩面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个节点。最终实现双向链表</p>
</li>
<li><p>所以LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高。</p>
</li>
</ol>
<h4 id="模拟一个简单的双向链表"><a href="#模拟一个简单的双向链表" class="headerlink" title="模拟一个简单的双向链表"></a>模拟一个简单的双向链表</h4><pre><code class="java">//定义一个 Node 类，Node 对象 表示双向链表的一个结点
class Node &#123;
public Object item; //真正存放数据
public Node next; //指向后一个结点
public Node pre; //指向前一个结点
public Node(Object name) &#123;
this.item = name;
&#125;
public String toString() &#123;
return &quot;Node name=&quot; + item;
&#125;
&#125;
</code></pre>
<pre><code class="java">public class LinkedList01 &#123;
public static void main(String[] args) &#123;
//模拟一个简单的双向链表
Node jack = new Node(&quot;jack&quot;);
Node tom = new Node(&quot;tom&quot;);
Node hsp = new Node(&quot;老韩&quot;);
//连接三个结点，形成双向链表
//jack -&gt; tom -&gt; hsp
jack.next = tom;
tom.next = hsp;
//hsp -&gt; tom -&gt; jack
hsp.pre = tom;
tom.pre = jack;
Node first = jack;//让 first 引用指向 jack,就是双向链表的头结点
Node last = hsp; //让 last 引用指向 hsp,就是双向链表的尾结点
//演示，从头到尾进行遍历
System.out.println(&quot;===从头到尾进行遍历===&quot;);
while (true) &#123;
if(first == null) &#123;
break;
&#125;
//输出 first 信息
System.out.println(first);
first 
&#125;

//演示，从尾到头的遍历
System.out.println(&quot;====从尾到头的遍历====&quot;);
while (true) &#123;
if(last == null) &#123;
break;
&#125;
//输出 last 信息
System.out.println(last);
last = last.pre;
&#125;


//演示链表的添加对象/数据，是多么的方便
//要求，是在 tom --------- 老韩直接，插入一个对象 smith
//1. 先创建一个 Node 结点，name 就是 smith
Node smith = new Node(&quot;smith&quot;);
//下面就把 smith 加入到双向链表了
smith.next = hsp;
smith.pre = tom;
hsp.pre = smith;
tom.next = smith;

//让 first 再次指向 jack
first = jack;//让 first 引用指向 jack,就是双向链表的头结点
System.out.println(&quot;===从头到尾进行遍历===&quot;);
while (true) &#123;
if(first == null) &#123;
break;
&#125;
//输出 first 信息
System.out.println(first);
first = first.next;
&#125;

last = hsp; //让 last 重新指向最后一个结点
//演示，从尾到头的遍历
System.out.println(&quot;====从尾到头的遍历====&quot;);
while (true) &#123;
if(last == null) &#123;
break;
&#125;
//输出 last 信息
System.out.println(last);
last = last.pre;
&#125;
&#125;
&#125;
</code></pre>
<h4 id="LinkedList-的增删改查案例"><a href="#LinkedList-的增删改查案例" class="headerlink" title="LinkedList 的增删改查案例"></a>LinkedList 的增删改查案例</h4><pre><code class="java">/**
* @author 韩顺平
* @version 1.0
*/
@SuppressWarnings(&#123;&quot;all&quot;&#125;)
public class LinkedListCRUD &#123;
public static void main(String[] args) &#123;
LinkedList linkedList = new LinkedList();
linkedList.add(1);
linkedList.add(2);
linkedList.add(3);
System.out.println(&quot;linkedList=&quot; + linkedList);
//演示一个删除结点的
linkedList.remove(); // 这里默认删除的是第一个结点
//linkedList.remove(2);
System.out.println(&quot;linkedList=&quot; + linkedList);
//修改某个结点对象
linkedList.set(1, 999);
System.out.println(&quot;linkedList=&quot; + linkedList);
//得到某个结点对象
//get(1) 是得到双向链表的第二个对象
Object o = linkedList.get(1);
System.out.println(o);//999
//因为 LinkedList 是 实现了 List 接口, 遍历方式
System.out.println(&quot;===LinkeList 遍历迭代器====&quot;);
Iterator iterator = linkedList.iterator();
while (iterator.hasNext()) &#123;
Object next = iterator.next();
System.out.println(&quot;next=&quot; + next);
&#125;
System.out.println(&quot;===LinkeList 遍历增强 for====&quot;);
for (Object o1 : linkedList) &#123;
System.out.println(&quot;o1=&quot; + o1);
&#125;
System.out.println(&quot;===LinkeList 遍历普通 for====&quot;);
for (int i = 0; i &lt; linkedList.size(); i++) &#123;
System.out.println(linkedList.get(i));
&#125;
//老韩源码阅读. /* 1. LinkedList linkedList = new LinkedList();
public LinkedList() &#123;&#125;
2. 这时 linkeList 的属性 first = null last = null
3. 执行 添加
public boolean add(E e) &#123;
linkLast(e);
return true;
&#125;
4.将新的结点，加入到双向链表的最后
void linkLast(E e) &#123;
final Node&lt;E&gt; l = last;
final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
last = newNode;
if (l == null)
first = newNode;
else
l.next = newNode;
size++;
modCount++;
&#125;
*/
/*
老韩读源码 linkedList.remove(); // 这里默认删除的是第一个结点
1. 执行 removeFirst
public E remove() &#123;
return removeFirst();
&#125;
2. 执行
public E removeFirst() &#123;
final Node&lt;E&gt; f = first;
if (f == null)
throw new NoSuchElementException();
return unlinkFirst(f);
&#125;
3. 执行 unlinkFirst, 将 f 指向的双向链表的第一个结点拿掉
private E unlinkFirst(Node&lt;E&gt; f) &#123;
// assert f == first &amp;&amp; f != null;
final E element = f.item;
final Node&lt;E&gt; next = f.next;
f.item = null;
f.next = null; // help GC
first = next;
if (next == null)
last = null;
else
next.prev = null;
size--;
modCount++;
return element;
&#125;
*/
&#125;
&#125;
</code></pre>
<h3 id="ArrayList和LinkedList比较"><a href="#ArrayList和LinkedList比较" class="headerlink" title="ArrayList和LinkedList比较"></a>ArrayList和LinkedList比较</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220614144502748.png" alt="image-20220614144502748"></p>
<p>如何选择ArrayList和LinkedList</p>
<ol>
<li>如果我们改查的操作多，选择ArrayList</li>
<li>如果我们增删操作多，选择LinkedList</li>
<li>一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList</li>
<li>在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另外一个模块是LinkedList，要根据业务来进行选择</li>
</ol>
<h2 id="Set接口和常用方法"><a href="#Set接口和常用方法" class="headerlink" title="Set接口和常用方法"></a>Set接口和常用方法</h2><h3 id="Set-接口基本介绍"><a href="#Set-接口基本介绍" class="headerlink" title="Set 接口基本介绍"></a>Set 接口基本介绍</h3><ol>
<li>无序，（添加和取出的顺序不一致），没有索引</li>
<li>不允许重复元素，最多包含一个Null</li>
<li>JDK API中Set接口的实现类有</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220614145003770.png" alt="image-20220614145003770"></p>
<h3 id="Set-接口的常用方法"><a href="#Set-接口的常用方法" class="headerlink" title="Set 接口的常用方法"></a>Set 接口的常用方法</h3><p>Set也是Collection接口的子接口，常用方法和Collection接口一样</p>
<h3 id="Set接口的便利方法"><a href="#Set接口的便利方法" class="headerlink" title="Set接口的便利方法"></a>Set接口的便利方法</h3><p>同Collection的遍历方式一样，因为Set接口是Collection接口的子接口。</p>
<ol>
<li>可以使用迭代器</li>
<li>增强for</li>
<li>不能使用索引的方式来获取</li>
</ol>
<h3 id="Set-接口的常用方法举例"><a href="#Set-接口的常用方法举例" class="headerlink" title="Set 接口的常用方法举例"></a>Set 接口的常用方法举例</h3><pre><code class="java">import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
/**
* @author 韩顺平
* @version 1.0
*/
@SuppressWarnings(&#123;&quot;all&quot;&#125;)
public class SetMethod &#123;
public static void main(String[] args) &#123;
//老韩解读
//1. 以 Set 接口的实现类 HashSet 来讲解 Set 接口的方法
//2. set 接口的实现类的对象(Set 接口对象), 不能存放重复的元素, 可以添加一个 null
//3. set 接口对象存放数据是无序(即添加的顺序和取出的顺序不一致)
//4. 注意：取出的顺序的顺序虽然不是添加的顺序，但是他的固定. 
    Set set = new HashSet();
set.add(&quot;john&quot;);
set.add(&quot;lucy&quot;);
set.add(&quot;john&quot;);//重复
set.add(&quot;jack&quot;);
set.add(&quot;hsp&quot;);
set.add(&quot;mary&quot;);
set.add(null);//
set.add(null);//再次添加 null
//顺序是固定的
for(int i = 0; i &lt;10;i ++) &#123;
System.out.println(&quot;set=&quot; + set);
&#125;
//遍历
//方式 1： 使用迭代器
System.out.println(&quot;=====使用迭代器====&quot;);
Iterator iterator = set.iterator();
while (iterator.hasNext()) &#123;
Object obj = iterator.next();
System.out.println(&quot;obj=&quot; + obj);
&#125;
set.remove(null);
//方式 2: 增强 for
System.out.println(&quot;=====增强 for====&quot;);
for (Object o : set) &#123;
System.out.println(&quot;o=&quot; + o);
&#125;
//set 接口对象，不能通过索引来获取
&#125;
&#125;
</code></pre>
<h3 id="Set接口实现类-HashSet"><a href="#Set接口实现类-HashSet" class="headerlink" title="Set接口实现类-HashSet"></a>Set接口实现类-HashSet</h3><h4 id="HashSet-全面说明"><a href="#HashSet-全面说明" class="headerlink" title="HashSet 全面说明"></a>HashSet 全面说明</h4><ol>
<li><p>HashSet实现了Set接口</p>
</li>
<li><p>HashSet实际上是HashMap</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220614150230761.png" alt="image-20220614150230761"></p>
</li>
<li><p>可以存放null值，但只能有一个</p>
</li>
<li><p>HashSet不保证元素是有序的，取决于hash后，在确定索引的结果（即，不保证存放元素的顺序和取出顺序一致）</p>
</li>
<li><p>不能用重复的元素&#x2F;对象。在前面Set接口使用已经讲过。</p>
</li>
<li><p>底层是HashMap，HashMap底层使用（数组+单向链表+红黑树）的方式实现的</p>
</li>
</ol>
<h4 id="HashSet案例（难点）"><a href="#HashSet案例（难点）" class="headerlink" title="HashSet案例（难点）"></a>HashSet案例（难点）</h4><pre><code class="java">class Dog &#123; //定义了 Dog 类
private String name;
public Dog(String name) &#123;
this.name = name;
&#125;
@Override
public String toString() &#123;
return &quot;Dog&#123;&quot; +
&quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
&#39;&#125;&#39;;
&#125;
&#125;
</code></pre>
<pre><code class="java">/**
* @author 韩顺平
* @version 1.0
*/
@SuppressWarnings(&#123;&quot;all&quot;&#125;)
public class HashSet01 &#123;
public static void main(String[] args) &#123;
HashSet set = new HashSet();
//说明
//1. 在执行 add 方法后，会返回一个 boolean 值
//2. 如果添加成功，返回 true, 否则返回 false
//3. 可以通过 remove 指定删除哪个对象
System.out.println(set.add(&quot;john&quot;));//T
System.out.println(set.add(&quot;lucy&quot;));//T
System.out.println(set.add(&quot;john&quot;));//F
System.out.println(set.add(&quot;jack&quot;));//T
System.out.println(set.add(&quot;Rose&quot;));//T
set.remove(&quot;john&quot;);
System.out.println(&quot;set=&quot; + set);//3 个
//
set = new HashSet();
System.out.println(&quot;set=&quot; + set);//0
//4 Hashset 不能添加相同的元素/数据?
set.add(&quot;lucy&quot;);//添加成功
set.add(&quot;lucy&quot;);//加入不了
//这两个对象在这里没有重写hash和equals方法，两个对象返回的是不同的值
set.add(new Dog(&quot;tom&quot;));//OK
set.add(new Dog(&quot;tom&quot;));//Ok
System.out.println(&quot;set=&quot; + set);
    
//在加深一下. 非常经典的面试题
//看源码，做分析， 先给小伙伴留一个坑，以后讲完源码，你就了然
//去看他的源码，即 add 到底发生了什么?=&gt; 底层机制. 
 //底层hash方法会调用
set.add(new String(&quot;hsp&quot;));//ok
set.add(new String(&quot;hsp&quot;));//加入不了. System.out.println(&quot;set=&quot; + set);
&#125;
&#125;
</code></pre>
<h4 id="HashSet面试题"><a href="#HashSet面试题" class="headerlink" title="HashSet面试题"></a>HashSet面试题</h4><pre><code class="java">set.add(new Dog(&quot;tom&quot;));//OK
set.add(new Dog(&quot;tom&quot;));//Ok
System.out.println(&quot;set=&quot; + set);
set.add(new String(&quot;hsp&quot;));//ok
set.add(new String(&quot;hsp&quot;));//加入不了. 为什么？
//hash+equals两个方法返回值相同就无法加入
</code></pre>
<h4 id="HashSet底层机制说明"><a href="#HashSet底层机制说明" class="headerlink" title="HashSet底层机制说明"></a>HashSet底层机制说明</h4><p>看源码！下面是简略总结</p>
<ol>
<li><p>HashSet底层是HashMap</p>
<pre><code class="java">    public HashSet() &#123;
        map = new HashMap&lt;&gt;();
    &#125;
</code></pre>
</li>
<li><p>会先创建一个16个长度的Node数组</p>
<pre><code class="java">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 1*2*2*2*2=16
Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
</code></pre>
</li>
<li><p>添加一个元素时，先得到Hash值，会转成-&gt;索引值</p>
<pre><code class="java">/*
private static final Object PRESENT = new Object();
Set相当于只使用了Map的Key，Value使用 PRESENT 填充的。
*/
public boolean add(E e) &#123;
    return map.put(e, PRESENT)==null;
&#125;

public V put(K key, V value) &#123;
        return putVal(hash(key), key, value, false, true);
&#125;
</code></pre>
</li>
<li><p>找到存储数据表table，看这个索引位置是否已经存放的有元素</p>
</li>
<li><p>如果没有，直接加入</p>
</li>
<li><p>如果有，调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后</p>
<pre><code class="java">    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else &#123;
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else &#123;
                for (int binCount = 0; ; ++binCount) &#123;
                    if ((e = p.next) == null) &#123;
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    &#125;
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                &#125;
            &#125;
            if (e != null) &#123; // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            &#125;
        &#125;
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    &#125;
</code></pre>
</li>
<li><p>在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小 &gt;&#x3D; MIN_TREEIFY_CAPACITY（默认64），就会进行数化（红黑树），不够64先会扩容<code>table</code>数组，</p>
<pre><code class="java">            else &#123;
                for (int binCount = 0; ; ++binCount) &#123;
                    if ((e = p.next) == null) &#123;
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // 8-1 for 1st 
                            treeifyBin(tab, hash);
                        break;
                    &#125;
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                &#125;
            &#125;
</code></pre>
<p><img src="/java/java-xue-xi-wen-dang/image-20220614174348275.png" alt="image-20220614174348275"></p>
</li>
</ol>
<h4 id="HashSet扩容和转成红黑树机制"><a href="#HashSet扩容和转成红黑树机制" class="headerlink" title="HashSet扩容和转成红黑树机制"></a>HashSet扩容和转成红黑树机制</h4><ol>
<li>HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子（loadFactor）0.75 &#x3D; 12</li>
<li>如果table数组使用到了临界值12，就会扩容到16*2 &#x3D; 32，新的临界值就是32 * 0.75 &#x3D; 24，以此类推</li>
<li>Java8中，如果一条链表的元素个数到达 TREEIFY_THRESHOLD(默认是8)，并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY（默认64），就会进行树化（红黑树），否则依然采用扩容机制</li>
<li>转换机制会对数组一个索引位置的元素进行转换，数组其他索引位置的元素不会发生转换操作，直到满足条件。</li>
</ol>
<pre><code class="java">if (binCount &gt;= TREEIFY_THRESHOLD - 1) // 8-1 for 1st 
    treeifyBin(tab, hash);
</code></pre>
<h4 id="HashSet扩容理解实例"><a href="#HashSet扩容理解实例" class="headerlink" title="HashSet扩容理解实例"></a>HashSet扩容理解实例</h4><pre><code class="java">/*1
看A类的hashCode方法，Hash值不同，会被分到不同的数组中
        if (++size &gt; threshold) 12+1 &gt; 13
            resize(); 扩容数组
*/
public static void main(String[] args) &#123;
    HashSet set = new HashSet();
        for (int i = 0; i &lt; 13; i++) &#123;
            set.add(new A(i));
        &#125;
    
class A &#123;
    private Integer aa;

    public A() &#123;
    &#125;

    public A(Integer aa) &#123;
        this.aa = aa;
    &#125;

    @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (!(o instanceof A)) return false;
        A a = (A) o;
        return Objects.equals(aa, a.aa);
    &#125;
    @Override
    public int hashCode() &#123;
        return Objects.hash(aa);
    &#125;
&#125;
</code></pre>
<p><img src="/java/java-xue-xi-wen-dang/image-20220614183854928.png" alt="image-20220614183854928"></p>
<pre><code class="java">/*2
看A类的hashCode方法，hash值一样会被分到同一个数组位置
if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
    treeifyBin(tab, hash);
    break;
*/
public static void main(String[] args) &#123;
    HashSet set = new HashSet();
        for (int i = 0; i &lt; 13; i++) &#123;
            set.add(new A(i));
        &#125;
    
class A &#123;
    private Integer aa;

    public A() &#123;
    &#125;

    public A(Integer aa) &#123;
        this.aa = aa;
    &#125;

    @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (!(o instanceof A)) return false;
        A a = (A) o;
        return Objects.equals(aa, a.aa);
    &#125;
    @Override
    public int hashCode() &#123;
        return 100;
    &#125;
&#125;
</code></pre>
<p><img src="/java/java-xue-xi-wen-dang/image-20220614184020108.png" alt="image-20220614184020108"></p>
<h3 id="Set-接口实现类-LinkedHashSet"><a href="#Set-接口实现类-LinkedHashSet" class="headerlink" title="Set 接口实现类-LinkedHashSet"></a>Set 接口实现类-LinkedHashSet</h3><ol>
<li>LinkedHashSet是HashSet的子类</li>
<li>LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表</li>
<li>LinkedHashSet根据元素的hashCode值来决定元素的存储位置。同时使用链表维护元素的&#x3D;&#x3D;次序&#x3D;&#x3D;，这使得元素看起来是以插入顺序保存的。</li>
<li>LinkedHashSet不允许添加重复元素。</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220614191124431.png" alt="image-20220614191124431"></p>
<p>数据存放在数组的索引位置不同，但是他们之间是有指向关系的。保存了插入的顺序。</p>
<ol>
<li><p>在LinkedHashSet维护了一个hash表（数组+哈希函数）和双向链表（LinkedHashSet 有 head和tail）</p>
</li>
<li><p>每一个节点都有before 和 after 属性，这样可以形成双向链表</p>
</li>
<li><p>在添加一个元素时，先求hash值，再求索引，确定该元素在table的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加）</p>
<pre><code class="java">tail.next = newElement
newElement.pre = tail
</code></pre>
</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220614200055057.png" alt="image-20220614200055057"></p>
<h3 id="Set接口实现类-TreeSet"><a href="#Set接口实现类-TreeSet" class="headerlink" title="Set接口实现类-TreeSet"></a>Set接口实现类-TreeSet</h3><ol>
<li><p>当使用无参构造器创建TreeSet时，他默认是无序的</p>
</li>
<li><p>可以调用有参构造器，进行排序，底层是TreeMap$Entry类型</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220615132501587.png" alt="image-20220615132501587"></p>
</li>
</ol>
<h4 id="TreeSet底层机制"><a href="#TreeSet底层机制" class="headerlink" title="TreeSet底层机制"></a>TreeSet底层机制</h4><ol>
<li>TreeSet底层是TreeMap</li>
<li>具体调用和之前类似，看源码。</li>
</ol>
<h2 id="Map-接口和常用方法"><a href="#Map-接口和常用方法" class="headerlink" title="Map 接口和常用方法"></a>Map 接口和常用方法</h2><p><img src="/java/java-xue-xi-wen-dang/image-20220613232151016.png" alt="image-20220613232151016"></p>
<h3 id="Map-接口实现类的特点-实用"><a href="#Map-接口实现类的特点-实用" class="headerlink" title="Map 接口实现类的特点[实用]"></a>Map 接口实现类的特点[实用]</h3><p>注意：这是JDK8的Map接口特点</p>
<ol>
<li>Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value</li>
<li>Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中</li>
<li>Map中的key不允许重复，原因和HashSet一样，前面分析过源码</li>
<li>Map中的value可以重复</li>
<li>Map的key 可以为null，value也可以为null，注意key 为null，只能有一个，value为null，可以多个</li>
<li>常用String类作为Map的key</li>
<li>key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value</li>
<li>Map存放数据的Key-Value示意图，一对k-v 是放在一个HashMap$Node中的，因为Node实现了Entry接口，有的书上也说一对kv就是一个Entry</li>
</ol>
<p>entrySet类底层存储的还是Node类</p>
<pre><code class="java">    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;
        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;
        return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;
    &#125;
</code></pre>
<p><img src="/java/java-xue-xi-wen-dang/image-20220614220252972.png" alt="image-20220614220252972"></p>
<pre><code class="java">    public static void main(String[] args) &#123;
        HashMap map = new HashMap&lt;Object,Object&gt;();
        map.put(null,null);
        map.put(&quot;null1&quot;,1);
        map.put(&quot;zsf&quot;,2);
        map.put(2,&quot;wangwu&quot;);
        System.out.println(map.get(2));//wangwu
        System.out.println(map);//&#123;null=null, 2=wangwu, zsf=2, null1=1&#125;
        Set keySet = map.keySet();
        System.out.println(keySet);//[null, 2, zsf, null1]
        Set set = map.entrySet();
        for(Object obj : set)&#123;
            System.out.println(obj.getClass());//class java.util.HashMap$Node
            Map.Entry entry = (Map.Entry)obj;
            System.out.println(entry.getKey()+&quot;    &quot;+entry.getValue());
        &#125;
        System.out.println(set);
    &#125;
</code></pre>
<p>HashMap是单向链表实现的，HashSet也是使用的这个</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220614212220227.png" alt="image-20220614212220227"></p>
<h3 id="Map的常用方法"><a href="#Map的常用方法" class="headerlink" title="Map的常用方法"></a>Map的常用方法</h3><pre><code class="java">/**
* @author 韩顺平
* @version 1.0
*/
@SuppressWarnings(&#123;&quot;all&quot;&#125;)
public class MapMethod &#123;
public static void main(String[] args) &#123;
//演示 map 接口常用方法
Map map = new HashMap();
map.put(&quot;邓超&quot;, new Book(&quot;&quot;, 100));//OK
map.put(&quot;邓超&quot;, &quot;孙俪&quot;);//替换-&gt; 一会分析源码
map.put(&quot;王宝强&quot;, &quot;马蓉&quot;);//OK
map.put(&quot;宋喆&quot;, &quot;马蓉&quot;);//OK
map.put(&quot;刘令博&quot;, null);//OK
map.put(null, &quot;刘亦菲&quot;);//OK
map.put(&quot;鹿晗&quot;, &quot;关晓彤&quot;);//OK
map.put(&quot;hsp&quot;, &quot;hsp 的老婆&quot;);
System.out.println(&quot;map=&quot; + map);
    
// remove:根据键删除映射关系
map.remove(null);
System.out.println(&quot;map=&quot; + map);
    
// get：根据键获取值
Object val = map.get(&quot;鹿晗&quot;);
System.out.println(&quot;val=&quot; + val);//关晓彤
    
// size:获取元素个数
System.out.println(&quot;k-v=&quot; + map.size());
    
// isEmpty:判断个数是否为 0
System.out.println(map.isEmpty());//F
    
// clear:清除 k-v
//map.clear();
System.out.println(&quot;map=&quot; + map);
// containsKey:查找键是否存在
System.out.println(&quot;结果=&quot; + map.containsKey(&quot;hsp&quot;));//T
&#125;
&#125;
class Book &#123;
private String name;
private int num;
public Book(String name, int num) &#123;
this.name = name;
this.num = num;
&#125;
&#125;
</code></pre>
<h3 id="Map接口遍历方式"><a href="#Map接口遍历方式" class="headerlink" title="Map接口遍历方式"></a>Map接口遍历方式</h3><ol>
<li>containsKey：查找健是否存在</li>
<li>keySet：获取所有键</li>
<li>entrySet：获取所有关系</li>
<li>values：获取所有的值</li>
</ol>
<pre><code class="java">package hsppedu.Homework.collection_homework;

import java.util.*;

/**
 * @author 张文辉
 * @version 1.0
 */
public class MapMethod &#123;
    public static void main(String[] args) &#123;
        //演示 map 接口常用方法
        Map map = new HashMap();
        map.put(&quot;邓超&quot;, new Book(&quot;aa&quot;, &quot;aa作者&quot;, 100));//OK
        map.put(&quot;邓超&quot;, &quot;孙俪&quot;);//替换-&gt; 一会分析源码
        map.put(&quot;王宝强&quot;, &quot;马蓉&quot;);//OK
        map.put(&quot;宋喆&quot;, &quot;马蓉&quot;);//OK
        map.put(&quot;刘令博&quot;, null);//OK
        map.put(null, &quot;刘亦菲&quot;);//OK
        map.put(&quot;鹿晗&quot;, &quot;关晓彤&quot;);//OK
        map.put(&quot;hsp&quot;, &quot;hsp 的老婆&quot;);
        System.out.println(&quot;map=&quot; + map);

        Set keySet = map.keySet();
        //(1) 增强 for
        System.out.println(&quot;-----第一种方式-------&quot;);
        for (Object key : keySet) &#123;
            System.out.println(key + &quot;-&quot; + map.get(key));
        &#125;
        //(2) 迭代器
        System.out.println(&quot;----第二种方式--------&quot;);
        Iterator iterator = keySet.iterator();
        while (iterator.hasNext()) &#123;
            Object key = iterator.next();
            System.out.println(key + &quot;-&quot; + map.get(key));
        &#125;
        //第二组: 把所有的 values 取出
        Collection values = map.values();
        //这里可以使用所有的 Collections 使用的遍历方法
        //(1) 增强 for
        System.out.println(&quot;---取出所有的 value 增强 for----&quot;);
        for (Object value : values) &#123;
            System.out.println(value);
        &#125;
        //(2) 迭代器
        System.out.println(&quot;---取出所有的 value 迭代器----&quot;);
        Iterator iterator2 = values.iterator();
        while (iterator2.hasNext()) &#123;
            Object value = iterator2.next();
            System.out.println(value);
        &#125;

        //第三组: 通过 EntrySet 来获取 k-v
        Set entrySet = map.entrySet();// EntrySet&lt;Map.Entry&lt;K,V&gt;&gt;
        //(1) 增强 for
        System.out.println(&quot;----使用 EntrySet 的 for 增强(第 3 种)----&quot;);
        for (Object entry : entrySet) &#123;
        //将 entry 转成 Map.Entry
            Map.Entry m = (Map.Entry) entry;
            System.out.println(m.getKey() + &quot;-&quot; + m.getValue());
        &#125;
        //(2) 迭代器
        System.out.println(&quot;----使用 EntrySet 的 迭代器(第 4 种)----&quot;);
        Iterator iterator3 = entrySet.iterator();
        while (iterator3.hasNext()) &#123;
            Object entry = iterator3.next();
//System.out.println(next.getClass());//HashMap$Node -实现-&gt; Map.Entry (getKey,getValue)
//向下转型 Map.Entry
            Map.Entry m = (Map.Entry) entry;
            System.out.println(m.getKey() + &quot;-&quot; + m.getValue());
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="HashMap小结"><a href="#HashMap小结" class="headerlink" title="HashMap小结"></a>HashMap小结</h3><ol>
<li>Map接口常用实现类：HashMap、Hashtable和Properties</li>
<li>HashMap是Map接口使用频率最高的实现类</li>
<li>HashMap是以key-val对的方式来存储数据（HashMap$Node类型）</li>
<li>key不能重复，但是值可以重复，允许使用null键和null值</li>
<li>如果添加相同的key，则会覆盖原来的key-val，等同于修改（key不会替换，value替换）</li>
<li>与HashSet一样，不保证映射的顺序，因为底层是hash表的方式来存储。（底层：数组+链表+红黑树（链表和红黑树结构可以同时存在））</li>
<li>HashMap没有实现同步，因此线程不安全。</li>
</ol>
<h3 id="底层示意图"><a href="#底层示意图" class="headerlink" title="底层示意图"></a>底层示意图</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220614230601814.png" alt="image-20220614230601814"></p>
<h3 id="HashMap扩容机制"><a href="#HashMap扩容机制" class="headerlink" title="HashMap扩容机制"></a>HashMap扩容机制</h3><p>和HashSet相同，HashSet就是HashMap。</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220614230651290.png" alt="image-20220614230651290"></p>
<h3 id="HashMap替换机制"><a href="#HashMap替换机制" class="headerlink" title="HashMap替换机制"></a>HashMap替换机制</h3><p>HashMap相同的Key输入，会把原来位置的Node对象value重新赋值</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220614231151540.png" alt="image-20220614231151540"></p>
<h3 id="HashMap底层机制说明"><a href="#HashMap底层机制说明" class="headerlink" title="HashMap底层机制说明"></a>HashMap底层机制说明</h3><ol>
<li>执行构造器，初始化加载因子</li>
</ol>
<pre><code class="java">    /**
     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity
     * (16) and the default load factor (0.75).
     */
    public HashMap() &#123;
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    &#125;
</code></pre>
<ol start="2">
<li>执行put方法，计算key的hash值</li>
</ol>
<pre><code class="java">map.put(null,null);    
public V put(K key, V value) &#123;
        return putVal(hash(key), key, value, false, true);
    &#125;
</code></pre>
<ol start="3">
<li>执行putVal方法</li>
<li>具体执行流程自己看源码！</li>
</ol>
<h3 id="Map接口实现类-HashTable"><a href="#Map接口实现类-HashTable" class="headerlink" title="Map接口实现类-HashTable"></a>Map接口实现类-HashTable</h3><ol>
<li>存放的是键值对：即K-V</li>
<li>hashtable的键和值都不能为null，否则会抛出NullPointException</li>
<li>hashTable 使用方法基本上和HashMap一样</li>
<li>HashTable是线程安全的（synchronized），hashMap是线程不安全的</li>
</ol>
<h4 id="HashTable底层机制"><a href="#HashTable底层机制" class="headerlink" title="HashTable底层机制"></a>HashTable底层机制</h4><ol>
<li>初始化容量是11</li>
<li>临界值 11 * 0.75</li>
<li>扩容是  （当前容量 * 2 ）+ 1</li>
</ol>
<pre><code class="java">    public Hashtable() &#123;
        this(11, 0.75f);
    &#125;
</code></pre>
<ol start="2">
<li>剩下看源码，基本上和之前的相同</li>
</ol>
<h3 id="HashTable和HashMap对比"><a href="#HashTable和HashMap对比" class="headerlink" title="HashTable和HashMap对比"></a>HashTable和HashMap对比</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220615121958797.png" alt="image-20220615121958797"></p>
<h3 id="Map接口实现类-Properties"><a href="#Map接口实现类-Properties" class="headerlink" title="Map接口实现类-Properties"></a>Map接口实现类-Properties</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220615123541279.png" alt="image-20220615123541279"></p>
<ol>
<li>Properties类继承自HashTable类并且实现了Map接口，并且是HashTable的子类，也是使用一种键值对方式来保存数据</li>
<li>使用和HashTable类似，k-v不能为Null</li>
<li>Properties还可以用于从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</li>
<li>xxx.properties文件通常作为配置文件，</li>
</ol>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><pre><code class="java">/**
* @author 韩顺平
* @version 1.0
*/
@SuppressWarnings(&#123;&quot;all&quot;&#125;)
public class Properties_ &#123;
public static void main(String[] args) &#123;
//老韩解读
//1. Properties 继承 Hashtable
//2. 可以通过 k-v 存放数据，当然 key 和 value 不能为 null
//增加
Properties properties = new Properties();
//properties.put(null, &quot;abc&quot;);//抛出 空指针异常
//properties.put(&quot;abc&quot;, null); //抛出 空指针异常
properties.put(&quot;john&quot;, 100);//k-v
properties.put(&quot;lucy&quot;, 100);
properties.put(&quot;lic&quot;, 100);
properties.put(&quot;lic&quot;, 88);//如果有相同的 key ， value 被替换
System.out.println(&quot;properties=&quot; + properties);
//通过 k 获取对应值
System.out.println(properties.get(&quot;lic&quot;));//88
//删除
properties.remove(&quot;lic&quot;);
System.out.println(&quot;properties=&quot; + properties);
//修改
properties.put(&quot;john&quot;, &quot;约翰&quot;);
System.out.println(&quot;properties=&quot; + properties);
&#125;
&#125;

/*
properties=&#123;john=100, lic=88, lucy=100&#125;
88
properties=&#123;john=100, lucy=100&#125;
properties=&#123;john=约翰, lucy=100&#125;
*/
</code></pre>
<h3 id="Map接口实现类-TreeMap"><a href="#Map接口实现类-TreeMap" class="headerlink" title="Map接口实现类-TreeMap"></a>Map接口实现类-TreeMap</h3><ol>
<li>使用默认无参构造器，创建TreeMap，也是无序的。</li>
<li>使用 TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类) 并指定排序规则</li>
</ol>
<pre><code class="java">**
* @author 韩顺平
* @version 1.0
*/
@SuppressWarnings(&#123;&quot;all&quot;&#125;)
public class TreeMap_ &#123;
public static void main(String[] args) &#123;
//使用默认的构造器，创建 TreeMap, 是无序的(也没有排序)
/*
老韩要求：按照传入的 k(String) 的大小进行排序
*/
// TreeMap treeMap = new TreeMap();
TreeMap treeMap = new TreeMap(new Comparator() &#123;
@Override
public int compare(Object o1, Object o2) &#123;
//按照传入的 k(String) 的大小进行排序
//按照 K(String) 的长度大小排序
//return ((String) o2).compareTo((String) o1);
return ((String) o2).length() - ((String) o1).length();
&#125;
&#125;);
treeMap.put(&quot;jack&quot;, &quot;杰克&quot;);
treeMap.put(&quot;tom&quot;, &quot;汤姆&quot;);
treeMap.put(&quot;kristina&quot;, &quot;克瑞斯提诺&quot;);
treeMap.put(&quot;smith&quot;, &quot;斯密斯&quot;);
treeMap.put(&quot;hsp&quot;, &quot;韩顺平&quot;);//加入不了
System.out.println(&quot;treemap=&quot; + treeMap);
/*
</code></pre>
<h2 id="集合选型规则"><a href="#集合选型规则" class="headerlink" title="集合选型规则"></a>集合选型规则</h2><p>kai发中，选择什么样的集合实现类，主要取决于业务操作特点，根据集合实现类特性选择：</p>
<ol>
<li>先判断存储类型</li>
<li>一组对象：Collection接口<ul>
<li>允许重复：&#x3D;&#x3D;List&#x3D;&#x3D;<ul>
<li>增删多：LinkedList【双向链表】</li>
<li>改查多：ArrayList【可变数组】</li>
</ul>
</li>
<li>不允许重复：&#x3D;&#x3D;Set&#x3D;&#x3D;<ul>
<li>无序：HashSet【底层HashMap，维护了一个hash表【数组+单向链表+红黑树】】</li>
<li>排序：&#x3D;&#x3D;TreeSet&#x3D;&#x3D;</li>
<li>插入和取出顺序一致：LinkedHashSet，维护数组+双向链表</li>
</ul>
</li>
</ul>
</li>
<li>一组键值对：Map<ul>
<li>键无序：HashMap【底层【数组+单向链表+红黑树】，JDK7只有【数组+单向链表】】</li>
<li>键排序：TreeMap</li>
<li>键插入和取出顺序一致：LinkedHashMap</li>
<li>读取文件 Properties</li>
</ul>
</li>
</ol>
<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><h3 id="Collections工具类介绍"><a href="#Collections工具类介绍" class="headerlink" title="Collections工具类介绍"></a>Collections工具类介绍</h3><ol>
<li>Collections是一个操作Set、List和Map等集合的工具类</li>
<li>Collections中提供了一系列静态方法对集合元素进行排序，查询，和修改操作</li>
</ol>
<h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h3><ol>
<li>reverse（List）：反转List中元素的顺序</li>
<li>shuffle（List）：对List集合元素进行随机排序</li>
<li>sort（List）：根据元素的自然顺序对指定List集合元素按升序排序</li>
<li>sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序</li>
<li>swap(List，int，int)：将指定list集合中的i处元素和j处元素进行交换</li>
</ol>
<h3 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h3><ol>
<li>Object max(Collection)：根据元素的自然排序，返回给定集合中的最大元素</li>
<li>Object max(Collection)：根据Comparator指定的顺序，返回给定集合中的最大元素</li>
<li>Object min(Collection)：</li>
<li>Object min(Collection，Comparator)：</li>
<li>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</li>
<li>void copy(List dest，List src)：将src中的内容复制到dest中</li>
<li>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换List对象的所有旧值。</li>
</ol>
<pre><code class="java">@SuppressWarnings(&#123;&quot;all&quot;&#125;)
public class Collections_ &#123;
public static void main(String[] args) &#123;
//创建 ArrayList 集合，用于测试. List list = new ArrayList();
list.add(&quot;tom&quot;);
list.add(&quot;smith&quot;);
list.add(&quot;king&quot;);
list.add(&quot;milan&quot;);
list.add(&quot;tom&quot;);
// reverse(List)：反转 List 中元素的顺序
Collections.reverse(list);
System.out.println(&quot;list=&quot; + list);
// shuffle(List)：对 List 集合元素进行随机排序
// for (int i = 0; i &lt; 5; i++) &#123;
// Collections.shuffle(list);
// System.out.println(&quot;list=&quot; + list);
// &#125;
// sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序
Collections.sort(list);
System.out.println(&quot;自然排序后&quot;);
System.out.println(&quot;list=&quot; + list);
// sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序
//我们希望按照 字符串的长度大小排序
Collections.sort(list, new Comparator() &#123;
@Override
public int compare(Object o1, Object o2) &#123;
//可以加入校验代码. return ((String) o2).length() - ((String) o1).length();
&#125;
&#125;);
System.out.println(&quot;字符串长度大小排序=&quot; + list);
// swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换
//比如
Collections.swap(list, 0, 1);
System.out.println(&quot;交换后的情况&quot;);
System.out.println(&quot;list=&quot; + list);
//Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素
System.out.println(&quot;自然顺序最大元素=&quot; + Collections.max(list));
//Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素
//比如，我们要返回长度最大的元素
Object maxObject = Collections.max(list, new Comparator() &#123;
@Override
public int compare(Object o1, Object o2) &#123;
return ((String)o1).length() - ((String)o2).length();
&#125;
&#125;);
System.out.println(&quot;长度最大的元素=&quot; + maxObject);
//Object min(Collection)
//Object min(Collection，Comparator)
//上面的两个方法，参考 max 即可
//int frequency(Collection，Object)：返回指定集合中指定元素的出现次数
System.out.println(&quot;tom 出现的次数=&quot; + Collections.frequency(list, &quot;tom&quot;));
//void copy(List dest,List src)：将 src 中的内容复制到 dest 中
ArrayList dest = new ArrayList();
//为了完成一个完整拷贝，我们需要先给 dest 赋值，大小和 list.size()一样
for(int i = 0; i &lt; list.size(); i++) &#123;
dest.add(&quot;&quot;);
&#125;
//拷贝
Collections.copy(dest, list);
System.out.println(&quot;dest=&quot; + dest);
//boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值
//如果 list 中，有 tom 就替换成 汤姆
Collections.replaceAll(list, &quot;tom&quot;, &quot;汤姆&quot;);
System.out.println(&quot;list 替换后=&quot; + list);
&#125;
&#125;
</code></pre>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol>
<li>HashSet和TreeSet分别如何实现去重的？</li>
</ol>
<p>HashSet去重机制：Hashcode()+equals()，底层存入对象计算hash值，通过hash值得到对应的索引，去找table数组索引所在得位置，没有数据，直接存入，有数据，先进行equals方法比较，相同就不加入</p>
<p>TreeSet去重机制：如果传入一个Comparator对象，就调用comparator方法去重，返回0，代表相同元素，就不添加。如果没有传入Comparator对象，添加的对象必须实现Compareable接口的compareTo去重。</p>
<ol start="2">
<li>下面代码会报错吗？</li>
</ol>
<p>会报错，因为TreeSet调用CompareTo方法，而你没有，就会报错：</p>
<p><code>.Person cannot be cast to java.lang.Comparable</code></p>
<pre><code class="java">class Person&#123;&#125;
        TreeSet treeSet = new TreeSet();
        treeSet.add(new Person());
</code></pre>
<ol start="3">
<li>Vector和ArrayList比较？</li>
</ol>
<p><img src="/java/java-xue-xi-wen-dang/image-20220615160525782.png" alt="image-20220615160525782"></p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="传统方式问题"><a href="#传统方式问题" class="headerlink" title="传统方式问题"></a>传统方式问题</h2><ol>
<li>不能对加入到集合ArrayList中的数据类型进行约束（不安全）</li>
<li>便利的时候，需要进行类型转换，如果集合中数据量较大，对效率有影响。</li>
</ol>
<h2 id="泛型的理解和好处"><a href="#泛型的理解和好处" class="headerlink" title="泛型的理解和好处"></a>泛型的理解和好处</h2><h3 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220615174246909.png" alt="泛型的好处"></p>
<h2 id="泛型介绍"><a href="#泛型介绍" class="headerlink" title="泛型介绍"></a>泛型介绍</h2><ol>
<li>泛型又称参数化类型，是JDK5.0出现的新特性，解决数据类型的安全性问题</li>
<li>在类声明或实例化时，只要制定好需要的具体的类型即可</li>
<li>Java泛型可以保证如过程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁，健壮。</li>
<li>泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值类型，或者是参数类型。【下面是实例】</li>
</ol>
<pre><code class="java">class Person&lt;E&gt; &#123;
    E s;//E 表示 s 的数据类型, 该数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E 是什么类型

    public Person(E s) &#123;//E 也可以是参数类型
        this.s = s;
    &#125;

    public E f() &#123;//返回类型使用 E
        return s;
    &#125;

    public void show() &#123;
        System.out.println(s.getClass());//显示 s 的运行类型
    &#125;
&#125;
</code></pre>
<h2 id="泛型的声明"><a href="#泛型的声明" class="headerlink" title="泛型的声明"></a>泛型的声明</h2><ol>
<li>T,K,V不代表值，只是表示类型</li>
<li>任意字母都可以，常用T表示，是Type的缩写。</li>
</ol>
<pre><code class="java">interface 接口&lt;T&gt; 
class 类&lt;K,V&gt;&#123;&#125;
</code></pre>
<h2 id="泛型的实例化"><a href="#泛型的实例化" class="headerlink" title="泛型的实例化"></a>泛型的实例化</h2><pre><code class="java">//要在类名后面指定类型参数的值
List&lt;String&gt; strList = new ArrayList&lt;String&gt;();
Iterator&lt;CUstomer&gt; iterator = customers.iterator();
</code></pre>
<h2 id="泛型使用的注意事项和细节"><a href="#泛型使用的注意事项和细节" class="headerlink" title="泛型使用的注意事项和细节"></a>泛型使用的注意事项和细节</h2><ol>
<li><p>泛型只能是&#x3D;&#x3D;引用类型&#x3D;&#x3D;</p>
<p>interface List<T>{},public class HashSet<E>{}</E></T></p>
<pre><code class="java">List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();//OK
List&lt;int&gt; list = new ArrayList&lt;int&gt;();//NO
</code></pre>
</li>
<li><p>在给泛型指定具体类型后，可以传入该类型或者其子类类型</p>
</li>
<li><p>泛型使用形式</p>
<pre><code class="java">List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
List&lt;Integer&gt; list = new ArrayList&lt;&gt;();//自动类型推断
</code></pre>
</li>
<li><pre><code class="java">List list3 = new ArrayList();
//默认类型是E：Object
</code></pre>
</li>
</ol>
<pre><code class="java">class A &#123;&#125;
class B extends A &#123;&#125;
class Pig&lt;E&gt; &#123;//
E e;
public Pig(E e) &#123;
this.e = e;
&#125;
public void f() &#123;
System.out.println(e.getClass()); //运行类型
&#125;
&#125;

&#125;
class Tiger&lt;E&gt; &#123;//类
E e;
public Tiger() &#123;&#125;
public Tiger(E e) &#123;
this.e = e;
&#125;
&#125;


public class GenericDetail &#123;
public static void main(String[] args) &#123;
//1.给泛型指向数据类型是，要求是引用类型，不能是基本数据类型
List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //OK
//List&lt;int&gt; list2 = new ArrayList&lt;int&gt;();//错误
//2. 说明
//因为 E 指定了 A 类型, 构造器传入了 new A()
//在给泛型指定具体类型后，可以传入该类型或者其子类类型
Pig&lt;A&gt; aPig = new Pig&lt;A&gt;(new A());
aPig.f();
Pig&lt;A&gt; aPig2 = new Pig&lt;A&gt;(new B());
aPig2.f();
//3. 泛型的使用形式
ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();
List&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;();
//在实际开发中，我们往往简写
//编译器会进行类型推断, 老师推荐使用下面写法
ArrayList&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();
List&lt;Integer&gt; list4 = new ArrayList&lt;&gt;();
ArrayList&lt;Pig&gt; pigs = new ArrayList&lt;&gt;();
//4. 如果是这样写 泛型默认是 Object
ArrayList arrayList = new ArrayList();//等价 ArrayList&lt;Object&gt; arrayList = new ArrayList&lt;Object&gt;();
/*
public boolean add(Object e) &#123;
ensureCapacityInternal(size + 1); // Increments modCount!!
elementData[size++] = e;
return true;
&#125;
*/
Tiger tiger = new Tiger();
/*
class Tiger &#123;//类
Object e;
public Tiger() &#123;&#125;
public Tiger(Object e) &#123;
this.e = e;
&#125;
&#125;
*/
&#125;


</code></pre>
<h2 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h2><h3 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre><code class="java">//... 表示可以有多个
class 类名&lt;T,R,...&gt;&#123;
成员
&#125;
</code></pre>
<h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><pre><code class="java">
Class Tiger&lt;T,R,R&gt;&#123;
    String name;
    R r;
    M m;
    T t;
&#125;
</code></pre>
<h4 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h4><ol>
<li>普通成员可以使用泛型（属性，方法）</li>
<li>使用泛型的数组，不能初始化</li>
<li>静态方法中不能使用类的泛型</li>
<li>泛型类的类型，是在创建对象时确定的(因为创建对象时，需要指定确定类型)</li>
<li>如果创建对象时，没有指定类型，默认为Object</li>
</ol>
<pre><code class="java">public class CustomGeneric_ &#123;
public static void main(String[] args) &#123;
//T=Double, R=String, M=Integer
Tiger&lt;Double,String,Integer&gt; g = new Tiger&lt;&gt;(&quot;john&quot;);
g.setT(10.9); //OK
//g.setT(&quot;yy&quot;); //错误，类型不对
System.out.println(g);
Tiger g2 = new Tiger(&quot;john~~&quot;);//OK T=Object R=Object M=Object
g2.setT(&quot;yy&quot;); //OK ,因为 T=Object &quot;yy&quot;=String 是 Object 子类
System.out.println(&quot;g2=&quot; + g2);
&#125;
&#125;

//老韩解读
//1. Tiger 后面泛型，所以我们把 Tiger 就称为自定义泛型类
//2, T, R, M 泛型的标识符, 一般是单个大写字母
//3. 泛型标识符可以有多个. //4. 普通成员可以使用泛型 (属性、方法)
//5. 使用泛型的数组，不能初始化
//6. 静态方法中不能使用类的泛型
class Tiger&lt;T, R, M&gt; &#123;
String name;
R r; //属性使用到泛型
M m;
T t;
//因为数组在 new 不能确定 T 的类型，就无法在内存开空间
T[] ts;
public Tiger(String name) &#123;
this.name = name;
&#125;
public Tiger(R r, M m, T t) &#123;//构造器使用泛型
this.r = r;
this.m = m;
this.t = t;
&#125;
public Tiger(String name, R r, M m, T t) &#123;//构造器使用泛型
this.name = name;
this.r = r;
this.m = m;
this.t = t;
&#125;
//因为静态是和类相关的，在类加载时，对象还没有创建
//所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化
// static R r2;
// public static void m1(M m) &#123;
//
// &#125;
//方法使用泛型
public String getName() &#123;
return name;
&#125;
public void setName(String name) &#123;
this.name = name;
&#125;
public R getR() &#123;
return r;
&#125;
public void setR(R r) &#123;//方法使用到泛型
this.r = r;
&#125;
public M getM() &#123;//返回类型可以使用泛型. return m;
&#125;
public void setM(M m) &#123;
this.m = m;
&#125;
public T getT() &#123;
return t;
&#125;
public void setT(T t) &#123;
this.t = t;
&#125;
@Override
public String toString() &#123;
return &quot;Tiger&#123;&quot; +
&quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
&quot;, r=&quot; + r +
&quot;, m=&quot; + m +
&quot;, t=&quot; + t +
&quot;, ts=&quot; + Arrays.toString(ts) +
&#39;&#125;&#39;;
&#125;
&#125;
</code></pre>
<h3 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h3><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><pre><code class="java">interface 接口名 &lt;T,R...&gt;&#123;

&#125;
</code></pre>
<h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><pre><code class="java">interface IUsb&lt;U, R&gt; &#123;
int n = 10;
//U name; 不能这样使用，接口成员都是静态的public static final 修饰的
    
//普通方法中，可以使用接口泛型
R get(U u);
void hi(R r);
void run(R r1, R r2, U u1, U u2);
//在 jdk8 中，可以在接口中，使用默认方法, 也是可以使用泛型
default R method(U u) &#123;
return null;
&#125;
&#125;





//在继承接口 指定泛型接口的类型
interface IA extends IUsb&lt;String, Double&gt; &#123;
&#125;
//当我们去实现 IA 接口时，因为 IA 在继承 IUsu 接口时，指定了 U 为 String R 为 Double
//，在实现 IUsu 接口的方法时，使用 String 替换 U, 是 Double 替换 R
class AA implements IA &#123;
@Override
public Double get(String s) &#123;
return null;
&#125;
@Override
public void hi(Double aDouble) &#123;
&#125;
@Override
public void run(Double r1, Double r2, String u1, String u2) &#123;
&#125;
&#125;

//实现接口时，直接指定泛型接口的类型
//给 U 指定 Integer 给 R 指定了 Float
//所以，当我们实现 IUsb 方法时，会使用 Integer 替换 U, 使用 Float 替换 R
class BB implements IUsb&lt;Integer, Float&gt; &#123;
@Override
public Float get(Integer integer) &#123;
return null;
&#125;
@Override
public void hi(Float aFloat) &#123;
&#125;
@Override
public void run(Float r1, Float r2, Integer u1, Integer u2) &#123;
&#125;
&#125;



//没有指定类型，默认为 Object
//建议直接写成 IUsb&lt;Object,Object&gt;
class CC implements IUsb &#123; //等价 class CC implements IUsb&lt;Object,Object&gt; &#123;
@Override
public Object get(Object o) &#123;
return null;
&#125;
@Override
public void hi(Object o) &#123;
&#125;
@Override
public void run(Object r1, Object r2, Object u1, Object u2) &#123;
&#125;
&#125;
</code></pre>
<h4 id="注意细节-1"><a href="#注意细节-1" class="headerlink" title="注意细节"></a>注意细节</h4><ol>
<li>接口中，静态成员也不能使用泛型（和泛型类规定一样）</li>
<li>泛型接口的类型，在&#x3D;&#x3D;继承接口&#x3D;&#x3D;或&#x3D;&#x3D;实现接口&#x3D;&#x3D;时确定</li>
<li>没有指定类型，默认为Object；</li>
</ol>
<h3 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h3><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><pre><code class="java">修饰符 &lt;T,R...&gt; 返回类型 方法名(参数列表)&#123;
&#125;
</code></pre>
<h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><pre><code class="java">/**
* @author 韩顺平
* @version 1.0
* 泛型方法的使用
*/
@SuppressWarnings(&#123;&quot;all&quot;&#125;)
public class CustomMethodGeneric &#123;
public static void main(String[] args) &#123;
Car car = new Car();
car.fly(&quot;宝马&quot;, 100);//当调用方法时，传入参数，编译器，就会确定类型
System.out.println(&quot;=======&quot;);
car.fly(300, 100.1);//当调用方法时，传入参数，编译器，就会确定类型
//测试
//T-&gt;String, R-&gt; ArrayList
Fish&lt;String, ArrayList&gt; fish = new Fish&lt;&gt;();
fish.hello(new ArrayList(), 11.3f);
&#125;
&#125;


class Fish&lt;T, R&gt; &#123;//泛型类
public void run() &#123;//普通方法
&#125;
public&lt;U,M&gt; void eat(U u, M m) &#123;//泛型方法
&#125;
//说明
//1. 下面 hi 方法不是泛型方法
//2. 是 hi 方法使用了类声明的 泛型
public void hi(T t) &#123;
&#125;
//泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型 K是自己声明的，R时类的声明的
public&lt;K&gt; void hello(R r, K k) &#123;
System.out.println(r.getClass());//ArrayList
System.out.println(k.getClass());//Float
&#125;
&#125;


//泛型方法，可以定义在普通类中, 也可以定义在泛型类中
class Car &#123;//普通类
public void run() &#123;//普通方法
&#125;
//说明 泛型方法
//1. &lt;T,R&gt; 就是泛型
//2. 是提供给 fly 使用的
public &lt;T, R&gt; void fly(T t, R r) &#123;//泛型方法
System.out.println(t.getClass());//String
System.out.println(r.getClass());//Integer
&#125;
&#125;
</code></pre>
<h4 id="注意细节-2"><a href="#注意细节-2" class="headerlink" title="注意细节"></a>注意细节</h4><ol>
<li>泛型方法，可以定义在&#x3D;&#x3D;普通类&#x3D;&#x3D;中，也可以定义在&#x3D;&#x3D;泛型类&#x3D;&#x3D;中</li>
<li>但泛型方法被调用时，类型会确定</li>
<li>public void eat(E e){}，修饰符后没有&lt;T,R…&gt;eat 方法不是泛型方法，而是使用了泛型</li>
</ol>
<h2 id="泛型的继承和通配符"><a href="#泛型的继承和通配符" class="headerlink" title="泛型的继承和通配符"></a>泛型的继承和通配符</h2><ol>
<li><p>泛型不具备继承性</p>
<pre><code class="java">List&lt;Object&gt; list = new ArrayList&lt;String&gt;();不对
</code></pre>
</li>
<li><?>：支持任意泛型类型
</li>
<li><? extends A>：支持A类以及A类的子类，规定了泛型的上限
</li>
<li><p>&lt;？super A &gt;：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限</p>
</li>
</ol>
<pre><code class="java">//举例说明下面三个方法的使用
List&lt;Object&gt; list1 = new ArrayList&lt;&gt;();
List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
List&lt;AA&gt; list3 = new ArrayList&lt;&gt;();
List&lt;BB&gt; list4 = new ArrayList&lt;&gt;();
List&lt;CC&gt; list5 = new ArrayList&lt;&gt;();

printCollection1(list1);//√
printCollection1(list2);//√
printCollection1(list3);//√
printCollection1(list4);//√
printCollection1(list5);//√

//List&lt;? extends AA&gt; c： 表示 上限，可以接受 AA 或者 AA 子类
// printCollection2(list1);//×
// printCollection2(list2);//×
printCollection2(list3);//√
printCollection2(list4);//√
printCollection2(list5);//√

//List&lt;? super AA&gt; c: 支持 AA 类以及 AA 类的父类，不限于直接父类
printCollection3(list1);//√
//printCollection3(list2);//×
printCollection3(list3);//√
//printCollection3(list4);//×
//printCollection3(list5);//×

//说明: List&lt;?&gt; 表示 任意的泛型类型都可以接受
public static void printCollection1(List&lt;?&gt; c) &#123;
for (Object object : c) &#123; // 通配符，取出时，就是 Object
System.out.println(object);
&#125;
&#125;

// ? extends AA 表示 上限，可以接受 AA 或者 AA 子类
public static void printCollection2(List&lt;? extends AA&gt; c) &#123;
for (Object object : c) &#123;
System.out.println(object);
&#125;
&#125;

// ? super 子类类名 AA:支持 AA 类以及 AA 类的父类，不限于直接父类，
//规定了泛型的下限
public static void printCollection3(List&lt;? super AA&gt; c) &#123;
for (Object object : c) &#123;
System.out.println(object);
&#125;
&#125;



class AA &#123;
&#125;
class BB extends AA &#123;
&#125;
class CC extends BB &#123;
&#125;
</code></pre>
<h1 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h1><h2 id="线程相关概念"><a href="#线程相关概念" class="headerlink" title="线程相关概念"></a>线程相关概念</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>是为了完成特定任务、用某种语言编写的一组指令的集合。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ol>
<li>进程是指运行中的程序，比如我们使用QQ，就启动了一个进程，操作系统会为该进程分配内存空间。当我们使用迅雷，又启动了一个进程，操作系统将为迅雷分配新的内存空间</li>
<li>进程是程序的一次执行过程，或是正在运行的一个程序，是一个动态过程，有它自身的产生、存在和消亡的过程。</li>
</ol>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ol>
<li>线程由进程创建的，是进程的一个实体</li>
<li>一个进程可以拥有多个线程。</li>
</ol>
<h3 id="其他相关概念"><a href="#其他相关概念" class="headerlink" title="其他相关概念"></a>其他相关概念</h3><p><strong>单线程</strong>：同一时刻，只允许执行一个线程</p>
<p><strong>多线程</strong>：同一时刻，可以执行多个线程，比如：一个QQ进程，可以同时打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件。</p>
<p><strong>并发</strong>：同一个时刻，多个任务交替执行，造成一种“貌似同时”的错觉，简单地说，单核CPU实现多任务就是并发。</p>
<p><strong>并行</strong>：同一时刻，多个任务同时执行，多核cpu可以实现并行。</p>
<h2 id="创建线程的两种方式"><a href="#创建线程的两种方式" class="headerlink" title="创建线程的两种方式"></a>创建线程的两种方式</h2><h3 id="继承Thread类，重写run-方法"><a href="#继承Thread类，重写run-方法" class="headerlink" title="继承Thread类，重写run()方法"></a>继承Thread类，重写run()方法</h3><p> 当 main 线程启动一个子线程 Thread-0, 主线程不会阻塞, 会继续执行</p>
<pre><code class="java">public class Thread01 &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        threadExercise threadExercise = new threadExercise();

        threadExercise.start();
        for (int i = 0; i &lt; 50; i++) &#123;
            System.out.println(Thread.currentThread().getName());
            Thread.sleep(5000);
        &#125;
    &#125;
&#125;

class threadExercise extends Thread &#123;
    boolean flag = true;
    int count = 0;

    @Override
    public void run() &#123;
        while (flag) &#123;

            System.out.println(&quot;我是傻逼              &quot; + Thread.currentThread().getName());
            count++;
            try &#123;
                Thread.sleep(500);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            if (count == 80) &#123;
                break;
            &#125;
        &#125;

    &#125;
&#125;
</code></pre>
<h3 id="实现Runnable接口，重写run-方法"><a href="#实现Runnable接口，重写run-方法" class="headerlink" title="实现Runnable接口，重写run()方法"></a>实现Runnable接口，重写run()方法</h3><p>使用到了&#x3D;&#x3D;静态代理模式&#x3D;&#x3D;，进程中main线程创建完对象调用方法后就会关闭，创建好的Thread01线程继续执行。</p>
<pre><code class="java">public class Thread02 &#123;
    public static void main(String[] args) &#123;
        Thread thread = new Thread(new A());
        thread.start();

    &#125;
&#125;

class A implements Runnable &#123;
    @Override
    public void run() &#123;
        while (true) &#123;
            System.out.println(&quot;谁是傻逼&quot;+Thread.currentThread().getName());
            try &#123;
                Thread.sleep(1000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="程序运行机制"><a href="#程序运行机制" class="headerlink" title="程序运行机制"></a>程序运行机制</h2><p>thread.start();方法执行，&gt; 最终会执行 cat 的 run 方法</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220618191218079.png" alt="image-20220618191218079"></p>
<p>start0() 是本地方法，是 JVM 调用, 底层是 c&#x2F;c++实现。</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220618191237103.png" alt="image-20220618191237103"></p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220618191556467.png" alt="image-20220618191556467"></p>
<h2 id="继承Thread-VS-实现Runnable区别"><a href="#继承Thread-VS-实现Runnable区别" class="headerlink" title="继承Thread VS 实现Runnable区别"></a>继承Thread VS 实现Runnable区别</h2><ol>
<li>通过继承Thread或者实现Runnable接口来创建线程本质上没有区别，从jdk帮助文档我们可以看到Thread类本身就实现了Runnable接口</li>
<li>实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制，建议使用Runnable</li>
</ol>
<h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><ol>
<li><p>当线程完成任务后，会自动退出。</p>
</li>
<li><p>还可以通过变量来控制run方法退出的方式停止线程，即通知方式</p>
</li>
</ol>
<pre><code class="java">public class SellTicket &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        SellTicket01 sellTicket01 = new SellTicket01();
        SellTicket01 sellTicket02 = new SellTicket01();
        SellTicket01 sellTicket03 = new SellTicket01();
        sellTicket01.start();
        sellTicket02.start();
        sellTicket03.start();
        Thread.sleep(1000);
        sellTicket01.setflag(false);
    &#125;
&#125;

class SellTicket01 extends Thread &#123;
    private static int num = 100;//共享
    private boolean flag = true;

    @Override
    public void run() &#123;

        while (flag) &#123;
            if (num &lt;= 0) &#123;
                System.out.println(&quot;没票了&quot;);
                break;
            &#125;
            System.out.println(Thread.currentThread().getName() + &quot;售票-1   &quot; + num);
            num--;
            try &#123;
                Thread.sleep(500);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

    public void setflag(boolean loop)&#123;
        this.flag = loop;
    &#125;
&#125;
</code></pre>
<h2 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h2><pre><code class="java">1. setName //设置线程名称，使之于参数name相同
2. getName //返回该线程的名称
3. start //使线程开始执行；java虚拟机底层调用该线程的start0方法
4. run //调用线程对象run方法
5. setPriority //更改线程的优先级
6. getPriority //获取线程使用优先级
7. sleep //在指定毫秒数内让当前正在执行的线程休眠（暂时执行）
8. interrupt //中断线程，不是终止，会让线程从休眠状态醒过来
    
1. yield //线程的礼让。让出cpu，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功。
2. join //线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程的所有任务，在执行原来线程的任务（一定会插入成功的）。
</code></pre>
<h3 id="interrupt-实例"><a href="#interrupt-实例" class="headerlink" title="interrupt 实例"></a>interrupt 实例</h3><pre><code class="java">//interrupt 实例
public class ThreadMethod01 &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        T t = new T();
        t.start();
        //设置优先级
        t.setPriority(Thread.MIN_PRIORITY);
        Thread.sleep(1000);
        System.out.println(&quot;main线程过了1秒调用interrupt方法&quot;);
        System.out.println(new Date(System.currentTimeMillis()));
        t.interrupt();

    &#125;
&#125;

class T extends Thread &#123;
    @Override
    public void run() &#123;
        while (true) &#123;
            for (int i = 0; i &lt; 100; i++) &#123;
                System.out.println(&quot;测试interrupt方法&quot; + i);
            &#125;
            try &#123;
                System.out.println(&quot;休眠10秒&quot;);
                Thread.sleep(10000);
            &#125; catch (InterruptedException e) &#123;
                System.out.println(&quot;被唤醒时间：&quot; + new Date(System.currentTimeMillis()));
                System.out.println(Thread.currentThread().getName() + &quot;被执行interrupt方法了&quot;);
            &#125;
        &#125;
    &#125;
&#125;
/*.....
测试interrupt方法97
测试interrupt方法98
测试interrupt方法99
休眠10秒
main线程过了1秒调用interrupt方法
Mon Jun 20 04:24:57 CST 2022
被唤醒时间：Mon Jun 20 04:24:57 CST 2022
Thread-0被执行interrupt方法了
测试interrupt方法0
.....
*/
</code></pre>
<h3 id="join-实例"><a href="#join-实例" class="headerlink" title="join 实例"></a>join 实例</h3><pre><code class="java">public class ThreadMethod02 &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        T2 t2 = new T2();
        t2.start();
        for (int i = 1; i &lt;= 20; i++) &#123;
            Thread.sleep(1000);
            if (i == 5) &#123;
                t2.join();
            &#125;
            System.out.println(&quot;主线程执行    &quot; + i);
        &#125;
    &#125;
&#125;

class T2 extends Thread &#123;
    @Override
    public void run() &#123;
        for (int i = 1; i &lt;= 20; i++) &#123;
            try &#123;
                Thread.sleep(1000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;子线程执行    &quot; + i);
        &#125;
    &#125;
&#125;
/*....
子线程执行    3
子线程执行    4
主线程执行    4
子线程执行    5
子线程执行    6
子线程执行    7
子线程执行    8
子线程执行    9
子线程执行    10
子线程执行    11
....
*/
</code></pre>
<h3 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h3><ol>
<li>start 底层会创建新的线程，调用run，run就是一个简单的方法调用，不会启动新线程</li>
<li>线程优先级的范围</li>
<li>interrupt，中断线程，但并没有真正的结束线程。所以一般用于终端正在休眠线程</li>
<li>sleep现成的静态方法，使当前线程休眠</li>
</ol>
<h2 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h2><ol>
<li>用户线程：也叫工作线程，当线程的任务执行完或通知方式结束</li>
<li>守护线程：一般是为工作线程服务的，当所有用户线程结束，守护线程自动结束</li>
<li>常见守护线程：垃圾回收机制</li>
</ol>
<pre><code class="java">public class ThreadMethod02 &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        T2 t2 = new T2();
        t2.start();
        //设置t2为守护线程
        t2.setDaemon(true);
        &#125;
        
class T2 extends Thread &#123;
    @Override
    public void run() &#123;
        for (int i = 1; i &lt;= 20; i++) &#123;
            try &#123;
                Thread.sleep(1000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;守护线程    &quot; + i);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>JDK中用Thread.State枚举表示了线程的几种状态</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220620050423270.png" alt="image-20220620050423270"></p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220620051208451.png" alt="image-20220620051208451"></p>
<pre><code class="Java">public class ThreadState &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        T t = new T();
        System.out.println(t.getState());
        t.start();
        System.out.println(t.getState());
        while(t.getState()!=Thread.State.TERMINATED)&#123;
            System.out.println(t.getState());
            Thread.sleep(500);
        &#125;
        System.out.println(t.getState());
    &#125;
&#125;

class T extends Thread &#123;
    @Override
    public void run() &#123;
        while (true) &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
//                System.out.println(&quot;i=&quot; + i);
                try &#123;
                    Thread.sleep(500);
//                    System.out.println(&quot;t线程当前状态&quot;+this.getState());
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            break;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><ol>
<li>多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性。</li>
<li>线程同步，当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作。</li>
</ol>
<h3 id="具体使用方法-Synchronized"><a href="#具体使用方法-Synchronized" class="headerlink" title="具体使用方法-Synchronized"></a>具体使用方法-Synchronized</h3><ol>
<li>同步代码块</li>
</ol>
<pre><code class="java">synchronized(对象)&#123;//得到对象的锁，才能操作同步代码
//需要被同步代码
&#125;
</code></pre>
<ol start="2">
<li>synchronized还可以放在方法声明中，表示整个方法-为同步方法</li>
</ol>
<pre><code class="java">public synchronized void m(String name)&#123;
//需要被同步代码
&#125;
</code></pre>
<ol start="3">
<li>静态方法</li>
</ol>
<pre><code class="java">public static void m2() &#123;
        synchronized (类名.class) &#123;
            System.out.println(&quot;静态方法的同步块不能使用this，默认当前类.class&quot;);
        &#125;
    &#125;
</code></pre>
<h3 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a>同步原理</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220620131546670.png" alt="image-20220620131546670"></p>
<p>三个线程同时去抢一把锁，抢到后执行自己的逻辑代码，执行完毕后把锁还回去。接着三个线程再次抢这把锁，在执行….</p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li>Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。</li>
<li>每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任意时刻，只能由一个线程访问该对象。</li>
<li>关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任意时刻只能有一个线程访问。</li>
<li>同步的局限性：导致程序的执行效率要降低</li>
<li>同步方法（非静态）的锁可以是this，也可以是其他对象（要求是同一个对象）</li>
<li>同步方法（静态的）的锁为当前类本身</li>
</ol>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><pre><code class="java">/**
 * @author 张文辉
 * @version 1.0
 * 多线程模拟三个窗口同时售票100张
 */
public class SellTicket &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        SellTicket01 sellTicket01 = new SellTicket01();
        SellTicket01 sellTicket02 = new SellTicket01();
        SellTicket01 sellTicket03 = new SellTicket01();
        sellTicket01.start();
        sellTicket02.start();
        sellTicket03.start();
    &#125;
&#125;



class SellTicket01 extends Thread &#123;
    private static int num = 100;//多个线程共享共享
    private static Object object = new Object();
    private boolean flag = true;

    public static void m2() &#123;
        synchronized (SellTicket01.class) &#123; //锁加在类对象上
            System.out.println(&quot;静态方法的同步块不能使用this，默认当前类.class&quot;);
        &#125;
        /*
        * public synchronized static void m1() &#123;
            &#125;
        * 静态方法直接加synchronized
        */
    &#125;

    public /*synchronized*/ void m1() &#123; //同步方法, 在同一时刻， 只能有一个线程来执行 sell 方法
//            synchronized(this) &#123;    //加在this对象上
        synchronized (object) &#123;//加在其他对象上，要求是同一个对象
            if (num &lt;= 0) &#123;
                System.out.println(&quot;没票了&quot;);
                flag = false;
                return;
            &#125;
            System.out.println(Thread.currentThread().getName() + &quot;售票-1   &quot; + num);
            num--;
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
//    &#125;
    &#125;

    @Override
    public void run() &#123;
        while (flag) &#123;
            m1();
        &#125;
    &#125;

    public void setflag(boolean loop) &#123;
        this.flag = loop;
    &#125;
&#125;
</code></pre>
<h3 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>同步方法如果没有使用static修饰：默认锁对象为this</p>
</li>
<li><p>如果方法使用static修饰，默认锁对象：当前类.class</p>
</li>
</ol>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>多个线程都占用了对方的锁资源，不肯让步，导致了死锁，一定要避免死锁现象的发生。</p>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><pre><code class="java">package hsppedu.Homework.threaduse_;

/**
 * @author 张文辉
 * @version 1.0
 */


public class DeadLock_ &#123;
    public static void main(String[] args) &#123;
//模拟死锁现象
        DeadLockDemo A = new DeadLockDemo(true);
        A.setName(&quot;A 线程&quot;);
        DeadLockDemo B = new DeadLockDemo(false);
        B.setName(&quot;B 线程&quot;);
        A.start();
        B.start();
    &#125;
&#125;
class DeadLockDemo extends Thread &#123;
    static Object o1 = new Object();// 保证多线程，共享一个对象,这里使用 static
    static Object o2 = new Object();
    boolean flag;

    public DeadLockDemo(boolean flag) &#123;//构造器
        this.flag = flag;
    &#125;

    @Override
    public void run() &#123;
//下面业务逻辑的分析
//1. 如果 flag 为 T, 线程 A 就会先得到/持有 o1 对象锁, 然后尝试去获取 o2 对象锁
//2. 如果线程 A 得不到 o2 对象锁，就会 Blocked
//3. 如果 flag 为 F, 线程 B 就会先得到/持有 o2 对象锁, 然后尝试去获取 o1 对象锁
//4. 如果线程 B 得不到 o1 对象锁，就会 Blocked
        if (flag) &#123;
            synchronized (o1) &#123;//对象互斥锁, 下面就是同步代码
                System.out.println(Thread.currentThread().getName() + &quot; 进入 1&quot;);
                synchronized (o2) &#123; // 这里获得 li 对象的监视权
                    System.out.println(Thread.currentThread().getName() + &quot; 进入 2&quot;);
                &#125;
            &#125;
        &#125; else &#123;
            synchronized (o2) &#123;
                System.out.println(Thread.currentThread().getName() + &quot; 进入 3&quot;);
                synchronized (o1) &#123; // 这里获得 li 对象的监视权
                    System.out.println(Thread.currentThread().getName() + &quot; 进入 4&quot;);
                &#125;
            &#125;


        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><ol>
<li>当前线程的同步方法，同步代码块执行结束</li>
<li>当前线程在同步代码块、同步方法中遇到break、return。</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁</li>
</ol>
<h3 id="不会释放锁"><a href="#不会释放锁" class="headerlink" title="不会释放锁"></a>不会释放锁</h3><ol>
<li><p>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行，不会释放锁</p>
</li>
<li><p>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂机，该线程不会释放锁。</p>
<p>应尽量避免使用suspend()和resume()来控制线程，方法不再推荐使用</p>
</li>
</ol>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>流：数据在数据源（文件）和程序（内存）之间经历的路径</p>
<p>输入流：数据从数据源（文件）到程序（内存）的路径</p>
<p>输出流：数据从程序（内存）到数据源（文件）的路径</p>
<h2 id="常用文件操作"><a href="#常用文件操作" class="headerlink" title="常用文件操作"></a>常用文件操作</h2><h3 id="创建文件对象相关构造器和方法"><a href="#创建文件对象相关构造器和方法" class="headerlink" title="创建文件对象相关构造器和方法"></a>创建文件对象相关构造器和方法</h3><p>new File(String pathname) &#x2F;&#x2F;根据路径构建一个File对象</p>
<p>new File（File parent，String child） &#x2F;&#x2F;根据附目录文件+子路径构建</p>
<p>new File（String parent,String child）&#x2F;&#x2F;根据父目录+子路径构建</p>
<p>createNewFile  创建新文件</p>
<pre><code class="java">    @Test
    //方式 1 new File(String pathnam
    public void create01()&#123;
        String filePath = &quot;e://testFile.txt&quot;;
        File file = new File(filePath);
        try &#123;
            file.createNewFile();
            System.out.println(&quot;文件创建成功&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    @Test
    //方式 2 new File(File parent,String child) //根据父目录文件+子路径构建
    public void create02()&#123;
        String filePath = &quot;e://&quot;;
        File file = new File(new File(filePath),&quot;testFile2.txt&quot;);
        try &#123;
            file.createNewFile();
            System.out.println(&quot;文件创建成功&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    @Test
    //方式 3 new File(String parent,String child) //根据父目录+子路径构建
    public void create03()&#123;
        File file = new File(&quot;e://&quot;,&quot;testFile3.txt&quot;);
        try &#123;
            file.createNewFile();
            System.out.println(&quot;文件创建成功&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<h3 id="获取文件相关信息"><a href="#获取文件相关信息" class="headerlink" title="获取文件相关信息"></a>获取文件相关信息</h3><p>getName</p>
<p>getAbsolutePath</p>
<p>getParent</p>
<p>Length</p>
<p>exists</p>
<p>isFile</p>
<p>isDirectory</p>
<pre><code class="java">//获取文件的信息
@Test
public void info() &#123;
//先创建文件对象
File file = new File(&quot;e:\\news1.txt&quot;);
//调用相应的方法，得到对应信息
System.out.println(&quot;文件名字=&quot; + file.getName());
//getName、getAbsolutePath、getParent、length、exists、isFile、isDirectory
System.out.println(&quot;文件绝对路径=&quot; + file.getAbsolutePath());
System.out.println(&quot;文件父级目录=&quot; + file.getParent());
System.out.println(&quot;文件大小(字节)=&quot; + file.length());
System.out.println(&quot;文件是否存在=&quot; + file.exists());//T
System.out.println(&quot;是不是一个文件=&quot; + file.isFile());//T
System.out.println(&quot;是不是一个目录=&quot; + file.isDirectory());//F
&#125;
</code></pre>
<h2 id="IO流原理及流的分类"><a href="#IO流原理及流的分类" class="headerlink" title="IO流原理及流的分类"></a>IO流原理及流的分类</h2><h3 id="IO流原理"><a href="#IO流原理" class="headerlink" title="IO流原理"></a>IO流原理</h3><ol>
<li>IO是Input&#x2F;Output的缩写，IO技术是非常实用的技术，用于处理数据传输，如读写文件，网络通讯等</li>
<li>java程序中，对于数据的输入&#x2F;输出操作以流Stream的方式进行</li>
<li>java.io报下提供了各种流类和接口，用于获取不同种类的数据，并通过方法输入或输出数据</li>
<li>输入input：读取外部数据，（磁盘，光盘等存储设备的数据）到（程序）中。</li>
<li>输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。</li>
</ol>
<h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><p>按操作数据单位不同分为：字节流（8 bit） 二进制文件，字符流（按字符）文本文件</p>
<p>按数据流的流向不同分为：输入流，输出流</p>
<p>按流的角色不同分为：节点流，处理流&#x2F;包装流</p>
<p><img src="/java/java-xue-xi-wen-dang/image-20220628051542083.png" alt="image-20220628051542083"></p>
<h2 id="IO流体系图"><a href="#IO流体系图" class="headerlink" title="IO流体系图"></a>IO流体系图</h2><p><img src="/java/java-xue-xi-wen-dang/image-20220628051736857.png" alt="image-20220628051736857"></p>
<h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><pre><code class="java">@Test
public void readFile01() &#123;
String filePath = &quot;e:\\hello.txt&quot;;
int readData = 0;
FileInputStream fileInputStream = null;
try &#123;
//创建 FileInputStream 对象，用于读取 文件
fileInputStream = new FileInputStream(filePath);
//从该输入流读取一个字节的数据。 如果没有输入可用，此方法将阻止。
//如果返回-1 , 表示读取完毕
while ((readData = fileInputStream.read()) != -1) &#123;
System.out.print((char)readData);//转成 char 显示
&#125;
&#125; catch (IOException e) &#123;
e.printStackTrace();
&#125; finally &#123;
//关闭文件流，释放资源.
try &#123;
fileInputStream.close();
&#125; catch (IOException e) &#123;
e.printStackTrace();
&#125;
&#125;
&#125;



/**
* 使用 read(byte[] b) 读取文件，提高效率
*/
@Test
public void readFile02() &#123;
String filePath = &quot;e:\\hello.txt&quot;;
//字节数组
byte[] buf = new byte[8]; //一次读取 8 个字节. int readLen = 0;
FileInputStream fileInputStream = null;
try &#123;
//创建 FileInputStream 对象，用于读取 文件
fileInputStream = new FileInputStream(filePath);
//从该输入流读取最多 b.length 字节的数据到字节数组。 此方法将阻塞，直到某些输入可用。
//如果返回-1 , 表示读取完毕
//如果读取正常, 返回实际读取的字节数
while ((readLen = fileInputStream.read(buf)) != -1) &#123;
System.out.print(new String(buf, 0, readLen));//显示
&#125;
&#125; catch (IOException e) &#123;
e.printStackTrace();
&#125; finally &#123;
//关闭文件流，释放资源. try &#123;
fileInputStream.close();
&#125; catch (IOException e) &#123;
e.printStackTrace();
&#125;
&#125;
&#125;
&#125;
</code></pre>
<h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><p><img src="/java/java-xue-xi-wen-dang/image-20220628060030244.png" alt="image-20220628060030244"></p>
<pre><code class="java">public void writeFile() &#123;
//创建 FileOutputStream 对象
String filePath = &quot;e:\\a.txt&quot;;
FileOutputStream fileOutputStream = null;
try &#123;
//得到 FileOutputStream 对象 对象
//老师说明
//1. new FileOutputStream(filePath) 创建方式，当写入内容是，会覆盖原来的内容
//2. new FileOutputStream(filePath, true) 创建方式，当写入内容是，是追加到文件后面
fileOutputStream = new FileOutputStream(filePath, true);
//写入一个字节
//fileOutputStream.write(&#39;H&#39;);//
//写入字符串
String str = &quot;hsp,world!&quot;;
//str.getBytes() 可以把 字符串-&gt; 字节数组
//fileOutputStream.write(str.getBytes());
/*
write(byte[] b, int off, int len) 将 len 字节从位于偏移量 off 的指定字节数组写入此文件输出流
*/
fileOutputStream.write(str.getBytes(), 0, 3);
&#125; catch (IOException e) &#123;
e.printStackTrace();
&#125; finally &#123;
try &#123;
fileOutputStream.close();
&#125; catch (IOException e) &#123;
e.printStackTrace();
&#125;
&#125;
&#125;
&#125;
</code></pre>
<pre><code class="java">public class FileCopy &#123;
public static void main(String[] args) &#123;
//完成 文件拷贝，将 e:\\Koala.jpg 拷贝 e:\\Koala3.jpg
//思路分析
//1. 创建文件的输入流 , 将文件读入到程序
//2. 创建文件的输出流， 将读取到的文件数据，写入到指定的文件. String srcFilePath = &quot;e:\\Koala.jpg&quot;;
String destFilePath = &quot;e:\\Koala3.jpg&quot;;
FileInputStream fileInputStream = null;
FileOutputStream fileOutputStream = null;
try &#123;
fileInputStream = new FileInputStream(srcFilePath);
fileOutputStream = new FileOutputStream(destFilePath);
//定义一个字节数组,提高读取效果
byte[] buf = new byte[1024];
int readLen = 0;
while ((readLen = fileInputStream.read(buf)) != -1) &#123;
//读取到后，就写入到文件 通过 fileOutputStream
//即，是一边读，一边写
fileOutputStream.write(buf, 0, readLen);//一定要使用这个方法
&#125;
System.out.println(&quot;拷贝 ok~&quot;);
&#125; catch (IOException e) &#123;
e.printStackTrace();
&#125; finally &#123;
try &#123;
//关闭输入流和输出流，释放资源
if (fileInputStream != null) &#123;
fileInputStream.close();
&#125;
if (fileOutputStream != null) &#123;
fileOutputStream.close();
&#125;
&#125; catch (IOException e) &#123;
e.printStackTrace();
&#125;
&#125;
&#125;
&#125;
</code></pre>
<h2 id="FileReader-和-FileWriter介绍"><a href="#FileReader-和-FileWriter介绍" class="headerlink" title="FileReader 和 FileWriter介绍"></a>FileReader 和 FileWriter介绍</h2><p><img src="/java/java-xue-xi-wen-dang/image-20220628075753227.png" alt="image-20220628075753227"></p>
<h3 id="FileReader-相关方法"><a href="#FileReader-相关方法" class="headerlink" title="FileReader 相关方法"></a>FileReader 相关方法</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220628075825344.png" alt="image-20220628075825344"></p>
<h3 id="FileWriter-常用方法"><a href="#FileWriter-常用方法" class="headerlink" title="FileWriter 常用方法"></a>FileWriter 常用方法</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220628084314871.png" alt="image-20220628084314871"></p>
<pre><code class="java">public class FileReader_ &#123;
public static void main(String[] args) &#123;
&#125;
/**
* 单个字符读取文件
*/
@Test
public void readFile01() &#123;
String filePath = &quot;e:\\story.txt&quot;;
FileReader fileReader = null;
int data = 0;
//1. 创建 FileReader 对象
try &#123;
fileReader = new FileReader(filePath);
//循环读取 使用 read, 单个字符读取
while ((data = fileReader.read()) != -1) &#123;
System.out.print((char) data);
&#125;
&#125; catch (IOException e) &#123;
e.printStackTrace();
&#125; finally &#123;
try &#123;
if (fileReader != null) &#123;
fileReader.close();
&#125;
&#125; catch (IOException e) &#123;
e.printStackTrace();
&#125;
&#125;
&#125;
/**
* 字符数组读取文件
*/
@Test
public void readFile02() &#123;
System.out.println(&quot;~~~readFile02 ~~~&quot;);
String filePath = &quot;e:\\story.txt&quot;;
FileReader fileReader = null;
int readLen = 0;
char[] buf = new char[8];
//1. 创建 FileReader 对象
try &#123;
fileReader = new FileReader(filePath);
//循环读取 使用 read(buf), 返回的是实际读取到的字符数
//如果返回-1, 说明到文件结束
while ((readLen = fileReader.read(buf)) != -1) &#123;
System.out.print(new String(buf, 0, readLen));
&#125;
&#125; catch (IOException e) &#123;
e.printStackTrace();
&#125; finally &#123;
try &#123;
if (fileReader != null) &#123;
fileReader.close();
&#125;
&#125; catch (IOException e) &#123;
e.printStackTrace();
&#125;
&#125;
&#125;
&#125;
</code></pre>
<pre><code class="java">public class FileWriter_ &#123;
public static void main(String[] args) &#123;
String filePath = &quot;e:\\note.txt&quot;;
//创建 FileWriter 对象
FileWriter fileWriter = null;
char[] chars = &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;;
try &#123;
fileWriter = new FileWriter(filePath);//默认是覆盖写入
// 3) write(int):写入单个字符
fileWriter.write(&#39;H&#39;);
// 4) write(char[]):写入指定数组
fileWriter.write(chars);
// 5) write(char[],off,len):写入指定数组的指定部分
fileWriter.write(&quot;韩顺平教育&quot;.toCharArray(), 0, 3);
// 6) write（string）：写入整个字符串
fileWriter.write(&quot; 你好北京~&quot;);
fileWriter.write(&quot;风雨之后，定见彩虹&quot;);
// 7) write(string,off,len):写入字符串的指定部分
fileWriter.write(&quot;上海天津&quot;, 0, 2);
//在数据量大的情况下，可以使用循环操作. &#125; catch (IOException e) &#123;
e.printStackTrace();
&#125; finally &#123;
//对应 FileWriter , 一定要关闭流，或者 flush 才能真正的把数据写入到文件
//老韩看源码就知道原因. 
/*
看看代码
private void writeBytes() throws IOException &#123;
this.bb.flip();
int var1 = this.bb.limit();
int var2 = this.bb.position();
assert var2 &lt;= var1;
int var3 = var2 &lt;= var1 ? var1 - var2 : 0;
if (var3 &gt; 0) &#123;
if (this.ch != null) &#123;
assert this.ch.write(this.bb) == var3 : var3;
&#125; else &#123;
this.out.write(this.bb.array(), this.bb.arrayOffset() + var2,var3);
&#125;
&#125;
this.bb.clear();
&#125;
*/
try &#123;
//fileWriter.flush();
//关闭文件流，等价 flush() + 关闭
fileWriter.close();
&#125; catch (IOException e) &#123;
e.printStackTrace();
&#125;
&#125;
System.out.println(&quot;程序结束...&quot;);
&#125;
&#125;
</code></pre>
<h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li><p>节点流可以从一个特定的数据源读写数据，如FileReader、FileWriter</p>
</li>
<li><p>处理流，也叫包装流，是连接在已存在的流（节点流或处理流）之上的，为程序提供更为强大的读写功能，也更加灵活，如BufferedReader、BufferedWriter</p>
</li>
</ol>
<h3 id="节点流和处理流一览图"><a href="#节点流和处理流一览图" class="headerlink" title="节点流和处理流一览图"></a>节点流和处理流一览图</h3><p><img src="/java/java-xue-xi-wen-dang/image-20220628085557719.png" alt="image-20220628085557719"></p>
<h3 id="节点流和处理流的区别和联系"><a href="#节点流和处理流的区别和联系" class="headerlink" title="节点流和处理流的区别和联系"></a>节点流和处理流的区别和联系</h3><ol>
<li>节点流是底层流&#x2F;低级流，直接跟数据源相接</li>
<li>处理流（包装流）包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便发的方法来完成输入输出。</li>
<li>处理流（也叫包装流）对节点流进行包装，使用了修饰器设计模式，不是直接与数据源相连</li>
</ol>
<h3 id="处理流的功能主要体现在以下两个方面"><a href="#处理流的功能主要体现在以下两个方面" class="headerlink" title="处理流的功能主要体现在以下两个方面"></a>处理流的功能主要体现在以下两个方面</h3><ol>
<li>性能的提高：主要以增加缓冲的方式来提高输入输出的效率</li>
<li>操作的便捷：处理流可以提供一些便捷的方法来依次输入输出大批量的数据，使用更加灵活方便。</li>
</ol>
<h3 id="处理流-BufferedReader-和-BufferedWriter"><a href="#处理流-BufferedReader-和-BufferedWriter" class="headerlink" title="处理流-BufferedReader 和 BufferedWriter"></a>处理流-BufferedReader 和 BufferedWriter</h3><p>BufferedReader 和 BufferedWriter 属于字符流，是按照字符来读取数据的</p>
<p>关闭时处理流，只需要关闭外层流即可。</p>
<pre><code class="java">public class BufferedReader_ &#123;
public static void main(String[] args) throws Exception &#123;
String filePath = &quot;e:\\a.java&quot;;
//创建 bufferedReader
BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath);
//读取
String line; //按行读取, 效率高
//说明
//1. bufferedReader.readLine() 是按行读取文件
//2. 当返回 null 时，表示文件读取完毕
while ((line = bufferedReader.readLine()) != null) &#123;
System.out.println(line);
&#125;
//关闭流, 这里注意，只需要关闭 BufferedReader ，因为底层会自动的去关闭 节点流
//FileReader。
/*
public void close() throws IOException &#123;
synchronized (lock) &#123;
if (in == null)
return;
try &#123;
in.close();//in 就是我们传入的 new FileReader(filePath), 关闭了. &#125; finally &#123;
in = null;
cb = null;
&#125;
&#125;
&#125;
*/
bufferedReader.close();
&#125;
&#125;
</code></pre>
<h2 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h2>
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">三山</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://star-light-star-bright.github.io/java/java-xue-xi-wen-dang/">https://star-light-star-bright.github.io/java/java-xue-xi-wen-dang/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">三山</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Java/">
                                    <span class="chip bg-color">Java</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/cdh/centos7-chi-xian-an-zhuang-cdh5.16-ji-qun/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="CDH5.16的搭建">
                        
                        <span class="card-title">CDH5.16的搭建</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-12-25
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/CDH/" class="post-category">
                                    CDH
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/CDH/">
                        <span class="chip bg-color">CDH</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/java/static/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="Static">
                        
                        <span class="card-title">Static</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-02-17
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2025</span>
            
            <a href="/about" target="_blank">三山</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
